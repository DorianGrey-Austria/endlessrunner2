<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Subway Runner 3D - V4.8-AUDIO-SAFE</title>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- Headtrackr.js for stable head tracking -->
    <script src="https://cdn.jsdelivr.net/gh/auduno/headtrackr/headtrackr.min.js"></script>
    
    <script type="module">
        // Pre-load Gesture Control Module with better fallback
        import('./js/GestureControllerProjector.js')
            .then(module => {
                window.GestureControllerProjector = module.GestureControllerProjector || module.default;
                console.log('✅ Gesture Module pre-loaded successfully');
            })
            .catch(error => {
                console.warn('⚠️ Gesture Module not found, using stub:', error.message);
                // Create a stub to prevent errors
                window.GestureControllerProjector = class {
                    constructor() {
                        console.log('Using gesture control stub');
                    }
                    init() { return Promise.resolve(); }
                    start() { }
                    stop() { }
                    isActive() { return false; }
                };
            });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            max-width: 133.33vh; /* 4:3 aspect ratio */
            max-height: 75vw;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: right;
            z-index: 100;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            z-index: 1000;
            min-width: 300px;
        }
        
        #menu h1 {
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        #menu button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #menu button:hover {
            background: #45a049;
        }
        
        #timer {
            font-size: 20px;
            margin-top: 5px;
        }
        
        #gestureControl {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 9999 !important;
            display: block !important;
        }
        
        #gestureControlBtn {
            background: rgba(0, 255, 136, 0.9);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 255, 136, 0.3);
            transition: all 0.3s;
        }
        
        #gestureControlBtn:hover {
            background: #00ff88;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.5);
        }
        
        #gestureControlBtn.active {
            background: #ff4444;
        }
        
        #gestureCanvas {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 135px;
            border: 2px solid #00ff88;
            border-radius: 8px;
            display: none;
            z-index: 150;
            background: #000;
        }
        
        #gestureCanvas.active {
            display: block;
        }
        
        #gestureStatus {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            z-index: 150;
        }
        
        #gestureStatus.active {
            display: block;
        }
        
        .timer-warning {
            color: #FF4444 !important;
            animation: pulse 0.5s infinite;
        }
        
        .timer-critical {
            color: #FF0000 !important;
            animation: fastPulse 0.2s infinite;
            font-weight: bold;
        }
        
        /* Audio Control Button */
        #audioToggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff88;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s;
            user-select: none;
        }
        
        #audioToggle:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.1);
        }
        
        #audioToggle.muted {
            border-color: #ff4444;
            opacity: 0.7;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes fastPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        
        .name-input-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 16px;
            z-index: 300;
            text-align: center;
            min-width: 350px;
            border: 2px solid #4CAF50;
        }
        
        .name-input-dialog input {
            width: 200px;
            padding: 10px;
            margin: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }
        
        .name-input-dialog button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .name-input-dialog button:hover {
            background: #45a049;
        }
        
        .name-input-dialog button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .highscore-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            min-width: 200px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        .highscore-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .highscore-panel.fading {
            opacity: 0;
        }
        
        .highscore-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .highscore-entry.current-player {
            color: #4CAF50;
            font-weight: bold;
        }
        
        /* Head Tracking Preview Window - ENHANCED */
        #headTrackPreview {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 400px;
            height: 300px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 0, 40, 0.9));
            border: 2px solid #00ff88;
            border-radius: 12px;
            z-index: 500;
            display: none;
            overflow: hidden;
            box-shadow: 
                0 0 30px rgba(0, 255, 136, 0.5),
                inset 0 0 20px rgba(0, 255, 136, 0.1);
            backdrop-filter: blur(10px);
        }
        
        #headTrackPreview.active {
            display: block;
        }
        
        #headTrackVideo {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #headTrackCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            z-index: 2;
        }
        
        #headTrackStatus {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #00ff88;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.8);
            z-index: 10;
        }
        
        /* Visual Feedback Metrics Panel */
        #headTrackMetrics {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            color: #00ffff;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 3px rgba(0, 255, 255, 0.8);
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }
        
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }
        
        .metric-label {
            color: #888;
        }
        
        .metric-value {
            color: #0ff;
            font-weight: bold;
        }
        
        .metric-value.warning {
            color: #ff0;
        }
        
        .metric-value.danger {
            color: #f00;
        }
        
        .metric-value.success {
            color: #0f0;
        }
        
        #headTrackToggle {
            position: fixed;
            top: 20px;
            right: 230px;
            padding: 10px 15px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 501;
            transition: all 0.3s;
        }
        
        #headTrackToggle:hover {
            background: #00cc70;
            transform: scale(1.05);
        }
        
        #headTrackToggle.active {
            background: #ff6b6b;
        }
        
        /* Mobile UI Optimization */
        #mobileScoreBar {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0 10px;
            z-index: 1000;
            align-items: center;
            justify-content: space-around;
            font-size: 14px;
            font-weight: 600;
        }
        
        #mobileInfoBar {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 0 10px;
            z-index: 1000;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            opacity: 0.8;
        }
        
        .mobile-score-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        /* Media Queries for Mobile */
        @media (max-width: 768px) or (pointer: coarse) {
            /* Hide desktop UI elements */
            #ui {
                display: none !important;
            }
            
            #instructions {
                display: none !important;
            }
            
            #gestureControl {
                display: none !important;
            }
            
            #headTrackToggle {
                display: none !important;
            }
            
            #headTrackPreview {
                display: none !important;
            }
            
            /* Show mobile UI */
            #mobileScoreBar {
                display: flex !important;
            }
            
            #mobileInfoBar {
                display: flex !important;
            }
            
            /* Adjust game container for mobile bars */
            #gameCanvas {
                position: fixed;
                top: 40px;
                bottom: 30px;
                left: 0;
                right: 0;
                width: 100% !important;
                height: calc(100vh - 70px) !important;
                max-width: none !important;
                max-height: none !important;
                border: none !important;
                border-radius: 0 !important;
            }
            
            /* Mobile menu adjustments */
            #menu {
                width: 90%;
                padding: 20px;
                font-size: 14px;
            }
            
            #menu h1 {
                font-size: 24px;
            }
            
            #menu p {
                font-size: 12px;
                margin: 5px 0;
            }
            
            #menu button {
                font-size: 16px;
                padding: 10px 20px;
            }
            
            /* Show mobile instructions in menu only */
            #menu .mobile-instructions {
                display: block;
                background: rgba(255, 255, 255, 0.1);
                padding: 10px;
                border-radius: 8px;
                margin: 10px 0;
            }
        }
        
        /* Desktop-only styles */
        @media (min-width: 769px) and (pointer: fine) {
            #mobileScoreBar, #mobileInfoBar {
                display: none !important;
            }
            
            #menu .mobile-instructions {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- Jeeliz Face Tracking Canvas (behind game) -->
        <canvas id="faceCanvas" style="position: absolute; width: 100%; height: 100%; z-index: 1; display: none;"></canvas>
        <!-- Game Canvas (on top) -->
        <canvas id="gameCanvas" style="position: relative; z-index: 2;"></canvas>
        
        <!-- Audio Toggle Button -->
        <button id="audioToggle" class="muted" title="Toggle Sound">🔇</button>
        
        <!-- Mobile Score Bar (Top) -->
        <div id="mobileScoreBar">
            <div class="mobile-score-item">
                <span>Score:</span>
                <span id="mobileScore">0</span>
            </div>
            <div class="mobile-score-item">
                <span>🍎</span>
                <span id="mobileApples">0</span>
            </div>
            <div class="mobile-score-item">
                <span>🥦</span>
                <span id="mobileBroccolis">0</span>
            </div>
            <div class="mobile-score-item">
                <span>❤️</span>
                <span id="mobileLives">3</span>
            </div>
        </div>
        
        <!-- Mobile Info Bar (Bottom) -->
        <div id="mobileInfoBar">
            <span>Speed: <span id="mobileSpeed">100</span></span>
            <span> | </span>
            <span>Time: <span id="mobileTime">60</span>s</span>
        </div>
        
        <!-- Head Tracking Preview Window -->
        <button id="headTrackToggle">📹 Head Tracking</button>
        <div id="headTrackPreview">
            <video id="headTrackVideo" autoplay playsinline></video>
            <canvas id="headTrackCanvas" width="400" height="300"></canvas>
            <div id="headTrackMetrics">
                <div class="metric-row">
                    <span class="metric-label">POSITION:</span>
                    <span class="metric-value" id="metricPosition">0.0cm</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">VELOCITY:</span>
                    <span class="metric-value" id="metricVelocity">0.0cm/s</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">CONFIDENCE:</span>
                    <span class="metric-value" id="metricConfidence">0%</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">STATE:</span>
                    <span class="metric-value" id="metricState">IDLE</span>
                </div>
            </div>
            <div id="headTrackStatus">Inactive</div>
        </div>
        
        <div id="ui">
            <div id="roundIndicator" style="font-size: 28px; color: #FFD700; text-shadow: 3px 3px 6px rgba(0,0,0,0.9); margin-bottom: 10px;">
                🎮 DURCHGANG <span id="currentRound">1</span>/3
            </div>
            <div>Score: <span id="score">0</span></div>
            <div id="speedIndicator">Speed: <span id="speed">100</span></div>
            <div>❤️ Leben: <span id="lives">3</span></div>
            <div id="timer">⏱️ Zeit: <span id="timeRemaining">60</span>s</div>
            <div>🍎 Äpfel: <span id="apples">0</span></div>
            <div>🥦 Brokkoli: <span id="broccolis">0</span></div>
            <div style="font-size: 12px; opacity: 0.6; margin-top: 10px;">V4.8-AUDIO-SAFE</div>
        </div>
        
        <!-- Round Transition Overlay -->
        <div id="roundTransitionOverlay" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 500; justify-content: center; align-items: center; flex-direction: column;">
            <div id="transitionTitle" style="font-size: 48px; color: white; text-shadow: 0 0 20px rgba(255,255,255,0.8); margin-bottom: 20px;"></div>
            <div id="transitionSubtitle" style="font-size: 24px; color: #FFD700; text-shadow: 0 0 10px rgba(255,215,0,0.8);"></div>
            <div id="transitionCountdown" style="font-size: 72px; color: white; margin-top: 30px; text-shadow: 0 0 30px rgba(255,255,255,1);"></div>
        </div>
        
        <div id="instructions">
            <div><strong>🎮 Steuerung:</strong></div>
            <div class="desktop-controls">
                <div>A/D: Spurwechsel</div>
                <div>Leertaste/W: Springen 🦘</div>
                <div>S: Ducken 🦆</div>
            </div>
            <div class="mobile-controls" style="display: none;">
                <div>◀️ Wisch Links/Rechts ▶️</div>
                <div>⬆️ Wisch Hoch: Springen</div>
                <div>⬇️ Wisch Runter: Ducken</div>
                <div>👆 Doppeltipp: Multi-Jump</div>
            </div>
            <div><strong>💡 Tipps:</strong></div>
            <div>🟠 Orange/Braun: Überspringen!</div>
            <div>🔵 Blau/Grau oben: Ducken!</div>
            <div>🔴 Stacheln: Beides möglich!</div>
        </div>
        
        <div id="gestureControl">
            <button id="gestureControlBtn">🎮 Gestensteuerung aktivieren</button>
            <div id="gestureStatus">
                <div>Status: <span id="gestureStatusText">Bereit</span></div>
                <div>Geste: <span id="gestureCurrentText">NONE</span></div>
            </div>
        </div>
        
        <video id="gestureVideo" style="display: none;" autoplay playsinline></video>
        <canvas id="gestureCanvas"></canvas>
        
        <div id="menu">
            <h1>🚇 Subway Runner 3D</h1>
            <h2>⏱️ 60-Sekunden Challenge!</h2>
            <p>Überlebe 60 Sekunden bei stetig steigender Geschwindigkeit!</p>
            <p><strong>🎯 Ziel:</strong> 60 Sekunden überleben</p>
            <p><strong>⚡ Warnung:</strong> Wird sehr schnell!</p>
            
            <!-- Desktop Instructions -->
            <div class="desktop-instructions">
                <p><strong>🎮 Steuerung:</strong></p>
                <p>A/D: Spurwechsel | W/Space: Springen | S: Ducken</p>
            </div>
            
            <!-- Mobile Instructions -->
            <div class="mobile-instructions">
                <p><strong>📱 Touch-Steuerung:</strong></p>
                <p>◀️ Wisch Links/Rechts ▶️ Lane wechseln</p>
                <p>⬆️ Wisch Hoch: Springen (mehrfach für Multi-Jump)</p>
                <p>⬇️ Wisch Runter: Ducken (Wisch hoch zum Aufstehen)</p>
            </div>
            
            <button onclick="startGame()">🎮 Challenge starten!</button>
        </div>
        
        <div id="highscorePanel" class="highscore-panel">
            <div style="font-weight: bold; margin-bottom: 10px;">🏆 TOP 10</div>
            <div id="highscoreList">Lade Bestenliste...</div>
        </div>
        
        <div id="nameInputDialog" class="name-input-dialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
             background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,140,0,0.95)); 
             padding: 30px; border-radius: 20px; text-align: center; z-index: 3000;
             box-shadow: 0 0 50px rgba(255,215,0,0.8); min-width: 300px;">
            <h2 style="color: white; text-shadow: 0 0 10px rgba(255,255,255,0.8); margin-bottom: 15px;">🎉 Neuer Highscore! 🎉</h2>
            <p style="font-size: 24px; color: white; font-weight: bold; margin-bottom: 10px;">Score: <span id="highscoreValue" style="color: #FFD700;"></span></p>
            <p style="color: white; margin-bottom: 15px;">Gib deinen Namen ein:</p>
            <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="20" 
                   style="padding: 10px; font-size: 16px; border-radius: 5px; border: none; width: 80%; margin-bottom: 20px;">
            <br>
            <button onclick="submitHighscore()" style="padding: 10px 20px; font-size: 16px; margin: 5px; 
                    background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">💾 Speichern</button>
            <button onclick="skipHighscore()" style="padding: 10px 20px; font-size: 16px; margin: 5px;
                    background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">⏭️ Überspringen</button>
        </div>
    </div>

    <script>
        // ============================================
        // ONE-EURO FILTER - Smoothing ohne Lag
        // Based on: https://gery.casiez.net/1euro/
        // ============================================
        class OneEuroFilter {
            constructor(freq = 60, minCutoff = 1.0, beta = 0.02, dCutoff = 1.0) {
                this.freq = freq;
                this.minCutoff = minCutoff;
                this.beta = beta;
                this.dCutoff = dCutoff;
                this.xPrev = null;
                this.dxPrev = null;
                this.tPrev = null;
            }
            
            alpha(cutoff) {
                const tau = 1.0 / (2 * Math.PI * cutoff);
                const te = 1.0 / this.freq;
                return 1.0 / (1.0 + tau / te);
            }
            
            filter(t, x) {
                if (this.tPrev === null) {
                    this.tPrev = t;
                    this.xPrev = x;
                    this.dxPrev = 0;
                    return x;
                }
                
                this.freq = 1.0 / Math.max(1e-6, t - this.tPrev);
                const dx = (x - this.xPrev) * this.freq;
                const aDx = this.alpha(this.dCutoff);
                const dxHat = aDx * dx + (1 - aDx) * this.dxPrev;
                
                const cutoff = this.minCutoff + this.beta * Math.abs(dxHat);
                const a = this.alpha(cutoff);
                const xHat = a * x + (1 - a) * this.xPrev;
                
                this.xPrev = xHat;
                this.dxPrev = dxHat;
                this.tPrev = t;
                
                return xHat;
            }
            
            reset() {
                this.xPrev = null;
                this.dxPrev = null;
                this.tPrev = null;
            }
        }
        
        // ============================================
        // HYSTERESIS CONTROLLER - Stabile Schwellwerte
        // ============================================
        class HysteresisController {
            constructor(enterThreshold, exitThreshold) {
                this.enterThreshold = enterThreshold;
                this.exitThreshold = exitThreshold;
                this.isActive = false;
            }
            
            update(value) {
                if (!this.isActive && Math.abs(value) >= Math.abs(this.enterThreshold)) {
                    this.isActive = true;
                    return true; // Rising edge
                } else if (this.isActive && Math.abs(value) < Math.abs(this.exitThreshold)) {
                    this.isActive = false;
                }
                return false;
            }
            
            reset() {
                this.isActive = false;
            }
        }
        
        // ============================================
        // ADVANCED VISUAL FEEDBACK SYSTEM
        // ============================================
        class AdvancedVisualFeedback {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                
                // Metrics tracking
                this.position = 0;
                this.velocity = 0;
                this.lastPosition = 0;
                this.lastUpdateTime = Date.now();
                this.confidence = 0;
                this.state = 'IDLE';
                
                // Movement history (circular buffer)
                this.historySize = 60; // 1 second at 60fps
                this.positionHistory = new Array(this.historySize).fill(0);
                this.historyIndex = 0;
                
                // Visual settings
                this.zones = {
                    triggerLeft: -5,    // cm
                    warningLeft: -3,    // cm
                    deadZone: 3,        // cm (±3)
                    warningRight: 3,    // cm
                    triggerRight: 5     // cm
                };
                
                // Animation states
                this.triggerFlashAlpha = 0;
                this.cooldownProgress = 0;
                this.particleEffects = [];
                
                // Debug mode
                this.debugMode = 1; // 0=off, 1=basic, 2=advanced, 3=developer
            }
            
            update(positionCm, confidence, state, cooldownActive, cooldownTime) {
                const now = Date.now();
                const deltaTime = (now - this.lastUpdateTime) / 1000; // seconds
                
                // Calculate velocity
                if (deltaTime > 0) {
                    this.velocity = (positionCm - this.lastPosition) / deltaTime;
                }
                
                this.position = positionCm;
                this.confidence = confidence;
                this.state = state;
                this.lastPosition = positionCm;
                this.lastUpdateTime = now;
                
                // Update history
                this.positionHistory[this.historyIndex] = positionCm;
                this.historyIndex = (this.historyIndex + 1) % this.historySize;
                
                // Update cooldown progress
                if (cooldownActive && cooldownTime > 0) {
                    this.cooldownProgress = 1 - (cooldownTime / 300); // 300ms total cooldown
                } else {
                    this.cooldownProgress = 0;
                }
                
                // Update metrics display
                this.updateMetricsDisplay();
            }
            
            updateMetricsDisplay() {
                // Update HTML metrics
                const posEl = document.getElementById('metricPosition');
                const velEl = document.getElementById('metricVelocity');
                const confEl = document.getElementById('metricConfidence');
                const stateEl = document.getElementById('metricState');
                
                if (posEl) {
                    posEl.textContent = `${this.position.toFixed(1)}cm`;
                    posEl.className = 'metric-value';
                    
                    if (Math.abs(this.position) > this.zones.triggerRight) {
                        posEl.className += ' danger';
                    } else if (Math.abs(this.position) > this.zones.warningRight) {
                        posEl.className += ' warning';
                    } else {
                        posEl.className += ' success';
                    }
                }
                
                if (velEl) {
                    velEl.textContent = `${this.velocity.toFixed(1)}cm/s`;
                    const absVel = Math.abs(this.velocity);
                    velEl.className = 'metric-value';
                    if (absVel > 10) velEl.className += ' danger';
                    else if (absVel > 5) velEl.className += ' warning';
                }
                
                if (confEl) {
                    const confPercent = Math.round(this.confidence * 100);
                    confEl.textContent = `${confPercent}%`;
                    confEl.className = 'metric-value';
                    if (confPercent < 50) confEl.className += ' danger';
                    else if (confPercent < 70) confEl.className += ' warning';
                    else confEl.className += ' success';
                }
                
                if (stateEl) {
                    stateEl.textContent = this.state;
                    stateEl.className = 'metric-value';
                    if (this.state === 'TRACKING') stateEl.className += ' success';
                    else if (this.state === 'COOLDOWN') stateEl.className += ' warning';
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Draw components based on debug mode
                if (this.debugMode >= 1) {
                    this.drawMovementBar();
                    this.drawCooldownIndicator();
                }
                
                if (this.debugMode >= 2) {
                    this.drawHistoryGraph();
                    this.drawVelocityVector();
                }
                
                if (this.debugMode >= 3) {
                    this.drawRawData();
                }
                
                // Always draw trigger effects
                this.drawTriggerEffects();
                this.updateParticles();
            }
            
            drawMovementBar() {
                const barY = this.height - 60;
                const barHeight = 30;
                const barWidth = this.width - 40;
                const barX = 20;
                const scale = barWidth / (this.zones.triggerRight * 2); // Scale to fit -5 to +5 cm
                
                // Draw background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Draw zones
                const centerX = barX + barWidth / 2;
                
                // Dead zone (green)
                const deadZoneWidth = this.zones.deadZone * scale;
                this.ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                this.ctx.fillRect(centerX - deadZoneWidth, barY, deadZoneWidth * 2, barHeight);
                
                // Warning zones (yellow)
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                // Left warning
                const leftWarningX = centerX + (this.zones.warningLeft * scale);
                const leftTriggerX = centerX + (this.zones.triggerLeft * scale);
                this.ctx.fillRect(leftTriggerX, barY, leftWarningX - leftTriggerX, barHeight);
                // Right warning
                const rightWarningX = centerX + (this.zones.warningRight * scale);
                const rightTriggerX = centerX + (this.zones.triggerRight * scale);
                this.ctx.fillRect(rightWarningX, barY, rightTriggerX - rightWarningX, barHeight);
                
                // Trigger zones (red)
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                // Left trigger
                this.ctx.fillRect(barX, barY, leftTriggerX - barX, barHeight);
                // Right trigger
                this.ctx.fillRect(rightTriggerX, barY, barX + barWidth - rightTriggerX, barHeight);
                
                // Draw threshold lines
                this.ctx.strokeStyle = '#444';
                this.ctx.lineWidth = 1;
                
                // Center line
                this.ctx.strokeStyle = '#0ff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, barY);
                this.ctx.lineTo(centerX, barY + barHeight);
                this.ctx.stroke();
                
                // Current position indicator
                const currentX = centerX + (this.position * scale);
                
                // Draw position marker
                this.ctx.fillStyle = this.getPositionColor();
                this.ctx.beginPath();
                this.ctx.arc(currentX, barY + barHeight/2, 8, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Draw position line
                this.ctx.strokeStyle = this.getPositionColor();
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(currentX, barY - 5);
                this.ctx.lineTo(currentX, barY + barHeight + 5);
                this.ctx.stroke();
                
                // Draw zone labels
                this.ctx.fillStyle = '#888';
                this.ctx.font = '10px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('-5cm', leftTriggerX, barY - 5);
                this.ctx.fillText('-3cm', leftWarningX, barY - 5);
                this.ctx.fillText('0', centerX, barY - 5);
                this.ctx.fillText('3cm', rightWarningX, barY - 5);
                this.ctx.fillText('5cm', rightTriggerX, barY - 5);
            }
            
            drawHistoryGraph() {
                const graphY = 100;
                const graphHeight = 80;
                const graphWidth = this.width - 40;
                const graphX = 20;
                
                // Background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
                
                // Draw grid
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 0.5;
                
                // Horizontal lines
                for (let i = 0; i <= 4; i++) {
                    const y = graphY + (graphHeight / 4) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(graphX, y);
                    this.ctx.lineTo(graphX + graphWidth, y);
                    this.ctx.stroke();
                }
                
                // Draw history line
                this.ctx.strokeStyle = '#0ff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                
                const stepX = graphWidth / this.historySize;
                const centerY = graphY + graphHeight / 2;
                const scale = graphHeight / 20; // Scale to fit -10 to +10 cm
                
                for (let i = 0; i < this.historySize; i++) {
                    const index = (this.historyIndex + i) % this.historySize;
                    const value = this.positionHistory[index];
                    const x = graphX + i * stepX;
                    const y = centerY - (value * scale);
                    
                    if (i === 0) {
                        this.ctx.moveTo(x, y);
                    } else {
                        this.ctx.lineTo(x, y);
                    }
                }
                this.ctx.stroke();
                
                // Draw threshold lines
                this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);
                
                // Upper threshold
                const upperY = centerY - (this.zones.triggerRight * scale);
                this.ctx.beginPath();
                this.ctx.moveTo(graphX, upperY);
                this.ctx.lineTo(graphX + graphWidth, upperY);
                this.ctx.stroke();
                
                // Lower threshold
                const lowerY = centerY - (this.zones.triggerLeft * scale);
                this.ctx.beginPath();
                this.ctx.moveTo(graphX, lowerY);
                this.ctx.lineTo(graphX + graphWidth, lowerY);
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
            }
            
            drawVelocityVector() {
                const centerX = this.width / 2;
                const centerY = 50;
                const maxLength = 40;
                
                // Background circle
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.arc(centerX, centerY, maxLength + 10, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Velocity vector
                const velocityLength = Math.min(Math.abs(this.velocity) * 2, maxLength);
                const velocityAngle = this.velocity > 0 ? 0 : Math.PI;
                
                const endX = centerX + Math.cos(velocityAngle) * velocityLength;
                const endY = centerY;
                
                // Draw arrow
                this.ctx.strokeStyle = this.velocity > 0 ? '#f00' : '#0f0';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(centerX, centerY);
                this.ctx.lineTo(endX, endY);
                this.ctx.stroke();
                
                // Arrow head
                if (velocityLength > 5) {
                    this.ctx.beginPath();
                    const arrowSize = 8;
                    const angle1 = velocityAngle + 2.5;
                    const angle2 = velocityAngle - 2.5;
                    this.ctx.moveTo(endX, endY);
                    this.ctx.lineTo(endX - Math.cos(angle1) * arrowSize, endY - Math.sin(angle1) * arrowSize);
                    this.ctx.moveTo(endX, endY);
                    this.ctx.lineTo(endX - Math.cos(angle2) * arrowSize, endY - Math.sin(angle2) * arrowSize);
                    this.ctx.stroke();
                }
                
                // Velocity text
                this.ctx.fillStyle = '#fff';
                this.ctx.font = '12px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`${this.velocity.toFixed(1)} cm/s`, centerX, centerY + maxLength + 25);
            }
            
            drawCooldownIndicator() {
                if (this.cooldownProgress > 0) {
                    const centerX = this.width - 40;
                    const centerY = 40;
                    const radius = 25;
                    
                    // Background circle
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Progress arc
                    this.ctx.strokeStyle = '#ff0';
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius - 2, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * this.cooldownProgress));
                    this.ctx.stroke();
                    
                    // Text
                    this.ctx.fillStyle = '#ff0';
                    this.ctx.font = '10px monospace';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('COOLDOWN', centerX, centerY + radius + 15);
                }
            }
            
            drawTriggerEffects() {
                // Flash effect when triggering
                if (this.triggerFlashAlpha > 0) {
                    const color = this.position < 0 ? '0, 255, 0' : '255, 0, 0';
                    this.ctx.fillStyle = `rgba(${color}, ${this.triggerFlashAlpha})`;
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    this.triggerFlashAlpha -= 0.05;
                }
            }
            
            updateParticles() {
                // Update and draw particle effects
                this.particleEffects = this.particleEffects.filter(particle => {
                    particle.y -= particle.velocity;
                    particle.alpha -= 0.02;
                    particle.size *= 0.98;
                    
                    if (particle.alpha > 0) {
                        this.ctx.fillStyle = `rgba(${particle.color}, ${particle.alpha})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        return true;
                    }
                    return false;
                });
            }
            
            triggerLaneChange(direction) {
                // Visual feedback for lane change
                this.triggerFlashAlpha = 0.3;
                
                // Create particles
                const centerX = this.width / 2;
                const centerY = this.height - 60;
                
                for (let i = 0; i < 10; i++) {
                    this.particleEffects.push({
                        x: centerX + (Math.random() - 0.5) * 100,
                        y: centerY,
                        velocity: Math.random() * 2 + 1,
                        size: Math.random() * 5 + 2,
                        color: direction === 'left' ? '0, 255, 0' : '255, 0, 0',
                        alpha: 1
                    });
                }
            }
            
            drawRawData() {
                // Developer mode - show raw data
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(10, 10, 150, 80);
                
                this.ctx.fillStyle = '#0f0';
                this.ctx.font = '10px monospace';
                this.ctx.textAlign = 'left';
                
                const lines = [
                    `Pos: ${this.position.toFixed(3)}cm`,
                    `Vel: ${this.velocity.toFixed(3)}cm/s`,
                    `Conf: ${(this.confidence * 100).toFixed(1)}%`,
                    `State: ${this.state}`,
                    `History: ${this.historyIndex}/${this.historySize}`,
                    `FPS: ${(1000 / (Date.now() - this.lastUpdateTime)).toFixed(0)}`
                ];
                
                lines.forEach((line, i) => {
                    this.ctx.fillText(line, 15, 25 + i * 12);
                });
            }
            
            getPositionColor() {
                const absPos = Math.abs(this.position);
                if (absPos > this.zones.triggerRight) {
                    return '#f00'; // Red - trigger zone
                } else if (absPos > this.zones.warningRight) {
                    return '#ff0'; // Yellow - warning zone
                } else {
                    return '#0f0'; // Green - safe zone
                }
            }
            
            toggleDebugMode() {
                this.debugMode = (this.debugMode + 1) % 4;
                console.log(`Debug mode: ${this.debugMode}`);
            }
        }
        
        // ============================================
        // LOW-LIGHT HEAD TRACKER - Enhanced for poor lighting
        // ============================================
        class LowLightHeadTracker {
            constructor() {
                // Core tracking modes
                this.TRACKING_MODES = {
                    FACE: 'face',           // Headtrackr face detection
                    OPTICAL_FLOW: 'flow',   // Motion tracking
                    SHOULDER: 'shoulder',   // Upper body silhouette
                    GESTURE: 'gesture'      // Big gesture mode
                };
                
                // Current state
                this.currentMode = this.TRACKING_MODES.FACE;
                this.confidence = 0;
                this.lightLevel = 1.0; // 0=dark, 1=bright
                this.isCalibrating = true;
                this.calibrationFrames = 0;
                
                // Image preprocessing
                this.preprocessCanvas = null;
                this.preprocessCtx = null;
                this.enhancementLevel = 0; // 0=none, 1=mild, 2=moderate, 3=aggressive
                
                // Adaptive thresholds
                this.baseThreshold = 5; // cm
                this.currentThreshold = 5;
                this.thresholdMultiplier = 1.0;
                
                // Optical flow tracking
                this.opticalFlowData = {
                    prevFrame: null,
                    currentFrame: null,
                    flowVectors: [],
                    avgMotionX: 0,
                    avgMotionY: 0
                };
                
                // Shoulder tracking
                this.shoulderData = {
                    leftEdge: 0,
                    rightEdge: 0,
                    centerX: 0,
                    detected: false
                };
                
                // Big gesture mode
                this.gestureMode = {
                    active: false,
                    requiredMovement: 15, // cm
                    lastGestureTime: 0
                };
                
                // Fallback to SimpleHeadTracker
                this.simpleTracker = null;
                
                this.init();
            }
            
            init() {
                // Create preprocessing canvas
                this.preprocessCanvas = document.createElement('canvas');
                this.preprocessCanvas.width = 320;
                this.preprocessCanvas.height = 240;
                this.preprocessCtx = this.preprocessCanvas.getContext('2d');
                
                // Initialize simple tracker as base
                this.simpleTracker = new SimpleHeadTracker();
                
                // Override the simple tracker's onHeadMove
                const originalOnHeadMove = this.simpleTracker.onHeadMove.bind(this.simpleTracker);
                this.simpleTracker.onHeadMove = (event) => {
                    this.enhancedHeadMove(event, originalOnHeadMove);
                };
                
                // Start calibration
                this.startCalibration();
                
                console.log('🌙 Low-Light Head Tracker initialized');
            }
            
            startCalibration() {
                this.isCalibrating = true;
                this.calibrationFrames = 0;
                const calibrationData = {
                    brightness: [],
                    contrast: [],
                    noise: []
                };
                
                const calibrationInterval = setInterval(() => {
                    if (!this.simpleTracker.video || !this.simpleTracker.isActive) {
                        return;
                    }
                    
                    // Analyze frame
                    const metrics = this.analyzeFrame();
                    calibrationData.brightness.push(metrics.brightness);
                    calibrationData.contrast.push(metrics.contrast);
                    calibrationData.noise.push(metrics.noise);
                    
                    this.calibrationFrames++;
                    
                    // After 60 frames (1 second), determine lighting conditions
                    if (this.calibrationFrames >= 60) {
                        clearInterval(calibrationInterval);
                        this.completeCalibration(calibrationData);
                    }
                }, 16); // 60fps
            }
            
            analyzeFrame() {
                if (!this.simpleTracker.video) {
                    return { brightness: 0.5, contrast: 0.5, noise: 0 };
                }
                
                // Draw video frame to preprocessing canvas
                this.preprocessCtx.drawImage(
                    this.simpleTracker.video,
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                
                // Get image data
                const imageData = this.preprocessCtx.getImageData(
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                const pixels = imageData.data;
                
                // Calculate brightness (average luminance)
                let totalBrightness = 0;
                let minBrightness = 255;
                let maxBrightness = 0;
                
                for (let i = 0; i < pixels.length; i += 4) {
                    const luminance = 0.299 * pixels[i] + 0.587 * pixels[i+1] + 0.114 * pixels[i+2];
                    totalBrightness += luminance;
                    minBrightness = Math.min(minBrightness, luminance);
                    maxBrightness = Math.max(maxBrightness, luminance);
                }
                
                const avgBrightness = totalBrightness / (pixels.length / 4) / 255;
                const contrast = (maxBrightness - minBrightness) / 255;
                
                // Estimate noise (simplified)
                let noise = 0;
                for (let i = 4; i < pixels.length - 4; i += 4) {
                    const diff = Math.abs(pixels[i] - pixels[i-4]);
                    noise += diff;
                }
                noise = noise / (pixels.length / 4) / 255;
                
                return {
                    brightness: avgBrightness,
                    contrast: contrast,
                    noise: noise
                };
            }
            
            completeCalibration(data) {
                // Calculate averages
                const avgBrightness = data.brightness.reduce((a, b) => a + b, 0) / data.brightness.length;
                const avgContrast = data.contrast.reduce((a, b) => a + b, 0) / data.contrast.length;
                const avgNoise = data.noise.reduce((a, b) => a + b, 0) / data.noise.length;
                
                // Determine light level and enhancement needs
                this.lightLevel = avgBrightness;
                
                if (avgBrightness < 0.2) {
                    // Very dark
                    this.enhancementLevel = 3;
                    this.thresholdMultiplier = 3.0;
                    this.currentMode = this.TRACKING_MODES.GESTURE;
                    console.log('🌑 Very dark environment detected - Big Gesture Mode');
                } else if (avgBrightness < 0.35) {
                    // Dark
                    this.enhancementLevel = 2;
                    this.thresholdMultiplier = 2.0;
                    this.currentMode = this.TRACKING_MODES.SHOULDER;
                    console.log('🌘 Dark environment - Shoulder Tracking Mode');
                } else if (avgBrightness < 0.5) {
                    // Dim
                    this.enhancementLevel = 1;
                    this.thresholdMultiplier = 1.5;
                    this.currentMode = this.TRACKING_MODES.OPTICAL_FLOW;
                    console.log('🌗 Dim lighting - Optical Flow Mode');
                } else {
                    // Good lighting
                    this.enhancementLevel = 0;
                    this.thresholdMultiplier = 1.0;
                    this.currentMode = this.TRACKING_MODES.FACE;
                    console.log('🌕 Good lighting - Face Tracking Mode');
                }
                
                // Update thresholds
                this.currentThreshold = this.baseThreshold * this.thresholdMultiplier;
                
                // Update visual feedback
                if (this.simpleTracker.visualFeedback) {
                    this.simpleTracker.visualFeedback.zones.triggerLeft = -this.currentThreshold;
                    this.simpleTracker.visualFeedback.zones.triggerRight = this.currentThreshold;
                }
                
                this.isCalibrating = false;
                
                // Show calibration results to user
                this.showCalibrationResults();
                
                // Re-calibrate every 30 seconds
                setTimeout(() => this.startCalibration(), 30000);
            }
            
            showCalibrationResults() {
                const status = document.getElementById('headTrackStatus');
                if (status) {
                    const modeText = {
                        [this.TRACKING_MODES.FACE]: '😊 Face Tracking',
                        [this.TRACKING_MODES.OPTICAL_FLOW]: '〰️ Motion Tracking',
                        [this.TRACKING_MODES.SHOULDER]: '👤 Shoulder Tracking',
                        [this.TRACKING_MODES.GESTURE]: '🙌 Big Gesture Mode'
                    };
                    
                    status.innerHTML = `
                        <span style="color: ${this.lightLevel < 0.35 ? '#ff9900' : '#00ff00'}">
                            Light: ${Math.round(this.lightLevel * 100)}% | 
                            Mode: ${modeText[this.currentMode]} |
                            Sensitivity: ${this.currentThreshold.toFixed(1)}cm
                        </span>
                    `;
                }
            }
            
            enhancedHeadMove(event, originalCallback) {
                // Apply preprocessing if needed
                if (this.enhancementLevel > 0) {
                    this.preprocessFrame();
                }
                
                // Route to appropriate tracking mode
                switch (this.currentMode) {
                    case this.TRACKING_MODES.FACE:
                        // Use original headtrackr with enhanced confidence check
                        if (event.confidence > 0.4) {
                            this.confidence = event.confidence;
                            originalCallback(event);
                        } else {
                            // Fallback to optical flow
                            this.trackOpticalFlow();
                        }
                        break;
                        
                    case this.TRACKING_MODES.OPTICAL_FLOW:
                        this.trackOpticalFlow();
                        break;
                        
                    case this.TRACKING_MODES.SHOULDER:
                        this.trackShoulders();
                        break;
                        
                    case this.TRACKING_MODES.GESTURE:
                        this.trackBigGestures();
                        break;
                }
                
                // Update visual feedback with current mode
                this.updateModeFeedback();
            }
            
            preprocessFrame() {
                if (!this.simpleTracker.video) return;
                
                // Draw original frame
                this.preprocessCtx.drawImage(
                    this.simpleTracker.video,
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                
                // Get image data
                const imageData = this.preprocessCtx.getImageData(
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                
                // Apply enhancements based on level
                if (this.enhancementLevel >= 1) {
                    this.applyGammaCorrection(imageData, 1.5);
                }
                
                if (this.enhancementLevel >= 2) {
                    this.applyCLAHE(imageData);
                }
                
                if (this.enhancementLevel >= 3) {
                    this.applyBilateralFilter(imageData);
                }
                
                // Put enhanced image back
                this.preprocessCtx.putImageData(imageData, 0, 0);
            }
            
            applyGammaCorrection(imageData, gamma) {
                const data = imageData.data;
                const invGamma = 1 / gamma;
                
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 * Math.pow(data[i] / 255, invGamma);
                    data[i + 1] = 255 * Math.pow(data[i + 1] / 255, invGamma);
                    data[i + 2] = 255 * Math.pow(data[i + 2] / 255, invGamma);
                }
            }
            
            applyCLAHE(imageData) {
                // Simplified CLAHE (Contrast Limited Adaptive Histogram Equalization)
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const tileSize = 8;
                const clipLimit = 2.0;
                
                // Convert to grayscale and apply local histogram equalization
                for (let ty = 0; ty < height; ty += tileSize) {
                    for (let tx = 0; tx < width; tx += tileSize) {
                        this.equalizeHistogramTile(data, width, height, tx, ty, tileSize, clipLimit);
                    }
                }
            }
            
            equalizeHistogramTile(data, width, height, tx, ty, tileSize, clipLimit) {
                // Simplified tile-based histogram equalization
                const histogram = new Array(256).fill(0);
                let pixelCount = 0;
                
                // Build histogram for tile
                for (let y = ty; y < Math.min(ty + tileSize, height); y++) {
                    for (let x = tx; x < Math.min(tx + tileSize, width); x++) {
                        const idx = (y * width + x) * 4;
                        const gray = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
                        histogram[gray]++;
                        pixelCount++;
                    }
                }
                
                // Apply clipping
                const avgBinSize = pixelCount / 256;
                const limit = avgBinSize * clipLimit;
                let excess = 0;
                
                for (let i = 0; i < 256; i++) {
                    if (histogram[i] > limit) {
                        excess += histogram[i] - limit;
                        histogram[i] = limit;
                    }
                }
                
                // Redistribute excess
                const avgExcess = excess / 256;
                for (let i = 0; i < 256; i++) {
                    histogram[i] += avgExcess;
                }
                
                // Build cumulative distribution
                const cdf = new Array(256);
                cdf[0] = histogram[0];
                for (let i = 1; i < 256; i++) {
                    cdf[i] = cdf[i - 1] + histogram[i];
                }
                
                // Apply equalization to tile
                for (let y = ty; y < Math.min(ty + tileSize, height); y++) {
                    for (let x = tx; x < Math.min(tx + tileSize, width); x++) {
                        const idx = (y * width + x) * 4;
                        const gray = Math.round(0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2]);
                        const newGray = Math.round((cdf[gray] / pixelCount) * 255);
                        
                        // Apply to all channels
                        const ratio = newGray / (gray || 1);
                        data[idx] = Math.min(255, data[idx] * ratio);
                        data[idx + 1] = Math.min(255, data[idx + 1] * ratio);
                        data[idx + 2] = Math.min(255, data[idx + 2] * ratio);
                    }
                }
            }
            
            applyBilateralFilter(imageData) {
                // Simplified bilateral filter for noise reduction
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const output = new Uint8ClampedArray(data);
                const kernelSize = 3;
                const spatialSigma = 2;
                const intensitySigma = 30;
                
                for (let y = kernelSize; y < height - kernelSize; y++) {
                    for (let x = kernelSize; x < width - kernelSize; x++) {
                        const centerIdx = (y * width + x) * 4;
                        let sumR = 0, sumG = 0, sumB = 0, sumW = 0;
                        
                        for (let ky = -kernelSize; ky <= kernelSize; ky++) {
                            for (let kx = -kernelSize; kx <= kernelSize; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                
                                // Spatial weight
                                const spatialDist = Math.sqrt(kx * kx + ky * ky);
                                const spatialWeight = Math.exp(-(spatialDist * spatialDist) / (2 * spatialSigma * spatialSigma));
                                
                                // Intensity weight
                                const intensityDiff = Math.sqrt(
                                    Math.pow(data[centerIdx] - data[idx], 2) +
                                    Math.pow(data[centerIdx + 1] - data[idx + 1], 2) +
                                    Math.pow(data[centerIdx + 2] - data[idx + 2], 2)
                                );
                                const intensityWeight = Math.exp(-(intensityDiff * intensityDiff) / (2 * intensitySigma * intensitySigma));
                                
                                const weight = spatialWeight * intensityWeight;
                                
                                sumR += data[idx] * weight;
                                sumG += data[idx + 1] * weight;
                                sumB += data[idx + 2] * weight;
                                sumW += weight;
                            }
                        }
                        
                        output[centerIdx] = sumR / sumW;
                        output[centerIdx + 1] = sumG / sumW;
                        output[centerIdx + 2] = sumB / sumW;
                    }
                }
                
                // Copy back
                for (let i = 0; i < data.length; i++) {
                    data[i] = output[i];
                }
            }
            
            trackOpticalFlow() {
                if (!this.simpleTracker.video) return;
                
                // Get current frame
                this.preprocessCtx.drawImage(
                    this.simpleTracker.video,
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                
                const currentFrame = this.preprocessCtx.getImageData(
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                
                if (this.opticalFlowData.prevFrame) {
                    // Calculate optical flow using Lucas-Kanade method (simplified)
                    const flow = this.calculateOpticalFlow(
                        this.opticalFlowData.prevFrame,
                        currentFrame
                    );
                    
                    // Average horizontal motion
                    const avgMotionX = flow.reduce((sum, v) => sum + v.x, 0) / flow.length;
                    
                    // Convert to cm (rough estimation)
                    const motionCm = avgMotionX * 50; // Scale factor
                    
                    // Trigger lane change if motion exceeds threshold
                    if (Math.abs(motionCm) > this.currentThreshold) {
                        this.triggerLaneChange(motionCm > 0 ? 'right' : 'left');
                    }
                    
                    this.confidence = Math.min(0.6, Math.abs(avgMotionX) * 10);
                }
                
                this.opticalFlowData.prevFrame = currentFrame;
            }
            
            calculateOpticalFlow(prevFrame, currentFrame) {
                // Simplified Lucas-Kanade optical flow
                const flow = [];
                const blockSize = 16;
                const width = prevFrame.width;
                const height = prevFrame.height;
                
                for (let y = blockSize; y < height - blockSize; y += blockSize) {
                    for (let x = blockSize; x < width - blockSize; x += blockSize) {
                        // Calculate gradients
                        let Ix = 0, Iy = 0, It = 0;
                        let sumIx2 = 0, sumIy2 = 0, sumIxIy = 0;
                        let sumIxIt = 0, sumIyIt = 0;
                        
                        for (let by = -blockSize/2; by < blockSize/2; by++) {
                            for (let bx = -blockSize/2; bx < blockSize/2; bx++) {
                                const idx = ((y + by) * width + (x + bx)) * 4;
                                const idxLeft = ((y + by) * width + (x + bx - 1)) * 4;
                                const idxRight = ((y + by) * width + (x + bx + 1)) * 4;
                                const idxUp = ((y + by - 1) * width + (x + bx)) * 4;
                                const idxDown = ((y + by + 1) * width + (x + bx)) * 4;
                                
                                // Spatial gradients
                                Ix = (currentFrame.data[idxRight] - currentFrame.data[idxLeft]) / 2;
                                Iy = (currentFrame.data[idxDown] - currentFrame.data[idxUp]) / 2;
                                
                                // Temporal gradient
                                It = currentFrame.data[idx] - prevFrame.data[idx];
                                
                                sumIx2 += Ix * Ix;
                                sumIy2 += Iy * Iy;
                                sumIxIy += Ix * Iy;
                                sumIxIt += Ix * It;
                                sumIyIt += Iy * It;
                            }
                        }
                        
                        // Solve for flow vector
                        const det = sumIx2 * sumIy2 - sumIxIy * sumIxIy;
                        if (Math.abs(det) > 0.001) {
                            const vx = (sumIy2 * (-sumIxIt) - sumIxIy * (-sumIyIt)) / det;
                            const vy = (sumIx2 * (-sumIyIt) - sumIxIy * (-sumIxIt)) / det;
                            
                            flow.push({ x: vx, y: vy });
                        }
                    }
                }
                
                return flow;
            }
            
            trackShoulders() {
                if (!this.simpleTracker.video) return;
                
                // Get frame
                this.preprocessCtx.drawImage(
                    this.simpleTracker.video,
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                
                const imageData = this.preprocessCtx.getImageData(
                    0, 0,
                    this.preprocessCanvas.width,
                    this.preprocessCanvas.height
                );
                
                // Find upper body silhouette (simplified edge detection)
                const edges = this.detectEdges(imageData);
                
                // Find shoulder positions
                const shoulderY = Math.floor(imageData.height * 0.3); // Upper third of image
                let leftMost = imageData.width;
                let rightMost = 0;
                
                for (let x = 0; x < imageData.width; x++) {
                    const idx = (shoulderY * imageData.width + x) * 4;
                    if (edges.data[idx] > 128) {
                        leftMost = Math.min(leftMost, x);
                        rightMost = Math.max(rightMost, x);
                    }
                }
                
                if (rightMost > leftMost) {
                    const centerX = (leftMost + rightMost) / 2;
                    const normalizedX = (centerX / imageData.width - 0.5) * 2; // -1 to 1
                    
                    // Convert to cm
                    const positionCm = normalizedX * 30; // Scale factor
                    
                    if (Math.abs(positionCm) > this.currentThreshold) {
                        this.triggerLaneChange(positionCm > 0 ? 'right' : 'left');
                    }
                    
                    this.shoulderData = {
                        leftEdge: leftMost,
                        rightEdge: rightMost,
                        centerX: centerX,
                        detected: true
                    };
                    
                    this.confidence = 0.4;
                }
            }
            
            detectEdges(imageData) {
                // Simplified Sobel edge detection
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const output = new ImageData(width, height);
                
                const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
                const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
                
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        let pixelX = 0;
                        let pixelY = 0;
                        
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4;
                                const gray = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                                const kernelIdx = (ky + 1) * 3 + (kx + 1);
                                
                                pixelX += gray * sobelX[kernelIdx];
                                pixelY += gray * sobelY[kernelIdx];
                            }
                        }
                        
                        const magnitude = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                        const idx = (y * width + x) * 4;
                        
                        output.data[idx] = magnitude;
                        output.data[idx + 1] = magnitude;
                        output.data[idx + 2] = magnitude;
                        output.data[idx + 3] = 255;
                    }
                }
                
                return output;
            }
            
            trackBigGestures() {
                // In very low light, require big movements
                if (!this.simpleTracker.video) return;
                
                // Get frame center brightness
                const metrics = this.analyzeFrame();
                
                // Show instruction to user
                const status = document.getElementById('headTrackStatus');
                if (status) {
                    status.innerHTML = `
                        <span style="color: #ff9900; font-size: 18px;">
                            🙌 BIG GESTURE MODE - Move head LEFT or RIGHT strongly!
                        </span>
                    `;
                }
                
                // Use optical flow but with much higher threshold
                const prevThreshold = this.currentThreshold;
                this.currentThreshold = this.gestureMode.requiredMovement;
                
                this.trackOpticalFlow();
                
                this.currentThreshold = prevThreshold;
                
                this.confidence = 0.2;
            }
            
            triggerLaneChange(direction) {
                const now = Date.now();
                
                // Check cooldown
                if (this.simpleTracker.cooldownActive && 
                    (now - this.simpleTracker.lastMoveTime) < this.simpleTracker.cooldownMs) {
                    return;
                }
                
                // Change lane
                if (direction === 'left' && gameState.playerLane > 0) {
                    gameState.playerLane--;
                    console.log(`⬅ ${this.currentMode.toUpperCase()}: Move left to lane ${gameState.playerLane}`);
                } else if (direction === 'right' && gameState.playerLane < 2) {
                    gameState.playerLane++;
                    console.log(`➡ ${this.currentMode.toUpperCase()}: Move right to lane ${gameState.playerLane}`);
                }
                
                this.simpleTracker.cooldownActive = true;
                this.simpleTracker.lastMoveTime = now;
                
                // Visual feedback
                if (this.simpleTracker.visualFeedback) {
                    this.simpleTracker.visualFeedback.triggerLaneChange(direction);
                }
                
                this.simpleTracker.showMoveFeedback(direction.toUpperCase());
            }
            
            updateModeFeedback() {
                // Update visual feedback to show current tracking mode
                if (this.simpleTracker.visualFeedback) {
                    const ctx = this.simpleTracker.canvas.getContext('2d');
                    
                    // Mode indicator
                    ctx.fillStyle = this.getModeColor();
                    ctx.fillRect(0, 0, 100, 20);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '12px monospace';
                    ctx.fillText(this.currentMode.toUpperCase(), 5, 15);
                    
                    // Confidence bar
                    const confWidth = this.confidence * 100;
                    ctx.fillStyle = this.confidence > 0.5 ? '#00ff00' : '#ff9900';
                    ctx.fillRect(0, 20, confWidth, 5);
                    
                    // Show shoulder detection if active
                    if (this.currentMode === this.TRACKING_MODES.SHOULDER && this.shoulderData.detected) {
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(this.shoulderData.leftEdge, 50);
                        ctx.lineTo(this.shoulderData.rightEdge, 50);
                        ctx.stroke();
                    }
                }
            }
            
            getModeColor() {
                switch (this.currentMode) {
                    case this.TRACKING_MODES.FACE:
                        return '#00ff00';
                    case this.TRACKING_MODES.OPTICAL_FLOW:
                        return '#00ccff';
                    case this.TRACKING_MODES.SHOULDER:
                        return '#ffcc00';
                    case this.TRACKING_MODES.GESTURE:
                        return '#ff6600';
                    default:
                        return '#ffffff';
                }
            }
        }
        
        // ============================================
        // SIMPLE HEAD TRACKER - Using Headtrackr.js
        // ============================================
        class SimpleHeadTracker {
            constructor() {
                // Core components
                this.htracker = null;
                this.video = null;
                this.canvas = null;
                this.isActive = false;
                
                // Tracking values
                this.lastX = 0;
                this.centerX = 0;
                this.cooldownActive = false;
                this.lastMoveTime = 0;
                this.confidence = 0;
                
                // Simple thresholds
                this.moveThreshold = 5; // cm of movement to trigger lane change
                this.cooldownMs = 300; // ms between moves
                
                // Debug
                this.debugMode = true;
                
                // Visual feedback system
                this.visualFeedback = null;
                this.renderLoop = null;
                
                this.init();
            }
            
            init() {
                // Get DOM elements
                this.video = document.getElementById('headTrackVideo');
                this.canvas = document.getElementById('headTrackCanvas');
                
                // Initialize visual feedback system
                if (this.canvas) {
                    this.visualFeedback = new AdvancedVisualFeedback(this.canvas);
                }
                
                // Create input canvas for headtrackr (hidden)
                const inputCanvas = document.createElement('canvas');
                inputCanvas.id = 'headtrackrInput';
                inputCanvas.width = 320;
                inputCanvas.height = 240;
                inputCanvas.style.display = 'none';
                document.body.appendChild(inputCanvas);
                
                // Setup button
                const toggleBtn = document.getElementById('headTrackToggle');
                if (toggleBtn) {
                    toggleBtn.addEventListener('click', () => this.toggle());
                }
                
                // Setup TAB key for debug mode toggle
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab' && this.visualFeedback) {
                        e.preventDefault();
                        this.visualFeedback.toggleDebugMode();
                    }
                });
                
                console.log('✅ Headtrackr.js with Advanced Visual Feedback initialized');
                console.log('💡 Press TAB to toggle debug modes (1=basic, 2=advanced, 3=developer)');
            }
            
            initializeHeadtrackr() {
                if (typeof headtrackr === 'undefined') {
                    console.error('❌ Headtrackr.js not loaded!');
                    return false;
                }
                
                try {
                    // Create headtrackr instance
                    this.htracker = new headtrackr.Tracker({
                        ui: false,
                        calcAngles: false,
                        headPosition: true
                    });
                    
                    // Initialize with video and canvas
                    const inputCanvas = document.getElementById('headtrackrInput');
                    this.htracker.init(this.video, inputCanvas);
                    
                    // Setup event listener for head tracking
                    document.addEventListener('headtrackingEvent', (event) => {
                        this.onHeadMove(event);
                    });
                    
                    console.log('✅ Headtrackr initialized');
                    return true;
                } catch (error) {
                    console.error('❌ Failed to initialize headtrackr:', error);
                    return false;
                }
            }
            
            toggle() {
                if (this.isActive) {
                    this.stop();
                } else {
                    this.start();
                }
            }
            
            async start() {
                try {
                    // Request webcam access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            width: 640, 
                            height: 480,
                            facingMode: 'user'
                        }
                    });
                    
                    this.video.srcObject = stream;
                    await this.video.play();
                    
                    // Initialize headtrackr after video is ready
                    if (!this.htracker) {
                        if (!this.initializeHeadtrackr()) {
                            alert('Headtrackr konnte nicht initialisiert werden.');
                            return;
                        }
                    }
                    
                    // Start tracking
                    this.htracker.start();
                    this.isActive = true;
                    
                    // Start render loop for visual feedback
                    this.startRenderLoop();
                    
                    // Update UI
                    document.getElementById('headTrackPreview').classList.add('active');
                    document.getElementById('headTrackToggle').classList.add('active');
                    document.getElementById('headTrackToggle').textContent = '🛑 Stop Tracking';
                    
                    // Calibrate center position after 1 second
                    setTimeout(() => {
                        this.centerX = this.lastX;
                        console.log('🎯 Calibrated center position:', this.centerX);
                        document.getElementById('headTrackStatus').textContent = 'Calibrating...';
                        
                        // After calibration, set to active
                        setTimeout(() => {
                            document.getElementById('headTrackStatus').textContent = 'TRACKING';
                            this.confidence = 1.0;
                        }, 500);
                    }, 1000);
                    
                    console.log('✅ Head tracking started with Headtrackr');
                } catch (error) {
                    console.error('❌ Failed to start head tracking:', error);
                    alert('Fehler beim Starten der Kopfsteuerung. Bitte Kamera-Zugriff erlauben.');
                }
            }
            
            startRenderLoop() {
                const render = () => {
                    if (this.isActive && this.visualFeedback) {
                        this.visualFeedback.render();
                        this.renderLoop = requestAnimationFrame(render);
                    }
                };
                render();
            }
            
            stop() {
                this.isActive = false;
                
                // Stop render loop
                if (this.renderLoop) {
                    cancelAnimationFrame(this.renderLoop);
                    this.renderLoop = null;
                }
                
                // Stop headtrackr
                if (this.htracker) {
                    this.htracker.stop();
                }
                
                // Stop video stream
                if (this.video && this.video.srcObject) {
                    const tracks = this.video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    this.video.srcObject = null;
                }
                
                // Clear canvas
                if (this.canvas) {
                    const ctx = this.canvas.getContext('2d');
                    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // Update UI
                document.getElementById('headTrackPreview').classList.remove('active');
                document.getElementById('headTrackToggle').classList.remove('active');
                document.getElementById('headTrackToggle').textContent = '📹 Head Tracking';
                document.getElementById('headTrackStatus').textContent = 'Inactive';
                
                console.log('✅ Head tracking stopped');
            }
            
            onHeadMove(event) {
                if (!this.isActive) return;
                
                // event.x is horizontal position in cm relative to screen
                const currentX = event.x;
                this.lastX = currentX;
                
                // Update confidence based on event (headtrackr provides this)
                this.confidence = event.confidence || 0.8;
                
                // Calculate relative movement from center
                const relativeX = currentX - this.centerX;
                
                // Update visual feedback system
                if (this.visualFeedback) {
                    const now = Date.now();
                    const cooldownTime = this.cooldownActive ? 
                        this.cooldownMs - (now - this.lastMoveTime) : 0;
                    const state = this.cooldownActive ? 'COOLDOWN' : 'TRACKING';
                    
                    this.visualFeedback.update(
                        relativeX,
                        this.confidence,
                        state,
                        this.cooldownActive,
                        cooldownTime
                    );
                }
                
                // Only process game moves if game is playing
                if (!gameState.isPlaying) return;
                
                // Check cooldown
                const now = Date.now();
                if (this.cooldownActive) {
                    if ((now - this.lastMoveTime) >= this.cooldownMs) {
                        this.cooldownActive = false;
                    } else {
                        return; // Still in cooldown
                    }
                }
                
                // Simple threshold-based lane change
                if (relativeX < -this.moveThreshold) {
                    // Move left
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        this.cooldownActive = true;
                        this.lastMoveTime = now;
                        console.log('⬅ HEAD: Move left to lane', gameState.playerLane);
                        
                        // Trigger visual effects
                        if (this.visualFeedback) {
                            this.visualFeedback.triggerLaneChange('left');
                        }
                        this.showMoveFeedback('LEFT');
                    }
                } else if (relativeX > this.moveThreshold) {
                    // Move right
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        this.cooldownActive = true;
                        this.lastMoveTime = now;
                        console.log('➡ HEAD: Move right to lane', gameState.playerLane);
                        
                        // Trigger visual effects
                        if (this.visualFeedback) {
                            this.visualFeedback.triggerLaneChange('right');
                        }
                        this.showMoveFeedback('RIGHT');
                    }
                }
                
                // Update status display
                document.getElementById('headTrackStatus').textContent = 
                    `${relativeX >= 0 ? '+' : ''}${relativeX.toFixed(1)}cm | Lane ${gameState.playerLane}`;
            }
            
            showMoveFeedback(direction) {
                // Quick visual feedback for successful move
                const canvas = this.canvas;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = direction === 'LEFT' ? '#00ff00' : '#00ffff';
                ctx.fillRect(0, 0, canvas.width, 10);
                
                setTimeout(() => {
                    ctx.clearRect(0, 0, canvas.width, 10);
                }, 100);
            }
        }
        
        // Initialize head tracking when page loads
        let headTracker = null;
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Low-Light Head Tracker after page load
            setTimeout(() => {
                headTracker = new LowLightHeadTracker();
                console.log('🌙 Low-Light Head Tracking System ready');
                console.log('💡 System will auto-calibrate for your lighting conditions');
                console.log('🎮 Use Q/E keys as fallback controls');
            }, 1000);
        });
        
        // ============================================
        // MOBILE TOUCH CONTROLLER
        // ============================================
        class TouchController {
            constructor() {
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.touchStartTime = 0;
                this.touchEndX = 0;
                this.touchEndY = 0;
                
                // Double/Triple tap detection
                this.lastTapTime = 0;
                this.tapCount = 0;
                this.tapTimeout = null;
                
                // Swipe detection thresholds
                this.minSwipeDistance = 30; // Minimum distance for swipe
                this.maxSwipeTime = 300; // Maximum time for swipe (ms)
                this.doubleTapDelay = 300; // Max time between taps
                
                // Duck state tracking
                this.duckTimeout = null;
                this.isDucking = false;
                
                this.init();
            }
            
            init() {
                // Get canvas element
                const canvas = document.getElementById('gameCanvas');
                if (!canvas) return;
                
                // Add touch event listeners with passive: false for better control
                canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Prevent default touch behaviors
                canvas.addEventListener('gesturestart', (e) => e.preventDefault());
                document.body.addEventListener('touchmove', (e) => {
                    if (e.target === canvas) e.preventDefault();
                }, { passive: false });
                
                console.log('📱 Touch Controller initialized');
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                if (!gameState.isPlaying) return;
                
                const touch = e.touches[0];
                this.touchStartX = touch.clientX;
                this.touchStartY = touch.clientY;
                this.touchStartTime = Date.now();
                
                // Double/Triple tap detection
                const currentTime = Date.now();
                const timeSinceLastTap = currentTime - this.lastTapTime;
                
                if (timeSinceLastTap < this.doubleTapDelay) {
                    this.tapCount++;
                } else {
                    this.tapCount = 1;
                }
                
                this.lastTapTime = currentTime;
                
                // Clear previous tap timeout
                if (this.tapTimeout) {
                    clearTimeout(this.tapTimeout);
                }
                
                // Set timeout to process taps
                this.tapTimeout = setTimeout(() => {
                    this.processTaps();
                }, this.doubleTapDelay);
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                if (!gameState.isPlaying) return;
                
                const touch = e.touches[0];
                this.touchEndX = touch.clientX;
                this.touchEndY = touch.clientY;
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                if (!gameState.isPlaying) return;
                
                const touch = e.changedTouches[0];
                this.touchEndX = touch.clientX;
                this.touchEndY = touch.clientY;
                
                // Calculate swipe
                const deltaX = this.touchEndX - this.touchStartX;
                const deltaY = this.touchEndY - this.touchStartY;
                const deltaTime = Date.now() - this.touchStartTime;
                
                // Check if it's a swipe (not a tap)
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > this.minSwipeDistance && deltaTime < this.maxSwipeTime) {
                    // It's a swipe, cancel tap processing
                    if (this.tapTimeout) {
                        clearTimeout(this.tapTimeout);
                        this.tapTimeout = null;
                    }
                    this.tapCount = 0;
                    
                    // Determine swipe direction
                    this.processSwipe(deltaX, deltaY);
                }
            }
            
            processSwipe(deltaX, deltaY) {
                const absX = Math.abs(deltaX);
                const absY = Math.abs(deltaY);
                
                // Determine primary direction
                if (absX > absY) {
                    // Horizontal swipe
                    if (deltaX > 0) {
                        this.swipeRight();
                    } else {
                        this.swipeLeft();
                    }
                } else {
                    // Vertical swipe
                    if (deltaY > 0) {
                        this.swipeDown();
                    } else {
                        this.swipeUp();
                    }
                }
            }
            
            swipeLeft() {
                // Move lane left
                if (gameState.playerLane > 0) {
                    gameState.playerLane--;
                    // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    console.log('📱 Swipe Left - Lane:', gameState.playerLane);
                }
            }
            
            swipeRight() {
                // Move lane right
                if (gameState.playerLane < 2) {
                    gameState.playerLane++;
                    // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    console.log('📱 Swipe Right - Lane:', gameState.playerLane);
                }
            }
            
            swipeUp() {
                // If ducking, stand up
                if (gameState.playerAction === 'ducking') {
                    this.standUp();
                } 
                // If running, first jump
                else if (gameState.playerAction === 'running') {
                    this.jump();
                }
                // If already jumping, perform multi-jump
                else if (gameState.playerAction === 'jumping') {
                    this.performMultiJump();
                }
            }
            
            performMultiJump() {
                // Check current jump count and perform next jump level
                if (gameState.jumpCount === 1 && gameState.jumpCount < 3) {
                    // Second jump (Double Jump)
                    gameState.jumpVelocity = 12;
                    gameState.jumpCount = 2;
                    gameState.jumpStartTime = performance.now();
                    
                    // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    }
                    
                    // Double jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF8800,
                        'jump'
                    );
                    
                    console.log('📱 Swipe Up - Double Jump!');
                } 
                else if (gameState.jumpCount === 2 && gameState.jumpCount < 3) {
                    // Third jump (Triple Jump)
                    gameState.jumpVelocity = 14;
                    gameState.jumpCount = 3;
                    gameState.jumpStartTime = performance.now();
                    
                    // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    }
                    
                    // Triple jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF0088,
                        'jump'
                    );
                    
                    console.log('📱 Swipe Up - Triple Jump!');
                }
            }
            
            swipeDown() {
                // Duck
                if (gameState.playerAction === 'running') {
                    this.duck();
                }
                // If jumping, fast fall (slam down)
                else if (gameState.playerAction === 'jumping') {
                    gameState.jumpVelocity = -15; // Fast fall
                    console.log('📱 Swipe Down - Fast Fall');
                }
            }
            
            processTaps() {
                if (!gameState.isPlaying) return;
                
                console.log('📱 Taps detected:', this.tapCount);
                
                if (this.tapCount === 1) {
                    // Single tap - Jump
                    this.jump();
                } else if (this.tapCount === 2) {
                    // Double tap - Double Jump
                    this.doubleJump();
                } else if (this.tapCount >= 3) {
                    // Triple tap - Multi Jump
                    this.multiJump();
                }
                
                // Reset tap count
                this.tapCount = 0;
                this.tapTimeout = null;
            }
            
            jump() {
                if (gameState.playerAction === 'running') {
                    gameState.playerAction = 'jumping';
                    gameState.jumpVelocity = 10;
                    gameState.jumpStartTime = performance.now();
                    gameState.jumpCount = 1;
                    
                    // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    }
                    
                    // Jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, 0.1, player.position.z),
                        0xFFFF00,
                        'jump'
                    );
                    
                    console.log('📱 Jump!');
                }
            }
            
            doubleJump() {
                if (gameState.playerAction === 'jumping' && gameState.jumpCount < 2) {
                    gameState.jumpVelocity = 12;
                    gameState.jumpCount = 2;
                    gameState.jumpStartTime = performance.now();
                    
                    // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    }
                    
                    // Double jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF8800,
                        'jump'
                    );
                    
                    console.log('📱 Double Jump!');
                }
            }
            
            multiJump() {
                if (gameState.jumpCount < 3) {
                    gameState.playerAction = 'jumping';
                    gameState.jumpVelocity = 14;
                    gameState.jumpCount = 3;
                    gameState.jumpStartTime = performance.now();
                    
                    // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    }
                    
                    // Multi jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF0088,
                        'jump'
                    );
                    
                    console.log('📱 Multi Jump!');
                }
            }
            
            duck() {
                gameState.playerAction = 'ducking';
                this.isDucking = true;
                
                const speedMultiplier = gameState.speed / gameState.maxSpeed;
                audioManager.playSpeedDependentSound('duck', speedMultiplier);
                
                // NO auto stand up - only manual with swipe up
                console.log('📱 Duck! (Swipe up to stand)');
            }
            
            standUp() {
                if (gameState.playerAction === 'ducking') {
                    gameState.playerAction = 'running';
                    this.isDucking = false;
                    
                    if (this.duckTimeout) {
                        clearTimeout(this.duckTimeout);
                        this.duckTimeout = null;
                    }
                    
                    console.log('📱 Stand Up!');
                }
            }
        }
        
        // Initialize touch controller
        let touchController = null;
        document.addEventListener('DOMContentLoaded', () => {
            // Check if mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile || 'ontouchstart' in window) {
                touchController = new TouchController();
                console.log('📱 Mobile device detected - Touch controls enabled');
                
                // Show mobile controls instructions
                const desktopControls = document.querySelector('.desktop-controls');
                const mobileControls = document.querySelector('.mobile-controls');
                if (desktopControls) desktopControls.style.display = 'none';
                if (mobileControls) mobileControls.style.display = 'block';
            }
            
            // Setup audio toggle button
            const audioToggle = document.getElementById('audioToggle');
            if (audioToggle) {
                // Set initial state based on AudioManager
                updateAudioButtonState();
                
                audioToggle.addEventListener('click', () => {
                    // FIXED: Check if audioManager exists before using it
                    const isMuted = (typeof audioManager !== 'undefined' && audioManager) ? audioManager.toggleMute() : false;
                    updateAudioButtonState();
                    
                    // Resume audio context if needed
                    if (!isMuted) {
                        if (typeof audioManager !== 'undefined' && audioManager) {
                            audioManager.resume();
                        }
                    }
                });
            }
        });
        
        // Helper function to update audio button appearance
        function updateAudioButtonState() {
            const audioToggle = document.getElementById('audioToggle');
            if (audioToggle && audioManager) {
                if (typeof audioManager !== 'undefined' && audioManager && audioManager.isMuted) {
                    audioToggle.textContent = '🔇';
                    audioToggle.classList.add('muted');
                    audioToggle.title = 'Enable Sound';
                } else {
                    audioToggle.textContent = '🔊';
                    audioToggle.classList.remove('muted');
                    audioToggle.title = 'Disable Sound';
                }
            }
        }
        
        // Modern Audio System with Real Sounds
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.masterVolume = 0.3;
                this.isMuted = true; // Start muted by default!
                this.audioBuffers = {}; // Cache for loaded sounds
                this.soundUrls = {
                    // Using free sound effects (these are example URLs - replace with actual working ones)
                    jump: 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=', // Placeholder
                    coin: 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=', // Placeholder
                    crash: null, // Will use synthesizer
                    whoosh: null, // Will use synthesizer
                    land: null, // Will use synthesizer
                    powerup: null, // Will use synthesizer
                };
                // DON'T initialize audio here - wait for user interaction!
                this.audioInitialized = false;
                this.loadMutePreference();
            }

            async initAudio() {
                if (this.audioInitialized) return; // Already initialized
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.isMuted ? 0 : this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);
                    this.createAdvancedSounds();
                    this.audioInitialized = true;
                    this.preloadSounds(); // Now load sounds after context is created
                    console.log('✅ Audio system initialized on user interaction');
                } catch (error) {
                    console.log('Audio not supported');
                }
            }
            
            loadMutePreference() {
                const saved = localStorage.getItem('audioMuted');
                if (saved !== null) {
                    this.isMuted = saved === 'true';
                    if (this.masterGain) {
                        this.masterGain.gain.value = this.isMuted ? 0 : this.masterVolume;
                    }
                }
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.isMuted ? 0 : this.masterVolume;
                }
                localStorage.setItem('audioMuted', this.isMuted);
                return this.isMuted;
            }
            
            mute() {
                this.isMuted = true;
                if (this.masterGain) {
                    this.masterGain.gain.value = 0;
                }
                localStorage.setItem('audioMuted', 'true');
            }
            
            unmute() {
                this.isMuted = false;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.masterVolume;
                }
                localStorage.setItem('audioMuted', 'false');
            }
            
            async preloadSounds() {
                // FIX: Don't use fetch() for data: URLs - causes CSP violations
                // Skip preloading to prevent crashes
                return; // TEMPORARILY DISABLED to fix Desktop crashes
            }
            
            playBuffer(name) {
                if (this.audioBuffers[name] && this.audioContext) {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = this.audioBuffers[name];
                    source.connect(this.masterGain);
                    source.start();
                    return true;
                }
                return false;
            }

            createTone(frequency, duration, type = 'sine', fadeOut = true) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                if (fadeOut) {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                } else {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                }
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            createNoise(duration, filterFreq = 1000) {
                if (!this.audioContext || this.isMuted) return; // Check muted!
                
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const source = this.audioContext.createBufferSource();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();
                
                source.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;
                
                source.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                source.start();
            }

            createAdvancedSounds() {
                // Enhanced realistic sounds using multiple layers
                this.sounds = {
                    jump: () => {
                        // Softer, more natural jump sound
                        this.createTone(100, 0.05, 'sine'); // Soft thud
                        setTimeout(() => this.createNoise(0.04, 1500), 20); // Light whoosh
                        // Removed reverb for cleaner sound
                    },
                    
                    land: () => {
                        // Subtle landing sound
                        this.createTone(60, 0.08, 'sine'); // Soft thud
                        this.createNoise(0.05, 600); // Light impact
                        // No reverb for cleaner sound
                    },
                    
                    duck: () => {
                        // Minimal duck sound
                        this.createNoise(0.06, 2000); // Soft swoosh
                        this.createTone(90, 0.06, 'sine'); // Light movement
                    },
                    
                    success: () => {
                        // Triumphant success with harmonic progression
                        const notes = [400, 500, 630, 800, 1000];
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.2, 'sine');
                                this.createReverbEffect(freq, 0.15, 0.6); // Rich reverb
                            }, i * 80);
                        });
                        // Add sparkle effect
                        setTimeout(() => {
                            for (let j = 0; j < 8; j++) {
                                setTimeout(() => this.createTone(1200 + j * 100, 0.05, 'sine'), j * 25);
                            }
                        }, 400);
                    },
                    
                    collision: () => {
                        // Softer collision sound
                        this.createNoise(0.15, 800); // Muffled impact
                        this.createTone(40, 0.2, 'sine', false); // Low bump
                        
                        if (window.gameState) {
                            gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, 0.15);
                        }
                    },
                    
                    coin: () => {
                        // Pleasant two-tone chime
                        this.createTone(800, 0.08, 'sine'); // First note
                        setTimeout(() => this.createTone(1200, 0.06, 'sine'), 40); // Second note
                        // Removed excessive shimmer effects
                    },
                    
                    whoosh: () => {
                        // Subtle lane change sound
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.5;
                        this.createNoise(0.08, 1500 + speedMultiplier * 500); // Light swoosh
                        // Removed tone for cleaner effect
                    },
                    
                    powerup: () => {
                        // Epic power-up activation sequence
                        const powerChord = [400, 500, 600, 750, 900];
                        powerChord.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.25, 'sine');
                                this.createReverbEffect(freq, 0.2, 0.8);
                            }, i * 60);
                        });
                        
                        // Add ascending energy effect
                        setTimeout(() => {
                            for (let m = 0; m < 12; m++) {
                                setTimeout(() => {
                                    this.createTone(1000 + m * 50, 0.04, 'triangle');
                                }, m * 30);
                            }
                        }, 300);
                    },
                    
                    // NEW: Ambient city sounds
                    ambient: () => {
                        if (!this.ambientPlaying) {
                            this.ambientPlaying = true;
                            this.playAmbientLoop();
                        }
                    },
                    
                    // NEW: Speed-based engine sound
                    engine: () => {
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.3;
                        const engineFreq = 40 + speedMultiplier * 60;
                        this.createTone(engineFreq, 0.2, 'sawtooth', false);
                    },
                    
                    // NEW: Near miss bonus sound
                    nearmiss: () => {
                        this.createTone(600, 0.08, 'sine');
                        setTimeout(() => this.createTone(800, 0.06, 'triangle'), 30);
                        this.createNoise(0.05, 5000); // Subtle whoosh
                    }
                };
            }

            // Enhanced reverb effect for depth
            createReverbEffect(frequency, duration, intensity) {
                if (!this.audioContext || this.isMuted) return; // Check muted!
                
                const delay = this.audioContext.createDelay(0.3);
                const feedback = this.audioContext.createGain();
                const wetGain = this.audioContext.createGain();
                
                delay.delayTime.value = 0.1;
                feedback.gain.value = intensity * 0.4;
                wetGain.gain.value = intensity * 0.3;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(wetGain);
                wetGain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            // Ambient city soundscape
            playAmbientLoop() {
                if (!this.audioContext || !this.ambientPlaying) return;
                
                // Distant traffic rumble
                const trafficFreq = 60 + Math.random() * 20;
                this.createTone(trafficFreq, 2.0, 'sawtooth', false);
                
                // Occasional distant sounds
                if (Math.random() > 0.7) {
                    setTimeout(() => {
                        this.createNoise(0.05, 800 + Math.random() * 1000);
                    }, Math.random() * 1000);
                }
                
                // Continue ambient loop
                setTimeout(() => this.playAmbientLoop(), 2000);
            }
            
            stopAmbient() {
                this.ambientPlaying = false;
            }
            
            // Dynamic sound based on game speed
            playSpeedDependentSound(soundName, speedMultiplier = 1) {
                const originalVolume = this.masterGain.gain.value;
                const speedVolume = Math.min(originalVolume * (0.8 + speedMultiplier * 0.4), 1.0);
                
                this.masterGain.gain.value = speedVolume;
                this.play(soundName);
                
                // Restore original volume
                setTimeout(() => {
                    this.masterGain.gain.value = originalVolume;
                }, 200);
            }
            
            play(soundName) {
                if (this.isMuted) return; // Don't play if muted
                
                // First try to play buffered/real sound
                if (this.playBuffer(soundName)) {
                    return; // Successfully played real sound
                }
                
                // Fall back to synthesizer sounds
                if (this.sounds[soundName]) {
                    try {
                        this.sounds[soundName]();
                    } catch (error) {
                        console.warn('Audio playback error:', error);
                    }
                }
            }

            async resume() {
                // First ensure audio is initialized
                if (!this.audioInitialized) {
                    await this.initAudio();
                }
                
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }
        }

        const audioManager = new AudioManager();
        if (typeof audioManager !== 'undefined' && audioManager) {
            audioManager.ambientPlaying = false;
        }
        
        // Auto-start ambient sounds when game starts
        let ambientStarted = false;

        // Supabase Configuration - Disabled for now to fix startup issue
        const SUPABASE_URL = 'https://cquahsbgcycdmslcmmdz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxdWFoc2JnY3ljZG1zbGNtbWR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzY1MzU2NDUsImV4cCI6MjA1MjExMTY0NX0.7icZ7GGer0DAM2gxHpeXCOS6K-xLziVX9w0nwPmA0_k';
        
        // Initialize Supabase client
        let supabase = null;
        let highscores = [];
        let currentScore = 0;
        let currentSurvivalTime = 0;
        let isOnlineMode = false; // Track if we're using online highscores

        // TEMPORARILY DISABLED - Causes crashes
        supabase = null;
        isOnlineMode = false;
        
        // DISABLED - Not needed
        function testSupabaseConnection() {
            return; // Skip
        }
        
        // Update UI to show connection status
        function updateConnectionStatus() {
            // Add status indicator to highscore panel
            const highscorePanel = document.getElementById('highscorePanel');
            if (highscorePanel) {
                const statusBadge = document.createElement('div');
                statusBadge.id = 'connectionStatus';
                statusBadge.style.cssText = `
                    position: absolute;
                    top: 5px;
                    right: 5px;
                    padding: 2px 8px;
                    border-radius: 10px;
                    font-size: 10px;
                    font-weight: bold;
                `;
                
                if (isOnlineMode) {
                    statusBadge.innerHTML = '🌐 ONLINE';
                    statusBadge.style.background = 'rgba(0, 255, 0, 0.2)';
                    statusBadge.style.color = '#00ff00';
                    statusBadge.title = 'Globale Highscores aktiv';
                } else {
                    statusBadge.innerHTML = '💾 OFFLINE';
                    statusBadge.style.background = 'rgba(255, 165, 0, 0.2)';
                    statusBadge.style.color = '#ffa500';
                    statusBadge.title = 'Lokale Highscores (nur Browser)';
                }
                
                // Remove old badge if exists
                const oldBadge = document.getElementById('connectionStatus');
                if (oldBadge) oldBadge.remove();
                
                highscorePanel.appendChild(statusBadge);
            }
            
            // Show temporary notification
            showConnectionNotification();
        }
        
        // Show a temporary notification about connection status
        function showConnectionNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 10px 20px;
                border-radius: 20px;
                font-weight: bold;
                z-index: 10000;
                animation: slideDown 0.5s ease;
            `;
            
            if (isOnlineMode) {
                notification.innerHTML = '🌐 Online Highscores aktiviert!';
                notification.style.background = 'rgba(0, 255, 0, 0.9)';
                notification.style.color = 'white';
            } else {
                notification.innerHTML = '💾 Offline-Modus - Scores werden lokal gespeichert';
                notification.style.background = 'rgba(255, 165, 0, 0.9)';
                notification.style.color = 'white';
            }
            
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideUp 0.5s ease';
                setTimeout(() => notification.remove(), 500);
            }, 3000);
        }

        // Highscore Management System
        class HighscoreManager {
            constructor() {
                this.localStorageKey = 'subwayRunner_highscores';
                this.loadHighscores();
            }

            async loadHighscores() {
                try {
                    if (supabase && isOnlineMode) {
                        const { data, error } = await supabase
                            .from('subway_runner_scores')
                            .select('*')
                            .order('score', { ascending: false })
                            .limit(10);
                        
                        if (!error && data) {
                            highscores = data;
                            console.log('📊 Loaded online highscores:', data.length, 'entries');
                        } else {
                            console.warn('⚠️ Failed to load online scores:', error?.message);
                            throw new Error('Supabase error');
                        }
                    } else {
                        throw new Error('Using offline mode');
                    }
                } catch (error) {
                    // Fallback to localStorage
                    console.log('💾 Using local highscores (offline mode)');
                    const localScores = localStorage.getItem(this.localStorageKey);
                    highscores = localScores ? JSON.parse(localScores) : [];
                }
                this.displayHighscores();
            }

            async submitScore(playerName, score, survivalTime, isVictory) {
                const scoreEntry = {
                    player_name: playerName,
                    score: score,
                    survival_time: survivalTime,
                    is_victory: isVictory,
                    created_at: new Date().toISOString()
                };

                let submitted = false;
                
                try {
                    if (supabase && isOnlineMode) {
                        const { data, error } = await supabase
                            .from('subway_runner_scores')
                            .insert([scoreEntry])
                            .select();
                        
                        if (error) {
                            console.error('❌ Failed to submit online score:', error);
                            throw error;
                        }
                        console.log('✅ Score submitted online:', data);
                        submitted = true;
                    }
                } catch (error) {
                    console.warn('⚠️ Falling back to local storage');
                }
                
                // Always save locally as backup
                if (!submitted || !isOnlineMode) {
                    console.log('💾 Saving score locally');
                    const localScores = localStorage.getItem(this.localStorageKey);
                    let scores = localScores ? JSON.parse(localScores) : [];
                    scores.push(scoreEntry);
                    scores.sort((a, b) => b.score - a.score);
                    scores = scores.slice(0, 10); // Keep only top 10
                    localStorage.setItem(this.localStorageKey, JSON.stringify(scores));
                }

                await this.loadHighscores();
            }

            isHighscore(score) {
                if (highscores.length < 10) return true;
                return score > highscores[9].score;
            }

            displayHighscores() {
                const list = document.getElementById('highscoreList');
                if (highscores.length === 0) {
                    list.innerHTML = 'Keine Scores vorhanden';
                    return;
                }

                let html = '';
                highscores.forEach((score, index) => {
                    const rank = index + 1;
                    const victoryIcon = score.is_victory ? '🏆' : '';
                    const timeText = score.is_victory ? '60s' : `${score.survival_time}s`;
                    
                    html += `<div class="highscore-entry">
                        ${rank}. ${score.player_name} ${victoryIcon}<br>
                        <small>${score.score} pts - ${timeText}</small>
                    </div>`;
                });
                list.innerHTML = html;
            }
        }

        const highscoreManager = new HighscoreManager();
        
        // Highscore Panel Visibility Control
        let highscorePanelTimeout = null;
        
        function showHighscorePanelTemporarily() {
            const panel = document.getElementById('highscorePanel');
            if (!panel) return;
            
            // Show panel
            panel.classList.add('visible');
            panel.classList.remove('fading');
            
            // Hide after 5 seconds
            if (highscorePanelTimeout) {
                clearTimeout(highscorePanelTimeout);
            }
            
            highscorePanelTimeout = setTimeout(() => {
                hideHighscorePanel();
            }, 5000);
        }
        
        function showHighscorePanel() {
            const panel = document.getElementById('highscorePanel');
            if (!panel) return;
            panel.classList.add('visible');
            panel.classList.remove('fading');
        }
        
        function hideHighscorePanel() {
            const panel = document.getElementById('highscorePanel');
            if (!panel) return;
            
            panel.classList.add('fading');
            setTimeout(() => {
                panel.classList.remove('visible');
                panel.classList.remove('fading');
            }, 500);
        }

        // Make functions globally available for onclick handlers
        window.startGame = async function() {
            console.log('startGame called');
            try {
                await startGameInternal();
            } catch (error) {
                console.error('Error in startGame:', error);
            }
        };

        window.submitHighscore = function() {
            console.log('submitHighscore called');
            submitHighscoreInternal();
        };

        window.skipHighscore = function() {
            console.log('skipHighscore called');
            skipHighscoreInternal();
        };

        // Game state
        let gameState = {
            isPlaying: false,
            isGameOver: false,
            isVictory: false,
            score: 0,
            speed: 0.08, // Langsamerer Start
            baseSpeed: 0.08,
            maxSpeed: 0.45, // Sehr schnell am Ende!
            lives: 3,
            gameTime: 60, // 60 Sekunden pro Durchgang
            timeRemaining: 60,
            gameStartTime: 0,
            // 3-DURCHGANG-SYSTEM
            currentRound: 1, // 1-3
            roundStartTime: 0,
            totalGameTime: 180, // 3x60 Sekunden
            roundTransition: false,
            roundTransitionStartTime: 0,
            roundTransitionDuration: 3000, // 3 Sekunden Übergang
            playerLane: 1, // 0=left, 1=center, 2=right
            playerAction: 'running', // running, jumping, ducking
            playerY: 0,
            jumpVelocity: 0,
            // JUMP TIMEOUT SYSTEM
            jumpStartTime: 0,
            maxJumpDuration: 1000, // 1 second max jump time
            // MULTI-LEVEL JUMP SYSTEM (V4.0)
            jumpCount: 0,
            maxJumps: 4,
            currentHeightLevel: 1,
            aerialCombo: 0,
            obstacles: [],
            invulnerable: false,
            invulnerabilityTime: 0,
            timeScale: 1.0,
            cameraShakeIntensity: 0,
            cameraZoom: 1.0,
            slowMotionActive: false,
            // STABILITY FEATURES
            scoreThisFrame: 0,
            frameCount: 0,
            lastHealthCheck: 0,
            // COLLECTIBLES SYSTEM
            lastCollectibleTime: 0,
            collectibleInterval: 2500, // 2.5 seconds (increased from 4)
            activeCollectibles: [],
            maxActiveCollectibles: 10, // Increased from 8
            collectedApples: 0,
            collectedBroccolis: 0
        };
        
        // STABILITY LIMITS
        const LIMITS = {
            MAX_SCORE_PER_FRAME: 50,
            MAX_OBSTACLES: 20,
            MAX_SCENE_OBJECTS: 500,
            HEALTH_CHECK_INTERVAL: 5000 // 5 seconds
        };

        // ==================== LEVEL SYSTEM V3.3 ====================
        let currentLevel = 1;
        const LEVEL_PROGRESSION_THRESHOLD = 1000; // Points needed per level
        let nextLevelScore = LEVEL_PROGRESSION_THRESHOLD;
        
        // Level Manager
        const LevelManager = {
            levels: {},
            currentLevel: 1,
            levelObjects: [],
            
            registerLevel: function(id, level) {
                this.levels[id] = level;
            },
            
            loadLevel: function(levelId) {
                console.log(`🎮 Loading Level ${levelId}`);
                
                // Cleanup previous level
                this.cleanup();
                
                // Load new level
                if (this.levels[levelId]) {
                    try {
                        this.currentLevel = levelId;
                        this.levels[levelId].load(scene, renderer);
                        
                        // Show level notification
                        this.showLevelNotification(levelId);
                        
                        // Update game state
                        currentLevel = levelId;
                        
                        // Clear loading flag on success
                        this.loadingLevel = null;
                    } catch (error) {
                        console.error(`Failed to load level ${levelId}:`, error);
                        // Reset loading flag on error
                        this.loadingLevel = null;
                        // Keep playing with current level
                        console.log('Continuing with current level due to load error');
                    }
                } else {
                    this.loadingLevel = null;
                }
            },
            
            cleanup: function() {
                // Remove all level-specific objects
                this.levelObjects.forEach(obj => {
                    if (obj.parent) {
                        obj.parent.remove(obj);
                    }
                    // Dispose geometries and materials
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(mat => mat.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });
                this.levelObjects = [];
                
                // Let current level cleanup
                if (this.levels[this.currentLevel] && this.levels[this.currentLevel].cleanup) {
                    this.levels[this.currentLevel].cleanup();
                }
            },
            
            update: function(deltaTime) {
                // Update current level
                if (this.levels[this.currentLevel] && this.levels[this.currentLevel].update) {
                    this.levels[this.currentLevel].update(deltaTime);
                }
                
                // Check for level progression
                this.checkProgression();
            },
            
            checkProgression: function() {
                // Prevent progression during game over, victory, or while loading
                if (gameState.isGameOver || gameState.isVictory || this.loadingLevel) {
                    return;
                }
                
                // Prevent rapid-fire level changes
                const now = Date.now();
                if (this.lastLevelChange && (now - this.lastLevelChange) < 2000) {
                    return; // Wait at least 2 seconds between level changes
                }
                
                nextLevelScore = currentLevel * 1000; // Update for test compatibility
                const nextLevelThreshold = currentLevel * LEVEL_PROGRESSION_THRESHOLD;
                if (gameState.score >= nextLevelThreshold && currentLevel < 10 && this.levels[currentLevel + 1]) {
                    this.lastLevelChange = now;
                    currentLevel++; // INCREMENT BEFORE LOADING!
                    this.loadLevel(currentLevel);
                    nextLevelScore = currentLevel * 1000;
                }
            },
            
            checkLevelTransition: function() {
                // Alias for test compatibility
                this.checkProgression();
            },
            
            showLevelNotification: function(levelId) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 48px;
                    font-weight: bold;
                    color: #00ff00;
                    text-shadow: 0 0 20px rgba(0,255,0,0.8);
                    z-index: 10000;
                    pointer-events: none;
                `;
                
                const levelName = this.levels[levelId].name || `Level ${levelId}`;
                notification.textContent = `${levelName}!`;
                document.body.appendChild(notification);
                
                // Animate and remove
                setTimeout(() => {
                    notification.style.transition = 'opacity 1s';
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 1000);
                }, 2000);
            },
            
            addLevelObject: function(obj) {
                this.levelObjects.push(obj);
            }
        };

        // ==================== LEVEL DEFINITIONS ====================
        
        // Level 1: Classic Subway
        const Level1 = {
            id: 1,
            name: "Classic Subway",
            description: "Classic underground subway environment",
            fogColor: 0x222222,
            fogDensity: 0.015,
            
            load: function(scene, renderer) {
                console.log('🚇 Loading Level 1: Subway Tunnel');
                
                // Set fog and background
                scene.fog = new THREE.FogExp2(this.fogColor, this.fogDensity);
                renderer.setClearColor(this.fogColor);
                
                // Level 1 uses existing environment (buildings, street lamps, etc.)
                // No additional setup needed as it's the default
            },
            
            update: function(deltaTime) {
                // Level 1 has no special updates
            },
            
            cleanup: function() {
                // Level 1 doesn't need special cleanup
            }
        };

        // Level 2: Neon Night Run
        const Level2 = {
            id: 2,
            name: "Neon Night Run",
            description: "Cyberpunk city with neon lights",
            fogColor: 0x001133,
            fogDensity: 0.025,
            objects: {
                cyberpunkBuildings: [],
                neonLights: [],
                gridFloor: null
            },
            
            load: function(scene, renderer) {
                console.log('🌃 Loading Level 2: Neon Night Run');
                
                // Update environment
                scene.fog = new THREE.FogExp2(this.fogColor, this.fogDensity);
                renderer.setClearColor(this.fogColor);
                
                // Safe environment handling - these objects don't exist
                // Skip hiding non-existent objects to prevent crashes
                console.log('Level 2 loading - skipping environment object hiding');
                
                // Create neon environment
                this.createEnvironment(scene);
            },
            
            createEnvironment: function(scene) {
                // Create neon grid floor
                const gridHelper = new THREE.GridHelper(100, 50, 0x00FFFF, 0x004444);
                gridHelper.position.y = -0.95;
                gridHelper.userData = { type: 'level2Grid' };
                scene.add(gridHelper);
                this.objects.gridFloor = gridHelper;
                LevelManager.addLevelObject(gridHelper);
                
                // Create cyberpunk buildings
                for (let i = 0; i < 20; i++) {
                    const buildingGroup = new THREE.Group();
                    const width = 6 + Math.random() * 4;
                    const height = 20 + Math.random() * 30;
                    const depth = 6 + Math.random() * 4;
                    
                    // Building body
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const buildingMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x111122,
                        emissive: 0x000011
                    });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.y = height / 2;
                    buildingGroup.add(building);
                    
                    // Neon edges (wireframe)
                    const edgeGeometry = new THREE.EdgesGeometry(buildingGeometry);
                    const edgeMaterial = new THREE.LineBasicMaterial({ 
                        color: Math.random() > 0.5 ? 0x00FFFF : 0xFF00FF,
                        linewidth: 2
                    });
                    const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    edges.position.y = height / 2;
                    buildingGroup.add(edges);
                    this.objects.neonLights.push(edges);
                    
                    // Position building
                    const side = i % 2 === 0 ? 1 : -1;
                    buildingGroup.position.set(
                        side * (20 + Math.random() * 15),
                        0,
                        -i * 8
                    );
                    buildingGroup.userData = { type: 'cyberpunkBuilding' };
                    
                    scene.add(buildingGroup);
                    this.objects.cyberpunkBuildings.push(buildingGroup);
                    LevelManager.addLevelObject(buildingGroup);
                }
            },
            
            update: function(deltaTime) {
                // Animate neon lights
                this.objects.neonLights.forEach((light, index) => {
                    if (light.material) {
                        // Pulse effect
                        const pulse = Math.sin(Date.now() * 0.002 + index) * 0.3 + 0.7;
                        light.material.opacity = pulse;
                    }
                });
                
                // Move buildings forward
                this.objects.cyberpunkBuildings.forEach(building => {
                    building.position.z += gameState.speed * 0.7;
                    
                    // Recycle buildings
                    if (building.position.z > 10) {
                        building.position.z -= 200;
                    }
                });
            },
            
            cleanup: function() {
                try {
                    console.log('Neon level cleanup started');
                    
                    // Clear level objects safely with full error handling
                    if (this.objects) {
                        // Safe cleanup of arrays
                        ['cyberpunkBuildings', 'neonLights'].forEach(key => {
                            if (this.objects[key] && Array.isArray(this.objects[key])) {
                                this.objects[key].forEach(obj => {
                                    if (obj && obj.parent) {
                                        try { scene.remove(obj); } catch(e) {}
                                    }
                                });
                                this.objects[key] = [];
                            }
                        });
                        
                        // Safe cleanup of single objects
                        if (this.objects.gridFloor) {
                            try {
                                if (this.objects.gridFloor.parent) {
                                    scene.remove(this.objects.gridFloor);
                                }
                            } catch(e) {}
                            this.objects.gridFloor = null;
                        }
                    }
                    console.log('Neon level cleanup completed');
                } catch (error) {
                    console.error('Error during cleanup, but continuing:', error);
                    // Game continues even if cleanup fails
                }
            }
        };

        // Register levels
        LevelManager.registerLevel(1, Level1);
        LevelManager.registerLevel(2, Level2);
        
        // HEIGHT LEVEL SYSTEM (V4.0)
        const HEIGHT_LEVELS = {
            GROUND: 0,
            DUCKING: 0.5,
            STANDING: 1.0,
            JUMP_1: 3.0,
            JUMP_2: 5.0,
            JUMP_3: 7.0,
            SUPER: 8.0
        };
        
        // Get current player height level (0-5)
        function getPlayerHeightLevel() {
            const y = gameState.playerY;
            if (y >= HEIGHT_LEVELS.SUPER) return 5;
            if (y >= HEIGHT_LEVELS.JUMP_3) return 4;
            if (y >= HEIGHT_LEVELS.JUMP_2) return 3;
            if (y >= HEIGHT_LEVELS.JUMP_1) return 2;
            if (gameState.playerAction === 'ducking') return 0;
            return 1; // Standing
        }
        
        // SAFE SCORE FUNCTION WITH LIMITS
        function addScore(amount) {
            if (!gameState.isPlaying) return;
            
            // Limit score per frame
            if (gameState.scoreThisFrame + amount > LIMITS.MAX_SCORE_PER_FRAME) {
                amount = LIMITS.MAX_SCORE_PER_FRAME - gameState.scoreThisFrame;
            }
            
            if (amount > 0) {
                gameState.score += amount;
                gameState.scoreThisFrame += amount;
            }
        }
        
        // STABILITY: Health monitoring
        function performHealthCheck() {
            const health = {
                fps: gameState.frameCount / 5, // Rough FPS over last 5 seconds
                obstacles: obstacles.length,
                sceneObjects: scene.children.length,
                score: gameState.score,
                memory: performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 'N/A'
            };
            
            console.log('=== HEALTH CHECK ===', health);
            
            // Reset frame counter
            gameState.frameCount = 0;
            
            // WARNINGS
            if (health.fps < 30) {
                console.warn('LOW FPS:', health.fps);
            }
            
            if (health.sceneObjects > LIMITS.MAX_SCENE_OBJECTS) {
                console.warn('TOO MANY OBJECTS:', health.sceneObjects);
            }
            
            if (health.score > 999999) {
                console.warn('SCORE OVERFLOW RISK:', health.score);
                gameState.score = 999999; // Cap score
            }
        }

        // Three.js setup
        let scene, camera, renderer, player, track, obstacles = [];
        const LANE_POSITIONS = [-2, 0, 2];
        
        // Environment object tracking for parallax movement
        let environmentObjects = {
            buildings: [],
            streetLamps: [],
            trafficSigns: [],
            streetLines: [],
            sidewalks: []
        };
        
        // Smooth speed system
        let visualSpeed = 0.08;
        let lastFrameTime = 0;
        const SPEED_LERP_FACTOR = 0.05;

        function init() {
            console.log('Initializing Three.js scene...');
            try {
                // Enhanced Scene
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x101020, 0.025); // Better fog

            // Camera (Subway Surfers perspective)
            camera = new THREE.PerspectiveCamera(60, 4/3, 0.1, 1000);
            camera.position.set(0, 3, 8);

            // Enhanced Renderer (SAFE improvements only)
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setClearColor(0x0a0a0f); // Darker background
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // Removed tone mapping - can cause issues

            // Better lighting (SAFE)
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x4040aa, 0.3);
            scene.add(ambientLight);
            
            // Hemisphere light for natural look
            const hemisphereLight = new THREE.HemisphereLight(0x8888ff, 0x444488, 0.5);
            hemisphereLight.position.set(0, 50, 0);
            scene.add(hemisphereLight);

            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFE4B5, 1.2);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);

            // Atmospheric sky light for gradient
            const skyHemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.6);
            scene.add(skyHemisphereLight);

            // Rim lighting for urban atmosphere
            const rimLight = new THREE.DirectionalLight(0x4A90E2, 0.3);
            rimLight.position.set(-5, 8, -10);
            scene.add(rimLight);

            // Enhance renderer for better visuals
            // Removed tone mapping - can cause issues
            // Removed outputColorSpace - can cause issues

            // Create player
            createPlayer();
            
            // Create track
            createTrack();
            
            // Create environment
            createEnvironment();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
                // Start render loop
                animate();
                console.log('Three.js initialization complete');
            } catch (error) {
                console.error('Error initializing Three.js:', error);
            }
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            // Player body (torso) - Enhanced but SAFE
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A90E2,
                emissive: 0x2A5090,
                emissiveIntensity: 0.2,
                shininess: 50
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.7;
            body.castShadow = true;
            body.receiveShadow = true;
            playerGroup.add(body);
            
            // Simple glow effect
            const glowGeometry = new THREE.BoxGeometry(0.65, 0.85, 0.35);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x6AB0FF,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(body.position);
            playerGroup.add(glow);

            // Player head - Better looking
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xF5B041,
                emissive: 0xF5B041,
                emissiveIntensity: 0.1,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.35;
            head.castShadow = true;
            playerGroup.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.4, 0.2);
            playerGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.4, 0.2);
            playerGroup.add(rightEye);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xF5B041 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            playerGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2C3E50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.0, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.0, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            // Cool Sneakers
            const shoeGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
            const shoeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a1a,
                shininess: 80
            });
            
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.15, -0.35, 0.1);
            leftShoe.castShadow = true;
            playerGroup.add(leftShoe);
            
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.15, -0.35, 0.1);
            rightShoe.castShadow = true;
            playerGroup.add(rightShoe);
            
            // Shoe stripes (simple glow effect)
            const stripeGeometry = new THREE.BoxGeometry(0.22, 0.02, 0.42);
            const stripeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00FF00
                // emissive not supported in MeshBasicMaterial
            });
            
            const leftStripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            leftStripe.position.set(-0.15, -0.32, 0.1);
            playerGroup.add(leftStripe);
            
            const rightStripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            rightStripe.position.set(0.15, -0.32, 0.1);
            playerGroup.add(rightStripe);

            // Backpack
            const backpackGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
            const backpackMaterial = new THREE.MeshLambertMaterial({ color: 0xE74C3C });
            const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.7, -0.25);
            backpack.castShadow = true;
            playerGroup.add(backpack);

            // Cap
            const capGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1);
            const capMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.55;
            cap.castShadow = true;
            playerGroup.add(cap);

            // Cap visor
            const visorGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.02);
            const visorMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 1.48, 0.2);
            visor.rotation.x = -0.3;
            visor.castShadow = true;
            playerGroup.add(visor);

            playerGroup.position.set(LANE_POSITIONS[gameState.playerLane], 0, 0);
            
            // FIX: Player should look forward (negative Z direction)
            playerGroup.rotation.y = Math.PI;
            
            scene.add(playerGroup);
            player = playerGroup;
        }

        function createTrack() {
            const trackGroup = new THREE.Group();
            
            // Create track segments
            for (let i = 0; i < 10; i++) {
                const segmentGroup = new THREE.Group();
                segmentGroup.position.z = -i * 10;
                
                // Main track
                const trackGeometry = new THREE.BoxGeometry(8, 0.1, 10);
                const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.receiveShadow = true;
                segmentGroup.add(trackMesh);
                
                // Lane dividers
                const dividerGeometry = new THREE.BoxGeometry(0.1, 0.05, 10);
                const dividerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
                
                const leftDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                leftDivider.position.x = -1;
                segmentGroup.add(leftDivider);
                
                const rightDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                rightDivider.position.x = 1;
                segmentGroup.add(rightDivider);
                
                trackGroup.add(segmentGroup);
            }
            
            scene.add(trackGroup);
            track = trackGroup;
        }

        function createEnvironment() {
            // Urban ground with asphalt texture
            const groundGeometry = new THREE.PlaneGeometry(80, 120);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(0, -1, -30);
            ground.receiveShadow = true;
            scene.add(ground);

            // Sidewalks
            const sidewalkGeometry = new THREE.PlaneGeometry(8, 120);
            const sidewalkMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x999999
            });
            
            const leftSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            leftSidewalk.rotation.x = -Math.PI / 2;
            leftSidewalk.position.set(-10, -0.98, -30);
            leftSidewalk.receiveShadow = true;
            leftSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(leftSidewalk);
            environmentObjects.sidewalks.push(leftSidewalk);
            
            const rightSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            rightSidewalk.rotation.x = -Math.PI / 2;
            rightSidewalk.position.set(10, -0.98, -30);
            rightSidewalk.receiveShadow = true;
            rightSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(rightSidewalk);
            environmentObjects.sidewalks.push(rightSidewalk);

            // Street lines
            for (let i = 0; i < 20; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.3, 2);
                const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const streetLine = new THREE.Mesh(lineGeometry, lineMaterial);
                streetLine.rotation.x = -Math.PI / 2;
                streetLine.position.set(0, -0.95, -i * 6);
                streetLine.userData = { 
                    type: 'streetLine', 
                    initialZ: -i * 6,
                    parallaxSpeed: 0.95 // 95% of game speed (close to track)
                };
                scene.add(streetLine);
                environmentObjects.streetLines.push(streetLine);
            }

            // Realistic city buildings
            for (let i = 0; i < 15; i++) {
                createRealisticBuilding(-15 - Math.random() * 8, -i * 8 - Math.random() * 4, 'left');
                createRealisticBuilding(15 + Math.random() * 8, -i * 8 - Math.random() * 4, 'right');
            }

            // Street lamps
            for (let i = 0; i < 12; i++) {
                createStreetLamp(-6, -i * 10);
                createStreetLamp(6, -i * 10);
            }

            // Traffic signs and urban details
            for (let i = 0; i < 8; i++) {
                if (Math.random() > 0.5) {
                    createTrafficSign(-7, -i * 12 - 5);
                    createTrafficSign(7, -i * 12 - 5);
                }
            }
        }

        function createRealisticBuilding(x, z, side) {
            const buildingGroup = new THREE.Group();
            
            // Building dimensions
            const width = 4 + Math.random() * 3;
            const depth = 4 + Math.random() * 3;
            const height = 8 + Math.random() * 12;
            
            // Main building structure
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create building materials with windows
            const buildingMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.2, 0.3 + Math.random() * 0.4)
            });
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2 - 1; // Ground level
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows
            const windowsPerFloor = Math.floor(width / 1.5);
            const floors = Math.floor(height / 3);
            
            for (let floor = 0; floor < floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    // Window facing the street
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const isLit = Math.random() > 0.4;
                    const windowMaterial = new THREE.MeshLambertMaterial({ 
                        color: isLit ? 0xFFFF88 : 0x222244,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    const windowX = -width/2 + 0.7 + w * 1.5;
                    const windowY = floor * 3 + 1.5;
                    const windowZ = side === 'left' ? depth/2 + 0.01 : -depth/2 - 0.01;
                    
                    window.position.set(windowX, windowY, windowZ);
                    if (side === 'right') window.rotation.y = Math.PI;
                    
                    buildingGroup.add(window);
                }
            }

            // Rooftop details
            if (Math.random() > 0.6) {
                // Air conditioning units
                const acGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const acMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const ac = new THREE.Mesh(acGeometry, acMaterial);
                ac.position.set(0, height/2 + 0.25, 0);
                ac.castShadow = true;
                buildingGroup.add(ac);
            }

            if (Math.random() > 0.7) {
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0, height/2 + 1, 0);
                buildingGroup.add(antenna);
            }

            buildingGroup.position.set(x, 0, z);
            buildingGroup.userData = { 
                type: 'building', 
                initialZ: z,
                parallaxSpeed: 0.7 + Math.random() * 0.2 // 70-90% of game speed
            };
            scene.add(buildingGroup);
            environmentObjects.buildings.push(buildingGroup);
        }

        function createStreetLamp(x, z) {
            const lampGroup = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1;
            pole.castShadow = true;
            lampGroup.add(pole);
            
            // Light fixture
            const lightGeometry = new THREE.SphereGeometry(0.3);
            const lightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFF88,
                emissive: 0x444400
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = 3;
            lampGroup.add(light);
            
            // Add point light
            const pointLight = new THREE.PointLight(0xFFFF88, 0.5, 10);
            pointLight.position.y = 3;
            lampGroup.add(pointLight);
            
            lampGroup.position.set(x, 0, z);
            lampGroup.userData = { 
                type: 'streetLamp', 
                initialZ: z,
                parallaxSpeed: 0.85 // 85% of game speed
            };
            scene.add(lampGroup);
            environmentObjects.streetLamps.push(lampGroup);
        }

        function createTrafficSign(x, z) {
            const signGroup = new THREE.Group();
            
            // Sign post
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.25;
            signGroup.add(post);
            
            // Sign board
            const signGeometry = new THREE.PlaneGeometry(1, 1);
            const signMaterial = new THREE.MeshLambertMaterial({ 
                color: Math.random() > 0.5 ? 0xFF4444 : 0x4444FF
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.y = 2;
            sign.rotation.y = x < 0 ? Math.PI/4 : -Math.PI/4;
            signGroup.add(sign);
            
            signGroup.position.set(x, 0, z);
            signGroup.userData = { 
                type: 'trafficSign', 
                initialZ: z,
                parallaxSpeed: 0.8 // 80% of game speed
            };
            scene.add(signGroup);
            environmentObjects.trafficSigns.push(signGroup);
        }

        function createObstacle(type, lane, z) {
            // STABILITY: Limit max obstacles
            if (obstacles.length >= LIMITS.MAX_OBSTACLES) {
                // Remove oldest obstacle
                const oldest = obstacles.shift();
                if (oldest && oldest.mesh) {
                    scene.remove(oldest.mesh);
                }
            }
            
            const obstacleGroup = new THREE.Group();
            obstacleGroup.position.set(LANE_POSITIONS[lane], 0, z);
            
            let obstacleGeometry, obstacleMaterial, height;
            
            switch (type) {
                case 'lowbarrier':
                    // Niedrige Barriere - muss übersprungen werden
                    obstacleGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35
                    });
                    height = 0.8;
                    break;
                case 'highbarrier':
                    // Hohe Barriere - muss unterduckt werden
                    obstacleGeometry = new THREE.BoxGeometry(1.8, 0.4, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B0000
                    });
                    height = 0.4;
                    break;
                case 'spikes':
                    // Stacheln - überspringen oder ducken
                    obstacleGeometry = new THREE.ConeGeometry(0.25, 0.6, 6);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF4500,
                        emissive: 0x221100
                    });
                    height = 0.6;
                    break;
                case 'jumpblock':
                    // Block zum Überspringen - Concrete texture
                    obstacleGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B8B8B
                    });
                    height = 1.2;
                    // Add concrete details
                    const detailGeom = new THREE.BoxGeometry(0.1, 0.1, 1.3);
                    const detailMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    for (let i = 0; i < 4; i++) {
                        const detail = new THREE.Mesh(detailGeom, detailMat);
                        detail.position.set(
                            (i % 2 - 0.5) * 1.2, 
                            (Math.floor(i / 2) - 0.5) * 1.2, 
                            0
                        );
                        detail.castShadow = true;
                        obstacleGroup.add(detail);
                    }
                    break;
                case 'duckbeam':
                    // Balken zum Unterducken - Metal beam
                    obstacleGeometry = new THREE.BoxGeometry(2.2, 0.3, 0.8);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x4682B4
                    });
                    height = 0.3;
                    // Add support struts
                    const strutGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.8);
                    const strutMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
                    for (let i = 0; i < 2; i++) {
                        const strut = new THREE.Mesh(strutGeom, strutMat);
                        strut.position.set((i - 0.5) * 1.5, -0.75, 0);
                        strut.castShadow = true;
                        obstacleGroup.add(strut);
                    }
                    break;
                case 'hurdleset':
                    // Hürden-Set - mehrere niedrige Hürden
                    for (let i = 0; i < 3; i++) {
                        const hurdleGeometry = new THREE.BoxGeometry(1.4, 0.7, 0.2);
                        const hurdleMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22
                        });
                        const hurdle = new THREE.Mesh(hurdleGeometry, hurdleMaterial);
                        hurdle.position.set(0, 0.35, -0.5 + i * 0.5);
                        hurdle.castShadow = true;
                        hurdle.receiveShadow = true;
                        obstacleGroup.add(hurdle);
                        
                        // Add warning stripes
                        const stripeGeom = new THREE.PlaneGeometry(1.5, 0.1);
                        const stripeMat = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00,
                            transparent: true,
                            opacity: 0.8
                        });
                        const stripe = new THREE.Mesh(stripeGeom, stripeMat);
                        stripe.position.set(0, 0.6, -0.5 + i * 0.5 + 0.11);
                        obstacleGroup.add(stripe);
                    }
                    height = 0.7;
                    break;
                case 'wallgap':
                    // Wand mit Lücke zum Ducken - Industrial wall
                    const wallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090
                    });
                    
                    const wallLeft = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallLeft.position.set(-0.5, 1.25, 0);
                    wallLeft.castShadow = true;
                    wallLeft.receiveShadow = true;
                    obstacleGroup.add(wallLeft);
                    
                    const wallRight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallRight.position.set(0.5, 1.25, 0);
                    wallRight.castShadow = true;
                    wallRight.receiveShadow = true;
                    obstacleGroup.add(wallRight);
                    
                    const wallTop = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.8, 0.4),
                        wallMaterial
                    );
                    wallTop.position.set(0, 2.1, 0);
                    wallTop.castShadow = true;
                    wallTop.receiveShadow = true;
                    obstacleGroup.add(wallTop);
                    
                    // Add hazard warning lights
                    const lightGeom = new THREE.SphereGeometry(0.08);
                    const lightMat = new THREE.MeshLambertMaterial({ 
                        color: 0xFF0000,
                        emissive: 0x440000
                    });
                    const warningLight = new THREE.Mesh(lightGeom, lightMat);
                    warningLight.position.set(0, 1.3, 0.25);
                    obstacleGroup.add(warningLight);
                    
                    height = 1.3; // Höhe der Lücke
                    break;
                    
                case 'rotatingblade':
                    // NEW: Rotating blade obstacle
                    const bladeGroup = new THREE.Group();
                    
                    // Central hub
                    const hubGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4);
                    const hubMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                    hub.position.y = 1;
                    bladeGroup.add(hub);
                    
                    // Rotating blades
                    for (let i = 0; i < 3; i++) {
                        const bladeGeometry = new THREE.BoxGeometry(2, 0.1, 0.2);
                        const bladeMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B0000,
                            emissive: 0x220000
                        });
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.y = 1;
                        blade.rotation.y = (i * Math.PI * 2) / 3;
                        blade.castShadow = true;
                        bladeGroup.add(blade);
                    }
                    
                    // Add warning lights
                    for (let j = 0; j < 2; j++) {
                        const warnLight = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06),
                            new THREE.MeshLambertMaterial({ 
                                color: 0xFF0000,
                                emissive: 0x330000
                            })
                        );
                        warnLight.position.set(j === 0 ? -1.2 : 1.2, 1.5, 0);
                        bladeGroup.add(warnLight);
                    }
                    
                    obstacleGroup.add(bladeGroup);
                    height = 2;
                    break;
                    
                case 'swinginghammer':
                    // NEW: Swinging hammer obstacle
                    const hammerGroup = new THREE.Group();
                    
                    // Support structure
                    const supportGeometry = new THREE.BoxGeometry(0.2, 3, 0.2);
                    const supportMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const support = new THREE.Mesh(supportGeometry, supportMaterial);
                    support.position.y = 1.5;
                    support.castShadow = true;
                    hammerGroup.add(support);
                    
                    // Swinging arm
                    const armGroup = new THREE.Group();
                    const armGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.y = -0.75;
                    arm.castShadow = true;
                    armGroup.add(arm);
                    
                    // Hammer head
                    const hammerGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
                    const hammerMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hammerHead = new THREE.Mesh(hammerGeometry, hammerMaterial);
                    hammerHead.position.y = -1.4;
                    hammerHead.castShadow = true;
                    armGroup.add(hammerHead);
                    
                    armGroup.position.y = 3;
                    hammerGroup.add(armGroup);
                    obstacleGroup.add(hammerGroup);
                    height = 1.8;
                    break;
                    
                case 'movingwall':
                    // NEW: Side-to-side moving wall
                    const movingWallGeometry = new THREE.BoxGeometry(0.3, 2, 1);
                    const movingWallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090,
                        transparent: true,
                        opacity: 0.9
                    });
                    const movingWall = new THREE.Mesh(movingWallGeometry, movingWallMaterial);
                    movingWall.position.y = 1;
                    movingWall.castShadow = true;
                    
                    // Add warning stripes
                    for (let k = 0; k < 4; k++) {
                        const stripeGeometry = new THREE.PlaneGeometry(0.35, 0.2);
                        const stripeMaterial = new THREE.MeshLambertMaterial({ 
                            color: k % 2 === 0 ? 0xFFFF00 : 0xFF0000
                        });
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.set(0.16, 0.5 + k * 0.4, 0);
                        movingWall.add(stripe);
                    }
                    
                    obstacleGroup.add(movingWall);
                    height = 2;
                    break;
                    
                case 'bouncingball':
                    // NEW: Bouncing ball obstacle - bounces up and down
                    const ballGroup = new THREE.Group();
                    
                    // Main bouncing ball
                    const ballGeometry = new THREE.SphereGeometry(0.6);
                    const ballMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35,
                        emissive: 0x331100
                    });
                    const bouncingBall = new THREE.Mesh(ballGeometry, ballMaterial);
                    bouncingBall.position.y = 1.5; // Starting height
                    bouncingBall.castShadow = true;
                    ballGroup.add(bouncingBall);
                    
                    // Shadow indicator on ground
                    const shadowGeometry = new THREE.CircleGeometry(0.4);
                    const shadowMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.3
                    });
                    const ballShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
                    ballShadow.rotation.x = -Math.PI / 2;
                    ballShadow.position.y = 0.01; // Just above ground
                    ballGroup.add(ballShadow);
                    
                    // Warning ring around bounce area
                    const ringGeometry = new THREE.RingGeometry(0.8, 1.0);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 0.6
                    });
                    const warningRing = new THREE.Mesh(ringGeometry, ringMaterial);
                    warningRing.rotation.x = -Math.PI / 2;
                    warningRing.position.y = 0.02;
                    ballGroup.add(warningRing);
                    
                    obstacleGroup.add(ballGroup);
                    height = 3; // Max bounce height
                    break;
                    
                case 'spinninglaser':
                    // NEW: Spinning laser beam obstacle
                    const laserGroup = new THREE.Group();
                    
                    // Central hub
                    const laserHubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6);
                    const laserHubMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x333333,
                        emissive: 0x110011
                    });
                    const laserHub = new THREE.Mesh(laserHubGeometry, laserHubMaterial);
                    laserHub.position.y = 1.2;
                    laserHub.castShadow = true;
                    laserGroup.add(laserHub);
                    
                    // Spinning laser beam (multiple segments for effect)
                    const laserBeamGroup = new THREE.Group();
                    for (let i = 0; i < 2; i++) {
                        const beamGeometry = new THREE.BoxGeometry(3, 0.1, 0.1);
                        const beamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0044,
                            emissive: 0x660022,
                            transparent: true,
                            opacity: 0.8
                        });
                        const laserBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                        laserBeam.position.y = 1.2;
                        laserBeam.rotation.y = i * Math.PI; // 180 degrees apart
                        laserBeam.castShadow = true;
                        laserBeamGroup.add(laserBeam);
                        
                        // Add glowing effect with smaller inner beam
                        const innerBeamGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
                        const innerBeamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFFFF,
                            emissive: 0xFF0044
                        });
                        const innerBeam = new THREE.Mesh(innerBeamGeometry, innerBeamMaterial);
                        innerBeam.position.copy(laserBeam.position);
                        innerBeam.rotation.copy(laserBeam.rotation);
                        laserBeamGroup.add(innerBeam);
                    }
                    
                    laserGroup.add(laserBeamGroup);
                    
                    // Warning lights at corners
                    for (let j = 0; j < 4; j++) {
                        const angle = (j * Math.PI) / 2;
                        const lightGeometry = new THREE.SphereGeometry(0.08);
                        const lightMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0000,
                            emissive: 0x440000
                        });
                        const warningLight = new THREE.Mesh(lightGeometry, lightMaterial);
                        warningLight.position.set(
                            Math.cos(angle) * 1.8,
                            0.2,
                            Math.sin(angle) * 1.8
                        );
                        laserGroup.add(warningLight);
                    }
                    
                    obstacleGroup.add(laserGroup);
                    height = 1.4; // Laser height
                    break;
            }
            
            // Für einfache Hindernisse (nicht die komplexen oder neuen Typen)
            if (type !== 'hurdleset' && type !== 'wallgap' && 
                type !== 'rotatingblade' && type !== 'swinginghammer' && type !== 'movingwall' &&
                type !== 'bouncingball' && type !== 'spinninglaser') {
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.castShadow = true;
                
                if (type === 'spikes') {
                    obstacle.position.y = height / 2;
                } else if (type === 'duckbeam') {
                    obstacle.position.y = 1.4; // Optimale Höhe für Ducken (aus git history)
                } else if (type === 'highbarrier') {
                    obstacle.position.y = 1.4; // Optimale Höhe für Ducken (aus git history)
                } else {
                    obstacle.position.y = height / 2;
                }
                
                obstacleGroup.add(obstacle);
            }
            
            scene.add(obstacleGroup);
            
            // Enhanced obstacle data with animation properties
            const obstacleData = {
                mesh: obstacleGroup,
                type: type,
                lane: lane,
                z: z,
                height: height,
                animationTime: 0,
                rotationSpeed: 0,
                swingAmplitude: 0,
                swingSpeed: 0,
                movementRange: 0,
                movementSpeed: 0,
                initialX: LANE_POSITIONS[lane]
            };
            
            // Set animation properties for moving obstacles
            switch (type) {
                case 'rotatingblade':
                    obstacleData.rotationSpeed = 3 + Math.random() * 2; // Random rotation speed
                    break;
                case 'swinginghammer':
                    obstacleData.swingAmplitude = Math.PI / 3; // 60 degree swing
                    obstacleData.swingSpeed = 2 + Math.random(); // Random swing speed
                    break;
                case 'movingwall':
                    obstacleData.movementRange = 3; // Movement range across lanes
                    obstacleData.movementSpeed = 1.5 + Math.random() * 0.5;
                    break;
                case 'bouncingball':
                    obstacleData.bounceHeight = 2.5; // Max bounce height
                    obstacleData.bounceSpeed = 3 + Math.random() * 1.5; // Bounce frequency
                    break;
                case 'spinninglaser':
                    obstacleData.rotationSpeed = 2 + Math.random() * 1.5; // Laser spin speed
                    obstacleData.pulseSpeed = 4; // Warning light pulse
                    break;
            }
            
            obstacles.push(obstacleData);
        }

        // Create Apple collectible (red fruit) - DISTINCT from spikes!
        function createApple(lane, z) {
            const appleGroup = new THREE.Group();
            
            // Apple body - DISTINCTIVE APPLE SHAPE
            const appleGeometry = new THREE.SphereGeometry(0.35, 12, 12);
            // Scale to create apple shape: wider at top, narrower at bottom
            appleGeometry.scale(1.1, 1.2, 1.1);
            
            // Apply custom apple shape by modifying vertices
            const positions = appleGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i);
                const x = positions.getX(i);
                const z = positions.getZ(i);
                
                // Create apple indentation at top
                if (y > 0.3) {
                    const indent = 1 - (y - 0.3) * 0.3;
                    positions.setX(i, x * indent);
                    positions.setZ(i, z * indent);
                }
                
                // Create apple bottom curve
                if (y < -0.2) {
                    const curve = 1 - Math.abs(y + 0.2) * 0.5;
                    positions.setX(i, x * curve);
                    positions.setZ(i, z * curve);
                }
            }
            appleGeometry.attributes.position.needsUpdate = true;
            
            // Bright red apple material - very different from orange spikes
            const appleMaterial = new THREE.MeshLambertMaterial({
                color: 0xFF0000,      // Pure red (not orange like spikes!)
                emissive: 0x660000,   // Dark red glow
                emissiveIntensity: 0.2
            });
            
            const apple = new THREE.Mesh(appleGeometry, appleMaterial);
            apple.position.y = 0.6;
            apple.castShadow = true;
            appleGroup.add(apple);
            
            // Thicker brown stem for visibility
            const stemGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.2, 6);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 1.05;
            appleGroup.add(stem);
            
            // Larger green leaf - more visible
            const leafGeometry = new THREE.PlaneGeometry(0.2, 0.12);
            const leafMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22,
                side: THREE.DoubleSide
            });
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.set(0.08, 1.0, 0);
            leaf.rotation.z = Math.PI / 4;
            appleGroup.add(leaf);
            
            appleGroup.position.set(LANE_POSITIONS[lane], 0, z);
            appleGroup.userData = { type: 'apple', lane: lane };
            scene.add(appleGroup);
            
            return appleGroup;
        }

        // Create Broccoli collectible (green vegetable)
        function createBroccoli(lane, z) {
            const broccoliGroup = new THREE.Group();
            
            // Green stem
            const stemGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.6, 6);
            const stemMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A7C4E  // Medium green
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.3;
            stem.castShadow = true;
            broccoliGroup.add(stem);
            
            // Floret cluster (simplified for performance)
            const floretGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const floretMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2D5016,      // Dark green
                flatShading: true     // For vegetable look
            });
            const florets = new THREE.Mesh(floretGeometry, floretMaterial);
            florets.position.y = 0.7;
            florets.scale.set(1.2, 0.8, 1.2); // Flatter top
            florets.castShadow = true;
            broccoliGroup.add(florets);
            
            broccoliGroup.position.set(LANE_POSITIONS[lane], 0, z);
            broccoliGroup.userData = { type: 'broccoli', lane: lane };
            scene.add(broccoliGroup);
            
            return broccoliGroup;
        }

        // Check if lane is safe for spawning collectibles - IMPROVED
        function isLaneSafeForCollectible(lane, z) {
            const MIN_DISTANCE = 50; // Increased from 30 for fair gameplay
            
            for (const obstacle of obstacles) {
                if (obstacle.lane === lane) {
                    const distance = obstacle.mesh.position.z - z;
                    
                    // Check BOTH directions to prevent unfair placement
                    if (distance > 0 && distance < MIN_DISTANCE) {
                        // Obstacle is IN FRONT of collectible
                        return false;
                    }
                    if (distance < 0 && Math.abs(distance) < MIN_DISTANCE) {
                        // Obstacle is BEHIND collectible  
                        return false;
                    }
                }
                
                // Also check adjacent lanes for wide obstacles
                if (Math.abs(obstacle.lane - lane) === 1) {
                    const wideObstacles = ['wallgap', 'hurdleset', 'movingwall'];
                    if (wideObstacles.includes(obstacle.type)) {
                        const distance = Math.abs(obstacle.mesh.position.z - z);
                        if (distance < MIN_DISTANCE * 0.7) {
                            return false; // Wide obstacle nearby
                        }
                    }
                }
            }
            return true;
        }

        // Spawn collectible with improved interval and placement
        function spawnCollectible() {
            const currentTime = performance.now();
            const timeSinceLastSpawn = currentTime - gameState.lastCollectibleTime;
            
            // Only spawn if interval has passed and under limit
            if (timeSinceLastSpawn >= gameState.collectibleInterval && 
                gameState.activeCollectibles.length < gameState.maxActiveCollectibles) {
                
                // Random lane
                let lane = Math.floor(Math.random() * 3);
                // Varied spawn distance for more natural placement
                const spawnZ = -50 - Math.random() * 20; // Between -50 and -70
                
                if (!isLaneSafeForCollectible(lane, spawnZ)) {
                    // Try different lane if first is blocked
                    const altLane = (lane + 1 + Math.floor(Math.random() * 2)) % 3;
                    if (!isLaneSafeForCollectible(altLane, spawnZ)) {
                        return; // Skip this spawn if no safe lane
                    } else {
                        // Use alternative lane
                        lane = altLane;
                    }
                }
                
                // 70% Apple, 30% Broccoli
                const isApple = Math.random() < 0.7;
                const collectible = isApple ? 
                    createApple(lane, spawnZ) : 
                    createBroccoli(lane, spawnZ);
                
                gameState.activeCollectibles.push({
                    mesh: collectible,
                    type: isApple ? 'apple' : 'broccoli',
                    lane: lane
                });
                
                gameState.lastCollectibleTime = currentTime;
            }
        }

        async function startGameInternal() {
            // Resume audio context (will initialize on first call)
            // FIXED: Check if audioManager exists before using it
            if (typeof audioManager !== 'undefined' && audioManager) {
                await audioManager.resume();
            }
            
            // Start ambient city sounds
            if (!ambientStarted) {
                if (typeof audioManager !== 'undefined' && audioManager) {
                    audioManager.play('ambient');
                }
                ambientStarted = true;
            }
            
            gameState.isPlaying = true;
            gameState.isGameOver = false;
            gameState.isVictory = false;
            gameState.score = 0;
            gameState.lives = 3;
            gameState.timeRemaining = gameState.gameTime;
            gameState.gameStartTime = Date.now();
            gameState.playerLane = 1;
            gameState.playerAction = 'running';
            gameState.playerY = 0;
            
            // Reset round system
            gameState.currentRound = 1;
            gameState.roundStartTime = Date.now();
            gameState.roundTransition = false;
            
            // Set Round 1 speed parameters
            setRoundSpeedParameters(1);
            
            // Apply Round 1 visual effects
            applyRoundVisualEffects(1);
            
            // Show highscore panel for first 5 seconds
            showHighscorePanelTemporarily();
            
            // Load Level 1
            currentLevel = 1;
            LevelManager.loadLevel(1);
            gameState.jumpVelocity = 0;
            gameState.jumpStartTime = 0; // Reset jump timer
            gameState.jumpCount = 0; // Reset jump counter
            gameState.aerialCombo = 0; // Reset aerial combo
            gameState.invulnerable = false;
            gameState.invulnerabilityTime = 0;
            gameState.timeScale = 1.0;
            gameState.cameraShakeIntensity = 0;
            gameState.slowMotionActive = false;
            
            // Reset collectibles
            gameState.lastCollectibleTime = 0;
            gameState.collectedApples = 0;
            gameState.collectedBroccolis = 0;
            gameState.activeCollectibles.forEach(c => scene.remove(c.mesh));
            gameState.activeCollectibles = [];
            
            // Clear obstacles
            obstacles.forEach(obs => scene.remove(obs.mesh));
            obstacles = [];
            
            // Start sound
            if (typeof audioManager !== 'undefined' && audioManager) {
                audioManager.play('powerup');
            }
            
            document.getElementById('menu').style.display = 'none';
            updateUI();
        }

        function endGame() {
            // Prevent multiple game over calls
            if (gameState.isGameOver) {
                console.log('Game over already triggered, skipping');
                return;
            }
            
            // Hide highscore panel when game ends
            hideHighscorePanel();
            
            // Clear any pending timeout
            if (highscorePanelTimeout) {
                clearTimeout(highscorePanelTimeout);
                highscorePanelTimeout = null;
            }
            
            gameState.isPlaying = false;
            gameState.isGameOver = true;
            
            // Stop ambient sounds
            if (typeof audioManager !== 'undefined' && audioManager) {
                audioManager.stopAmbient();
            }
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = Math.max(0, gameState.gameTime - Math.ceil(gameState.timeRemaining));
            
            // TEMPORARILY SKIP HIGHSCORE CHECK TO PREVENT CRASHES
            // if (highscoreManager.isHighscore(currentScore)) {
            //     showNameInputDialog(false);
            // } else {
            showGameOverMenu(false);
            // }
        }

        function victoryGame() {
            // Prevent multiple victory calls
            if (gameState.roundTransition) {
                console.log('Round transition already in progress');
                return;
            }
            
            // Check if this was the final round
            if (gameState.currentRound >= 3) {
                // FINAL VICTORY - All 3 rounds completed!
                gameState.isPlaying = false;
                gameState.isVictory = true;
                
                // Stop ambient sounds
                if (typeof audioManager !== 'undefined' && audioManager) {
                audioManager.stopAmbient();
            }
                ambientStarted = false;
                
                currentScore = gameState.score;
                currentSurvivalTime = 180; // Full 180 seconds survived!
                
                // Epic victory celebration!
                if (typeof audioManager !== 'undefined' && audioManager) {
                audioManager.play('powerup');
            }
                
                // Massive fireworks effect
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        createParticleEffect(
                            new THREE.Vector3((Math.random() - 0.5) * 15, 5 + Math.random() * 5, -5),
                            [0xFF6B35, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFEDE57, 0xFF1493, 0x00FF00][i % 7],
                            'success'
                        );
                    }, i * 200);
                }
                
                // SIMPLIFIED: Direct to game over menu
                currentScore = gameState.score;
                currentSurvivalTime = 180;
                showGameOverMenu(true); // true = victory
            } else {
                // Round completed - transition to next round
                startRoundTransition();
            }
        }
        
        // New round transition function
        function startRoundTransition() {
            console.log(`🎯 Round ${gameState.currentRound} completed, transitioning to Round ${gameState.currentRound + 1}`);
            
            gameState.roundTransition = true;
            gameState.roundTransitionStartTime = Date.now(); // FIX: Consistent time API
            gameState.isPlaying = false;
            
            // Pause all game elements
            obstacles.forEach(o => o.paused = true);
            gameState.activeCollectibles.forEach(c => c.paused = true);
            
            const overlay = document.getElementById('roundTransitionOverlay');
            const title = document.getElementById('transitionTitle');
            const subtitle = document.getElementById('transitionSubtitle');
            const countdown = document.getElementById('transitionCountdown');
            
            // Show round completed message
            title.textContent = `DURCHGANG ${gameState.currentRound} GESCHAFFT! 🎉`;
            subtitle.textContent = `Bereite dich auf DURCHGANG ${gameState.currentRound + 1} vor...`;
            
            // Apply round-specific colors
            if (gameState.currentRound === 1) {
                // Transition to Round 2 - Orange theme
                title.style.color = '#FFA500';
                subtitle.style.color = '#FF8C00';
                overlay.style.background = 'linear-gradient(135deg, rgba(255,140,0,0.9), rgba(255,69,0,0.9))';
            } else if (gameState.currentRound === 2) {
                // Transition to Round 3 - Purple/Pink theme
                title.style.color = '#FF1493';
                subtitle.style.color = '#FF00FF';
                overlay.style.background = 'linear-gradient(135deg, rgba(138,43,226,0.9), rgba(255,20,147,0.9))';
            }
            
            // Properly show the overlay
            overlay.style.display = 'flex';
            console.log('✅ Round transition overlay shown');
            
            // Countdown animation
            let count = 3;
            countdown.textContent = count;
            
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdown.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    overlay.style.display = 'none';
                    console.log('✅ Round transition overlay hidden');
                    startNextRound();
                }
            }, 1000);
        }
        
        function startNextRound() {
            console.log(`🚀 Starting Round ${gameState.currentRound + 1}`);
            
            // Increment round
            gameState.currentRound++;
            gameState.roundStartTime = Date.now(); // FIX: Use Date.now() consistently!
            
            console.log(`✅ Now in Round ${gameState.currentRound}`);
            
            // Reset timer for new round
            gameState.timeRemaining = 60;
            gameState.gameStartTime = Date.now(); // FIX: Use Date.now() not performance.now()!
            
            // Update UI
            document.getElementById('currentRound').textContent = gameState.currentRound;
            
            // Apply round-specific visual effects
            applyRoundVisualEffects(gameState.currentRound);
            
            // Set round-specific speed parameters
            setRoundSpeedParameters(gameState.currentRound);
            
            // Resume game - ENSURE controls work
            gameState.roundTransition = false;
            gameState.isPlaying = true;
            gameState.isGameOver = false; // Make sure game over flag is clear
            console.log('✅ Round', gameState.currentRound, 'started - Controls ACTIVE');
            
            // Unpause game elements
            obstacles.forEach(o => o.paused = false);
            gameState.activeCollectibles.forEach(c => c.paused = false);
            
            // Play round start sound
            if (typeof audioManager !== 'undefined' && audioManager) {
                audioManager.play('powerup');
            }
        }
        
        function setRoundSpeedParameters(round) {
            switch(round) {
                case 1:
                    // Round 1: Normal progression (0.08 → 0.35)
                    gameState.baseSpeed = 0.08;
                    gameState.maxSpeed = 0.35;
                    break;
                case 2:
                    // Round 2: Faster start, higher max (0.28 → 0.525)
                    gameState.baseSpeed = 0.28;
                    gameState.maxSpeed = 0.525;
                    break;
                case 3:
                    // Round 3: INSANE mode (0.42 → 0.75)
                    gameState.baseSpeed = 0.42;
                    gameState.maxSpeed = 0.75;
                    break;
            }
            
            // Set current speed to base speed
            gameState.speed = gameState.baseSpeed;
        }
        
        function applyRoundVisualEffects(round) {
            const speedIndicator = document.getElementById('speedIndicator');
            const roundIndicator = document.getElementById('roundIndicator');
            
            switch(round) {
                case 1:
                    // Normal theme
                    speedIndicator.style.color = 'white';
                    roundIndicator.style.color = '#FFD700';
                    document.body.style.background = 'linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%)';
                    break;
                case 2:
                    // Heat theme - Orange/Red
                    speedIndicator.style.color = '#FFA500';
                    speedIndicator.style.textShadow = '0 0 10px rgba(255,165,0,0.8)';
                    roundIndicator.style.color = '#FF4500';
                    roundIndicator.innerHTML = '🔥 DURCHGANG <span id="currentRound">2</span>/3 - HEAT MODE';
                    document.body.style.background = 'linear-gradient(to bottom, #FF8C00 0%, #FF4500 100%)';
                    
                    // Add motion blur effect
                    renderer.domElement.style.filter = 'blur(0.5px)';
                    setTimeout(() => {
                        renderer.domElement.style.filter = 'none';
                    }, 1000);
                    break;
                case 3:
                    // Insane theme - Purple/Pink Neon
                    speedIndicator.style.color = '#FF1493';
                    speedIndicator.style.textShadow = '0 0 20px rgba(255,20,147,1)';
                    speedIndicator.style.animation = 'pulse 0.5s infinite';
                    roundIndicator.style.color = '#FF00FF';
                    roundIndicator.innerHTML = '⚡ DURCHGANG <span id="currentRound">3</span>/3 - INSANE MODE!!!';
                    document.body.style.background = 'linear-gradient(to bottom, #8A2BE2 0%, #FF1493 100%)';
                    
                    // Add chromatic aberration effect
                    renderer.domElement.style.filter = 'contrast(1.1) saturate(1.3)';
                    
                    // Add CSS animation for pulsing
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes pulse {
                            0% { transform: scale(1); }
                            50% { transform: scale(1.05); }
                            100% { transform: scale(1); }
                        }
                    `;
                    document.head.appendChild(style);
                    break;
            }
        }
        
        function showFinalVictoryDialog() {
            // Create epic victory screen
            const victoryHTML = `
                <div id="finalVictoryDialog" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                     background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,20,147,0.95)); 
                     padding: 40px; border-radius: 20px; text-align: center; z-index: 2000;
                     box-shadow: 0 0 50px rgba(255,215,0,0.8);">
                    <h1 style="font-size: 48px; color: white; text-shadow: 0 0 20px rgba(255,255,255,1); margin-bottom: 20px;">
                        🏆 LEGENDARY RUNNER! 🏆
                    </h1>
                    <div style="font-size: 24px; color: white; margin-bottom: 30px;">
                        Du hast alle 3 Durchgänge gemeistert!
                    </div>
                    <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                        <div style="color: #FFD700; font-size: 20px; margin-bottom: 10px;">📊 STATISTIK</div>
                        <div style="color: white; font-size: 18px;">
                            <div>✅ Durchgang 1: 60s</div>
                            <div>✅ Durchgang 2: 60s</div>
                            <div>✅ Durchgang 3: 60s</div>
                            <div style="margin-top: 10px; font-size: 24px; color: #FFD700;">
                                🎯 Total: 180 Sekunden überlebt!
                            </div>
                            <div style="margin-top: 5px;">Max Speed: ${Math.floor(gameState.maxSpeed * 1000)}</div>
                            <div>Score: ${gameState.score}</div>
                        </div>
                    </div>
                    <button onclick="window.proceedToHighscore()" style="padding: 15px 30px; font-size: 20px; 
                            background: linear-gradient(135deg, #FFD700, #FFA500); border: none; 
                            border-radius: 10px; color: white; cursor: pointer; font-weight: bold;
                            box-shadow: 0 5px 15px rgba(0,0,0,0.3);">
                        🎮 WEITER ZU HIGHSCORE
                    </button>
                </div>
            `;
            
            const victoryDiv = document.createElement('div');
            victoryDiv.innerHTML = victoryHTML;
            document.body.appendChild(victoryDiv);
            
            // Add function to proceed to highscore
            window.proceedToHighscore = function() {
                // Remove victory dialog
                const dialog = document.getElementById('finalVictoryDialog');
                if (dialog) dialog.remove();
                
                // TEMPORARILY SKIP HIGHSCORE TO PREVENT CRASHES
                // if (highscoreManager.isHighscore(gameState.score)) {
                //     showNameInputDialog(true); // true = victory
                // } else {
                showGameOverMenu(true); // true = victory
                // }
            };
        }

        function updateUI() {
            // Update desktop UI
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('speed').textContent = Math.floor(gameState.speed * 1000);
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('currentRound').textContent = gameState.currentRound;
            document.getElementById('apples').textContent = gameState.collectedApples;
            document.getElementById('broccolis').textContent = gameState.collectedBroccolis;
            
            // Update mobile UI
            const mobileScore = document.getElementById('mobileScore');
            const mobileSpeed = document.getElementById('mobileSpeed');
            const mobileLives = document.getElementById('mobileLives');
            const mobileApples = document.getElementById('mobileApples');
            const mobileBroccolis = document.getElementById('mobileBroccolis');
            const mobileTime = document.getElementById('mobileTime');
            
            if (mobileScore) mobileScore.textContent = gameState.score;
            if (mobileSpeed) mobileSpeed.textContent = Math.floor(gameState.speed * 1000);
            if (mobileLives) mobileLives.textContent = gameState.lives;
            if (mobileApples) mobileApples.textContent = gameState.collectedApples;
            if (mobileBroccolis) mobileBroccolis.textContent = gameState.collectedBroccolis;
            if (mobileTime) mobileTime.textContent = Math.max(0, Math.ceil(gameState.timeRemaining));
            
            // Update timer with visual warnings
            const timeElement = document.getElementById('timeRemaining');
            const timerElement = document.getElementById('timer');
            timeElement.textContent = Math.max(0, Math.ceil(gameState.timeRemaining));
            
            // Timer visual states with audio warnings
            const timeLeft = Math.ceil(gameState.timeRemaining);
            
            // Show highscore panel in last 5 seconds
            if (timeLeft <= 5 && timeLeft > 0) {
                showHighscorePanel();
            }
            
            if (timeLeft <= 10) {
                timerElement.className = 'timer-critical';
                // Final countdown beeps
                if (timeLeft <= 5 && timeLeft > 0 && Math.ceil(gameState.timeRemaining) !== Math.ceil(gameState.timeRemaining + 0.016)) {
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        audioManager.play('coin'); // High pitched beep
                    }
                }
            } else if (timeLeft <= 20) {
                timerElement.className = 'timer-warning';
                // Warning at 20 seconds
                if (timeLeft === 20 && Math.abs(gameState.timeRemaining - 20) < 0.1) {
                    audioManager.play('duck'); // Warning sound
                }
            } else {
                timerElement.className = '';
            }
        }

        function showNameInputDialog(isVictory) {
            const dialog = document.getElementById('nameInputDialog');
            const title = dialog.querySelector('h2');
            const scoreValue = document.getElementById('highscoreValue');
            
            if (isVictory) {
                title.innerHTML = '🎉 VICTORY + HIGHSCORE! 🎉';
            } else {
                title.innerHTML = '🎉 Neuer Highscore! 🎉';
            }
            
            // Display the achieved score
            if (scoreValue) {
                scoreValue.textContent = currentScore;
            }
            
            dialog.style.display = 'block';
            document.getElementById('playerNameInput').focus();
        }

        function showGameOverMenu(isVictory) {
            const menu = document.getElementById('menu');
            
            // SIMPLIFIED VERSION - No highscores, no async calls
            if (isVictory) {
                menu.innerHTML = `
                    <h1>🎉 VICTORY! 🎉</h1>
                    <h2>Du hast alle 3 Durchgänge geschafft!</h2>
                    <p style="font-size: 24px; color: #FFD700;">Final Score: ${currentScore}</p>
                    <p>Du bist ein Subway Runner Champion! 🏆</p>
                    <button onclick="startGame()" style="padding: 10px 20px; font-size: 18px;">🎮 Nochmal versuchen</button>
                `;
            } else {
                menu.innerHTML = `
                    <h1>Game Over!</h1>
                    <p style="font-size: 20px;">Final Score: <span style="color: #FFD700; font-weight: bold;">${currentScore}</span></p>
                    <p>Zeit überlebt: ${currentSurvivalTime}s</p>
                    <p>Durchgang: ${gameState.currentRound}/3</p>
                    <button onclick="startGame()" style="padding: 10px 20px; font-size: 18px;">🎮 Nochmal spielen</button>
                `;
            }
            
            menu.style.display = 'block';
        }

        async function submitHighscoreInternal() {
            const nameInput = document.getElementById('playerNameInput');
            let playerName = nameInput.value.trim();
            
            if (!playerName) {
                playerName = 'Anonymous';
            }
            
            // Disable button while submitting
            const submitBtn = document.querySelector('#nameInputDialog button');
            submitBtn.disabled = true;
            submitBtn.textContent = '💾 Speichere...';
            
            try {
                await highscoreManager.submitScore(
                    playerName, 
                    currentScore, 
                    currentSurvivalTime, 
                    gameState.isVictory
                );
                
                // Hide dialog and show game over menu
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
                
                // Clear input for next time
                nameInput.value = '';
                
            } catch (error) {
                console.error('Error submitting highscore:', error);
                // Still hide dialog and continue
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
            }
            
            // Re-enable button
            submitBtn.disabled = false;
            submitBtn.textContent = '💾 Speichern';
        }

        function skipHighscoreInternal() {
            document.getElementById('nameInputDialog').style.display = 'none';
            showGameOverMenu(gameState.isVictory);
            document.getElementById('playerNameInput').value = '';
        }

        // Handle Enter key in name input
        document.addEventListener('DOMContentLoaded', () => {
            const nameInput = document.getElementById('playerNameInput');
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitHighscoreInternal();
                }
            });
        });
        
        // Expose functions to window for HTML buttons
        window.submitHighscore = submitHighscoreInternal;
        window.skipHighscore = skipHighscoreInternal;

        function handleKeyDown(event) {
            // ULTRA FIX: Force focus to game canvas
            const canvas = document.getElementById('gameCanvas');
            if (canvas && document.activeElement !== canvas) {
                canvas.focus();
            }
            
            // FIXED: More robust check for game state
            if (!gameState.isPlaying || gameState.isGameOver || gameState.roundTransition) {
                console.warn('🚫 Controls blocked - State:', {
                    isPlaying: gameState.isPlaying,
                    isGameOver: gameState.isGameOver,
                    roundTransition: gameState.roundTransition
                });
                return;
            }
            
            // Prevent default for game keys
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD'].includes(event.code)) {
                event.preventDefault();
            }
            
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                case 'KeyQ':  // HEAD TRACKING FALLBACK
                    event.preventDefault();
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        // FIXED: Check if audioManager exists before using it
                        if (typeof audioManager !== 'undefined' && audioManager) {
                            const speedMultiplier = gameState.speed / gameState.maxSpeed;
                            audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        }
                        console.log('⌨️ Q/A/← Lane left:', gameState.playerLane);
                    }
                    break;
                case 'ArrowRight':
                case 'KeyD':
                case 'KeyE':  // HEAD TRACKING FALLBACK
                    event.preventDefault();
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        // FIXED: Check if audioManager exists before using it
                        if (typeof audioManager !== 'undefined' && audioManager) {
                            const speedMultiplier = gameState.speed / gameState.maxSpeed;
                            audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        }
                        console.log('⌨️ E/D/→ Lane right:', gameState.playerLane);
                    }
                    break;
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        // First jump
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = performance.now();
                        gameState.jumpCount = 1;
                        
                        // Audio & Visual Feedback
                        if (typeof audioManager !== 'undefined' && audioManager) {
                            const speedMultiplier = gameState.speed / gameState.maxSpeed;
                            audioManager.playSpeedDependentSound('jump', speedMultiplier);
                            if (typeof audioManager !== 'undefined' && audioManager) {
                            audioManager.resume();
                        }
                        }
                        
                        // Jump particles - color based on jump number
                        if (typeof createParticleEffect === 'function') {
                            createParticleEffect(
                                new THREE.Vector3(player.position.x, 0.1, player.position.z),
                                0xFFFF00, // Yellow for first jump
                                'jump'
                            );
                        }
                    } else if (gameState.playerAction === 'jumping' && 
                               gameState.jumpCount < gameState.maxJumps && 
                               gameState.playerY > 0.5) {
                        // Multi-jump system - up to 4 jumps
                        gameState.jumpCount++;
                        
                        // Jump force decreases with each jump
                        const jumpForce = 10 - (gameState.jumpCount - 1) * 1.5;
                        gameState.jumpVelocity = Math.max(jumpForce, 6);
                        gameState.jumpStartTime = performance.now(); // RESET timer!
                        
                        // Different particle colors for each jump level
                        const jumpColors = [0xFFFF00, 0xFF8800, 0xFF0088, 0x8800FF, 0x00FFFF];
                        const particleColor = jumpColors[Math.min(gameState.jumpCount - 1, 4)];
                        
                        // Audio pitch increases with jump count
                        if (typeof audioManager !== 'undefined' && audioManager) {
                            const speedMultiplier = gameState.speed / gameState.maxSpeed;
                            audioManager.playSpeedDependentSound('jump', speedMultiplier);
                            if (typeof audioManager !== 'undefined' && audioManager) {
                            audioManager.resume();
                        } // Resume audio context if needed
                        }
                        
                        // Sprung-Partikel
                        if (typeof createParticleEffect === 'function') {
                            createParticleEffect(
                                new THREE.Vector3(player.position.x, 0.1, player.position.z),
                                0xFFFF00,
                                'jump'
                            );
                        }
                    }
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        // FIXED: Check if audioManager exists before using it
                        if (typeof audioManager !== 'undefined' && audioManager) {
                            const speedMultiplier = gameState.speed / gameState.maxSpeed;
                            // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                    }
                        }
                    }
                    break;
            }
        }

        function handleKeyUp(event) {
            // FIXED: More robust check
            if (!gameState.isPlaying || gameState.isGameOver || gameState.roundTransition) {
                return;
            }
            
            switch (event.code) {
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    gameState.playerAction = 'running';
                    break;
            }
        }

        function createParticleEffect(position, color, type) {
            let particleCount, spreadRange, speed, size;
            
            switch (type) {
                case 'success':
                    particleCount = 25;
                    spreadRange = 3;
                    speed = 4;
                    size = 0.06;
                    break;
                case 'explosion':
                    particleCount = 40;
                    spreadRange = 5;
                    speed = 6;
                    size = 0.08;
                    break;
                case 'jump':
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.04;
                    break;
                case 'landing':
                    particleCount = 20;
                    spreadRange = 3;
                    speed = 2;
                    size = 0.05;
                    break;
                default:
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.05;
            }
            
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 6, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true
                    })
                );
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spreadRange,
                    Math.random() * speed + 0.5,
                    (Math.random() - 0.5) * spreadRange
                );
                particle.life = 1.0;
                particle.originalSize = size;
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Enhanced particle animation
            const animateParticles = () => {
                particles.children.forEach((particle, index) => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(gameState.timeScale));
                    particle.velocity.y -= 0.15 * gameState.timeScale; // Gravity
                    particle.life -= 0.015 * gameState.timeScale;
                    
                    // Fancy effects based on type
                    if (type === 'explosion') {
                        particle.material.opacity = particle.life * 0.8;
                        particle.scale.setScalar(1 + (1 - particle.life) * 2);
                        particle.rotation.x += 0.1 * gameState.timeScale;
                        particle.rotation.y += 0.1 * gameState.timeScale;
                    } else if (type === 'success') {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(1 + Math.sin(Date.now() * 0.01 + index) * 0.3);
                    } else {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(particle.life);
                    }
                    
                    if (particle.life <= 0) {
                        particles.remove(particle);
                    }
                });
                
                if (particles.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }

        function startSlowMotion(duration = 800) {
            gameState.slowMotionActive = true;
            gameState.timeScale = 0.3;
            
            // Camera zoom effect
            const originalFov = camera.fov;
            camera.fov = originalFov * 0.8;
            camera.updateProjectionMatrix();
            
            setTimeout(() => {
                gameState.slowMotionActive = false;
                gameState.timeScale = 1.0;
                camera.fov = originalFov;
                camera.updateProjectionMatrix();
            }, duration);
        }

        function screenShake(intensity = 0.1, duration = 300) {
            gameState.cameraShakeIntensity = intensity;
            
            setTimeout(() => {
                gameState.cameraShakeIntensity = 0;
            }, duration);
        }

        function cameraZoomEffect(targetZoom = 1.2, duration = 500) {
            const originalFov = camera.fov;
            const targetFov = originalFov / targetZoom;
            
            const startTime = Date.now();
            const zoomAnimation = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.5) {
                    // Zoom in
                    const zoomProgress = progress * 2;
                    camera.fov = originalFov - (originalFov - targetFov) * zoomProgress;
                } else {
                    // Zoom out
                    const zoomProgress = (progress - 0.5) * 2;
                    camera.fov = targetFov + (originalFov - targetFov) * zoomProgress;
                }
                
                camera.updateProjectionMatrix();
                
                if (progress < 1) {
                    requestAnimationFrame(zoomAnimation);
                }
            };
            zoomAnimation();
        }

        function createExplosionRing(position, color = 0xFF6644) {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            ring.position.copy(position);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            // Animate ring expansion
            const animateRing = () => {
                ring.scale.x += 0.3;
                ring.scale.y += 0.3;
                ring.material.opacity -= 0.02;
                
                if (ring.material.opacity > 0) {
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ring);
                }
            };
            animateRing();
        }

        // Enhanced collision detection with precise bounding boxes and near-miss system
        function checkCollisions() {
            if (gameState.invulnerable) return;
            
            // Player bounding box calculation
            const playerBBox = calculatePlayerBoundingBox();
            
            obstacles.forEach((obstacle, index) => {
                // Calculate obstacle bounding box
                const obstacleBBox = calculateObstacleBoundingBox(obstacle);
                
                // Check for actual collision using 3D bounding box intersection
                const isColliding = boundingBoxIntersection(playerBBox, obstacleBBox);
                
                // ENHANCED DUCK COLLISION DETECTION - V4.0 WITH SUPER JUMP
                if (obstacle.type === 'duckbeam' || obstacle.type === 'highbarrier' || obstacle.type === 'wallgap') {
                    const playerX = LANE_POSITIONS[gameState.playerLane];
                    const obstacleX = obstacle.mesh.position.x;
                    const obstacleZ = obstacle.mesh.position.z;
                    
                    // Check if player is in same lane (X axis)
                    const inSameLane = Math.abs(playerX - obstacleX) < 1.0;
                    
                    // Check if obstacle is close enough in Z direction
                    const inCollisionZone = obstacleZ > -2 && obstacleZ < 2;
                    
                    if (inSameLane && inCollisionZone) {
                        const playerHeight = gameState.playerY;
                        const safeJumpHeight = 3.0; // Can jump over duck obstacles at this height
                        
                        // V4.0: Check if player is high enough to jump over
                        if (playerHeight >= safeJumpHeight) {
                            // SUPER JUMP SUCCESS! No collision when jumping high
                            console.log(`🚀 SUPER JUMP! Cleared duck obstacle at height ${playerHeight.toFixed(1)}`);
                            
                            // Bonus points for skillful play
                            const heightBonus = Math.floor((playerHeight - safeJumpHeight) * 50);
                            addScore(200 + heightBonus);
                            gameState.aerialCombo++;
                            
                            // Show achievement
                            if (gameState.jumpCount >= 3) {
                                showScorePopup(300 + heightBonus, obstacle.mesh.position, 'SUPER JUMP!');
                            }
                            
                            // Special particle effect
                            createParticleEffect(
                                obstacle.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)),
                                0x00FFFF,
                                'success'
                            );
                            
                            // No collision - continue to next obstacle
                            return;
                        } else if (gameState.playerAction === 'ducking') {
                            // Normal ducking success - FAIR POINTS FOR DUCK!
                            console.log(`✅ DUCK SUCCESS! Player ducked properly.`);
                            
                            // Give fair points for successful duck
                            addScore(150); // Base duck points
                            showScorePopup(150, obstacle.mesh.position, 'DUCK SUCCESS!');
                            
                            // Success particle effect
                            createParticleEffect(
                                obstacle.mesh.position.clone().add(new THREE.Vector3(0, 0.5, 0)),
                                0x00FF00,
                                'success'
                            );
                            
                            // Play success sound
                            audioManager.play('success');
                            
                            // Remove obstacle since it was successfully avoided
                            scene.remove(obstacle.mesh);
                            obstacles.splice(index, 1);
                            return; // Important: Skip to next obstacle
                        } else {
                            // Collision - not ducking and not high enough
                            console.log(`💥 DUCK COLLISION! Height: ${playerHeight.toFixed(1)}, needed: ${safeJumpHeight}`);
                            handleCollision(obstacle, obstacleBBox);
                            scene.remove(obstacle.mesh);
                            obstacles.splice(index, 1);
                            return;
                        }
                    }
                }
                
                // Near-miss detection (close but not colliding)
                const nearMissDistance = 0.3; // Units for near-miss threshold
                const isNearMiss = !isColliding && boundingBoxDistance(playerBBox, obstacleBBox) < nearMissDistance;
                
                if (isColliding) {
                    // Check if player can avoid this collision
                    let canAvoid = false;
                    let avoidanceType = '';
                    
                    // Enhanced avoidance logic with precise hitbox checking
                    switch (obstacle.type) {
                        case 'lowbarrier':
                        case 'jumpblock':
                        case 'hurdleset':
                            // Must be jumped - check if player is high enough to clear
                            if (gameState.playerAction === 'jumping' && 
                                playerBBox.min.y > obstacleBBox.max.y - 0.2) {
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'highbarrier':
                        case 'duckbeam':
                        case 'wallgap':
                            // Must be ducked - check if player is low enough to pass under
                            if (gameState.playerAction === 'ducking' && 
                                playerBBox.max.y < obstacleBBox.min.y + 0.2) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else if (gameState.playerAction === 'jumping') {
                                // EXPLICITLY HANDLE: Cannot jump over duck obstacles!
                                console.warn('Cannot jump over duck obstacles - collision!');
                                canAvoid = false;
                                // Mark obstacle as hit for score tracking
                                obstacle.hitPlayer = true;
                            } else {
                                canAvoid = false;
                            }
                            break;
                            
                        case 'spikes':
                            // Flexible - can jump over or duck under
                            if ((gameState.playerAction === 'jumping' && playerBBox.min.y > obstacleBBox.max.y - 0.2) ||
                                (gameState.playerAction === 'ducking' && playerBBox.max.y < obstacleBBox.min.y + 0.2)) {
                                canAvoid = true;
                                avoidanceType = gameState.playerAction === 'jumping' ? 'jump' : 'duck';
                            }
                            break;
                            
                        case 'rotatingblade':
                            // Rotating blades - can only be ducked under
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 0.8) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'swinginghammer':
                            // Swinging hammer - timing-based avoidance
                            // Check if hammer is in safe position
                            const hammerAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                            const isSafePosition = Math.abs(hammerAngle) < obstacle.swingAmplitude * 0.3; // Safe zone
                            
                            if (isSafePosition) {
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && Math.abs(hammerAngle) > obstacle.swingAmplitude * 0.7) {
                                // Can duck under when hammer is at extreme positions
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'movingwall':
                            // Moving wall - must time movement or jump
                            const wallPosition = obstacle.mesh.position.x;
                            const playerPosition = LANE_POSITIONS[gameState.playerLane];
                            const wallDistance = Math.abs(wallPosition - playerPosition);
                            
                            if (wallDistance > 1.0) {
                                // Wall is far enough away
                                canAvoid = true;
                                avoidanceType = 'dodge';
                            } else if (gameState.playerAction === 'jumping' && playerBBox.min.y > 1.5) {
                                // Can jump over the wall
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'bouncingball':
                            // Bouncing ball - timing-based avoidance or ducking
                            const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                            
                            if (ballHeight < 0.8) {
                                // Ball is low - can run through
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && ballHeight > 1.5) {
                                // Ball is high, player is ducking
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else if (gameState.playerAction === 'jumping' && ballHeight < 1.2 && playerBBox.min.y > ballHeight + 0.3) {
                                // Ball is medium height, player jumps over
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'spinninglaser':
                            // Spinning laser - only ducking helps
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 1.1) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                    }
                    
                    if (canAvoid) {
                        // SUCCESSFUL AVOIDANCE!
                        let bonusScore = 50;
                        
                        // Precision bonus - closer calls get more points
                        const precision = 1 - (boundingBoxDistance(playerBBox, obstacleBBox) / nearMissDistance);
                        bonusScore += Math.floor(precision * 25);
                        
                        if (avoidanceType === 'jump') bonusScore += 25; // Jump bonus
                        
                        addScore(bonusScore); // SAFE SCORE UPDATE
                        
                        // Enhanced audio feedback with precision
                        if (precision > 0.8) {
                            audioManager.play('success'); // Perfect avoidance
                        } else {
                            audioManager.playSpeedDependentSound('coin', gameState.speed / gameState.maxSpeed);
                        }
                        
                        // Spectacular success particle effects
                        const effectPos = obstacle.mesh.position.clone();
                        const effectColor = avoidanceType === 'jump' ? 0x00FF00 : 0x00FFFF;
                        
                        createParticleEffect(effectPos, effectColor, 'success');
                        
                        // Precision-based additional effects
                        if (precision > 0.8) {
                            // Perfect execution - extra sparkles
                            createParticleEffect(
                                effectPos.clone().add(new THREE.Vector3(0, 1, 0)),
                                0xFFD700,
                                'success'
                            );
                            // Mini camera zoom for perfect execution
                            cameraZoomEffect(1.1, 200);
                        }
                        
                        // Score popup with precision indicator
                        showScorePopup(bonusScore, effectPos, precision > 0.8 ? 'PERFECT!' : 'NICE!');
                        
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        
                    } else {
                        // COLLISION DETECTED!
                        handleCollision(obstacle, obstacleBBox);
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                    }
                    
                } else if (isNearMiss) {
                    // NEAR MISS BONUS!
                    handleNearMiss(obstacle, playerBBox, obstacleBBox);
                }
            });
            
            // Check collectible collisions
            gameState.activeCollectibles.forEach((collectible, index) => {
                const collectibleBBox = {
                    min: new THREE.Vector3(
                        collectible.mesh.position.x - 0.5,
                        collectible.mesh.position.y - 0.5,
                        collectible.mesh.position.z - 0.5
                    ),
                    max: new THREE.Vector3(
                        collectible.mesh.position.x + 0.5,
                        collectible.mesh.position.y + 0.5,
                        collectible.mesh.position.z + 0.5
                    )
                };
                
                if (boundingBoxIntersection(playerBBox, collectibleBBox)) {
                    // Collected!
                    if (collectible.type === 'apple') {
                        gameState.collectedApples++;
                        addScore(50);
                        audioManager.play('collect');
                    } else if (collectible.type === 'broccoli') {
                        gameState.collectedBroccolis++;
                        addScore(100);
                        audioManager.play('collect');
                    }
                    
                    // Visual effect
                    createParticleEffect(
                        collectible.mesh.position.clone(),
                        collectible.type === 'apple' ? 0xFF0000 : 0x00FF00,
                        'collect'
                    );
                    
                    // Remove collectible
                    scene.remove(collectible.mesh);
                    gameState.activeCollectibles.splice(index, 1);
                }
            });
        }
        
        // Calculate precise player bounding box based on current action
        function calculatePlayerBoundingBox() {
            const playerX = LANE_POSITIONS[gameState.playerLane];
            const playerY = gameState.playerY;
            
            let width = 0.8;  // Player width
            let height = 1.5; // Player height
            let depth = 0.6;  // Player depth
            
            // Adjust hitbox based on action
            if (gameState.playerAction === 'ducking') {
                height = 0.6;
                depth = 0.8; // Slightly larger depth when ducking
            } else if (gameState.playerAction === 'jumping') {
                // Tighter hitbox when jumping for more precise collision
                width = 0.7;
                depth = 0.5;
            }
            
            return {
                min: new THREE.Vector3(
                    playerX - width/2,
                    playerY,
                    -depth/2
                ),
                max: new THREE.Vector3(
                    playerX + width/2,
                    playerY + height,
                    depth/2
                )
            };
        }
        
        // Calculate obstacle bounding box based on type and mesh
        function calculateObstacleBoundingBox(obstacle) {
            const pos = obstacle.mesh.position;
            let width, height, depth;
            
            // Obstacle-specific bounding box dimensions
            switch (obstacle.type) {
                case 'lowbarrier':
                    width = 1.5; height = 0.8; depth = 0.3;
                    break;
                case 'highbarrier':
                    width = 1.8; height = 0.4; depth = 0.3;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'jumpblock':
                    width = 1.2; height = 1.2; depth = 1.2;
                    break;
                case 'spikes':
                    width = 0.5; height = 0.6; depth = 0.5;
                    break;
                case 'duckbeam':
                    width = 2.2; height = 0.3; depth = 0.8;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'hurdleset':
                    width = 1.4; height = 0.7; depth = 1.5; // Covers multiple hurdles
                    break;
                case 'wallgap':
                    width = 1.8; height = 1.3; depth = 0.4;
                    // Gap height consideration
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.3, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 2.5, pos.z + depth/2)
                    };
                case 'rotatingblade':
                    // Dynamic hitbox based on rotation - always dangerous
                    width = 2.2; height = 2; depth = 0.4;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'swinginghammer':
                    // Dynamic hitbox for swinging hammer - wider danger zone
                    width = 2.5; height = 1.8; depth = 0.8;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'movingwall':
                    // Moving wall uses actual position
                    width = 0.4; height = 2; depth = 1;
                    break;
                case 'bouncingball':
                    // Dynamic hitbox based on ball position
                    const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                    width = 1.2; height = ballHeight + 0.6; depth = 1.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'spinninglaser':
                    // Laser beam danger zone - wider when spinning
                    width = 3.2; height = 1.4; depth = 3.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.1, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.3, pos.z + depth/2)
                    };
                default:
                    width = 1.0; height = 1.0; depth = 1.0;
            }
            
            return {
                min: new THREE.Vector3(
                    pos.x - width/2,
                    pos.y,
                    pos.z - depth/2
                ),
                max: new THREE.Vector3(
                    pos.x + width/2,
                    pos.y + height,
                    pos.z + depth/2
                )
            };
        }
        
        // Check if two 3D bounding boxes intersect
        function boundingBoxIntersection(bbox1, bbox2) {
            return (bbox1.min.x <= bbox2.max.x && bbox1.max.x >= bbox2.min.x) &&
                   (bbox1.min.y <= bbox2.max.y && bbox1.max.y >= bbox2.min.y) &&
                   (bbox1.min.z <= bbox2.max.z && bbox1.max.z >= bbox2.min.z);
        }
        
        // Calculate minimum distance between two bounding boxes
        function boundingBoxDistance(bbox1, bbox2) {
            const dx = Math.max(0, Math.max(bbox1.min.x - bbox2.max.x, bbox2.min.x - bbox1.max.x));
            const dy = Math.max(0, Math.max(bbox1.min.y - bbox2.max.y, bbox2.min.y - bbox1.max.y));
            const dz = Math.max(0, Math.max(bbox1.min.z - bbox2.max.z, bbox2.min.z - bbox1.max.z));
            
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // Enhanced collision handling with type-specific effects
        function handleCollision(obstacle, obstacleBBox) {
            // Slow motion for dramatic effect
            startSlowMotion(1000);
            
            // Type-specific collision audio
            audioManager.play('collision');
            
            // Lose life
            loseLife();
            
            // Enhanced collision effects based on obstacle material
            const collisionPos = obstacle.mesh.position.clone();
            let effectColor = 0xFF4444;
            
            switch (obstacle.type) {
                case 'jumpblock':
                case 'wallgap':
                    effectColor = 0x888888; // Concrete dust
                    break;
                case 'duckbeam':
                    effectColor = 0x4682B4; // Metal sparks
                    break;
                case 'spikes':
                    effectColor = 0xFF4500; // Fire/sparks
                    break;
            }
            
            // Main explosion with material-appropriate color
            createParticleEffect(collisionPos, effectColor, 'explosion');
            
            // Multiple secondary explosions for dramatic effect
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 1,
                        (Math.random() - 0.5) * 1
                    );
                    createParticleEffect(
                        collisionPos.clone().add(offset),
                        effectColor,
                        'explosion'
                    );
                }, i * 150);
            }
            
            // Screen shake intensity based on obstacle size
            const shakeIntensity = Math.min(0.5, (obstacleBBox.max.y - obstacleBBox.min.y) * 0.3);
            screenShake(shakeIntensity, 600);
            
            // Camera zoom for impact
            cameraZoomEffect(1.25, 400);
        }
        
        // Near-miss detection and bonus system
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            // Prevent multiple near-miss triggers for same obstacle
            if (obstacle.nearMissTriggered) return;
            obstacle.nearMissTriggered = true;
            
            // Calculate how close the call was
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const nearMissBonus = Math.floor((0.3 - distance) * 100); // Closer = more points
            
            addScore(nearMissBonus); // SAFE SCORE UPDATE
            
            // Near-miss audio feedback
            audioManager.play('nearmiss');
            
            // Visual feedback for near miss
            const effectPos = obstacle.mesh.position.clone();
            createParticleEffect(effectPos, 0xFFFF00, 'nearmiss'); // Yellow sparkles
            
            // Show near-miss popup
            showScorePopup(nearMissBonus, effectPos, 'CLOSE!');
        }
        
        // Update animations for moving obstacles
        function updateMovingObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                obstacle.animationTime += deltaTime * 0.001; // Convert to seconds
                
                switch (obstacle.type) {
                    case 'rotatingblade':
                        // Rotate the blade group
                        const bladeGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (bladeGroup) {
                            bladeGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                            
                            // Add warning sound for fast rotating blades
                            if (obstacle.rotationSpeed > 4 && Math.random() > 0.98) {
                                audioManager.createNoise(0.02, 800 + Math.random() * 400);
                            }
                        }
                        break;
                        
                    case 'swinginghammer':
                        // Swing the hammer arm
                        const hammerGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (hammerGroup) {
                            const armGroup = hammerGroup.children.find(child => child.type === 'Group');
                            if (armGroup) {
                                const swingAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                                armGroup.rotation.z = swingAngle;
                                
                                // Add swoosh sound at swing extremes
                                if (Math.abs(swingAngle) > obstacle.swingAmplitude * 0.8 && Math.random() > 0.95) {
                                    audioManager.createNoise(0.03, 1200 + Math.abs(swingAngle) * 500);
                                }
                            }
                        }
                        break;
                        
                    case 'movingwall':
                        // Move the wall side to side
                        const movingWall = obstacle.mesh.children[0];
                        if (movingWall) {
                            const movement = Math.sin(obstacle.animationTime * obstacle.movementSpeed) * obstacle.movementRange;
                            obstacle.mesh.position.x = obstacle.initialX + movement;
                            
                            // Add mechanical sound when changing direction
                            const prevMovement = Math.sin((obstacle.animationTime - deltaTime * 0.001) * obstacle.movementSpeed) * obstacle.movementRange;
                            if (Math.sign(movement) !== Math.sign(prevMovement) && Math.random() > 0.9) {
                                audioManager.createTone(150, 0.1, 'square');
                            }
                        }
                        break;
                        
                    case 'bouncingball':
                        // Bounce the ball up and down with realistic physics
                        const ballGroup = obstacle.mesh.children[0];
                        if (ballGroup) {
                            const ball = ballGroup.children[0]; // The actual ball
                            const shadow = ballGroup.children[1]; // Ground shadow
                            const ring = ballGroup.children[2]; // Warning ring
                            
                            if (ball && shadow && ring) {
                                // Bouncing motion using sine wave with gravity simulation
                                const bouncePhase = obstacle.animationTime * obstacle.bounceSpeed;
                                const bounceHeight = Math.abs(Math.sin(bouncePhase)) * obstacle.bounceHeight;
                                ball.position.y = 0.6 + bounceHeight; // 0.6 is ball radius
                                
                                // Scale shadow based on height (higher = smaller shadow)
                                const shadowScale = 1 - (bounceHeight / obstacle.bounceHeight) * 0.3;
                                shadow.scale.set(shadowScale, 1, shadowScale);
                                
                                // Pulse warning ring
                                const ringPulse = 1 + Math.sin(obstacle.animationTime * 8) * 0.2;
                                ring.scale.set(ringPulse, 1, ringPulse);
                                
                                // Add bounce sound at impact
                                if (bounceHeight < 0.2 && Math.random() > 0.97) {
                                    audioManager.createTone(200 + Math.random() * 100, 0.1, 'square');
                                }
                            }
                        }
                        break;
                        
                    case 'spinninglaser':
                        // Spin the laser beams and pulse warning lights
                        const laserGroup = obstacle.mesh.children[0];
                        if (laserGroup) {
                            const laserBeamGroup = laserGroup.children.find(child => child.type === 'Group');
                            
                            if (laserBeamGroup) {
                                // Rotate laser beams
                                laserBeamGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                                
                                // Pulse warning lights
                                const pulseFactor = (Math.sin(obstacle.animationTime * obstacle.pulseSpeed) + 1) / 2;
                                laserGroup.children.forEach(child => {
                                    if (child.geometry && child.geometry.type === 'SphereGeometry') {
                                        child.material.emissive.setHex(pulseFactor > 0.5 ? 0x440000 : 0x220000);
                                    }
                                });
                                
                                // Add laser whir sound
                                if (obstacle.rotationSpeed > 2.5 && Math.random() > 0.98) {
                                    audioManager.createNoise(0.02, 1500 + Math.random() * 500);
                                }
                            }
                        }
                        break;
                }
            });
        }

        function showScorePopup(score, position) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#00FF00';
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.fillText(`+${score}`, 64, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            
            sprite.position.copy(position);
            sprite.position.y += 2;
            sprite.scale.set(2, 1, 1);
            scene.add(sprite);
            
            // Animate popup
            const startY = sprite.position.y;
            const animatePopup = () => {
                sprite.position.y += 0.05;
                sprite.material.opacity -= 0.02;
                
                if (sprite.material.opacity > 0) {
                    requestAnimationFrame(animatePopup);
                } else {
                    scene.remove(sprite);
                }
            };
            animatePopup();
        }

        function loseLife() {
            gameState.lives--;
            
            // Make player invulnerable for 2 seconds
            gameState.invulnerable = true;
            gameState.invulnerabilityTime = 2000;
            
            // Visual feedback - make player flash red
            player.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0xFF6B6B);
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            
            if (gameState.lives <= 0) {
                endGame();
            }
        }

        // Smooth linear interpolation function
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        // Enhanced environment movement with parallax and smooth speed
        function updateEnvironmentMovement(deltaTime) {
            // Smooth speed interpolation
            visualSpeed = lerp(visualSpeed, gameState.speed, SPEED_LERP_FACTOR);
            
            // Move all environment objects with parallax effect
            Object.keys(environmentObjects).forEach(category => {
                environmentObjects[category].forEach((obj, index) => {
                    if (obj && obj.userData) {
                        const parallaxSpeed = visualSpeed * obj.userData.parallaxSpeed;
                        obj.position.z += parallaxSpeed;
                        
                        // Reset object position when it goes too far
                        if (obj.position.z > 50) {
                            // Calculate new spawn position based on object type
                            let resetDistance = -150;
                            if (obj.userData.type === 'building') {
                                resetDistance = -200 - Math.random() * 50;
                            } else if (obj.userData.type === 'streetLamp') {
                                resetDistance = -120;
                            } else if (obj.userData.type === 'streetLine') {
                                resetDistance = -120;
                            }
                            
                            obj.position.z = resetDistance;
                            
                            // Add some variation for buildings
                            if (obj.userData.type === 'building') {
                                // Randomize building properties
                                const side = obj.position.x < 0 ? 'left' : 'right';
                                const baseX = side === 'left' ? -15 : 15;
                                obj.position.x = baseX + (Math.random() - 0.5) * 8;
                                
                                // Update parallax speed slightly for variation
                                obj.userData.parallaxSpeed = 0.7 + Math.random() * 0.2;
                            }
                        }
                    }
                });
            });
        }
        
        // Dynamic audio system that responds to speed
        let lastEngineTime = 0;
        function updateDynamicAudio() {
            const currentTime = performance.now();
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Engine sound every 800ms, pitch increases with speed
            if (currentTime - lastEngineTime > 800) {
                audioManager.play('engine');
                lastEngineTime = currentTime;
            }
            
            // High-speed wind effects
            if (speedRatio > 0.7 && Math.random() > 0.95) {
                // Occasional high-speed wind whoosh
                audioManager.createNoise(0.08, 4000 + speedRatio * 2000);
            }
            
            // Master volume adjustment based on speed for intensity
            const baseVolume = 0.3;
            const speedVolume = baseVolume * (0.8 + speedRatio * 0.4);
            if (audioManager.audioContext && audioManager.masterGain) {
                audioManager.masterGain.gain.setValueAtTime(speedVolume, audioManager.audioContext.currentTime);
            }
        }
        
        // Enhanced motion blur effect at high speeds
        function updateVisualEffects() {
            const speedRatio = visualSpeed / gameState.maxSpeed;
            
            // Dynamic fog based on speed
            if (scene.fog) {
                scene.fog.near = 20 - speedRatio * 10; // Closer fog at high speed
                scene.fog.far = 60 + speedRatio * 20; // Extended range
            }
            
            // Camera FOV effect for speed sensation
            const baseFov = 60;
            const speedFov = baseFov + speedRatio * 15; // Wider FOV at high speed
            camera.fov = lerp(camera.fov, speedFov, 0.02);
            camera.updateProjectionMatrix();
            
            // Enhanced camera shake at high speeds
            if (speedRatio > 0.7) {
                const shakeIntensity = (speedRatio - 0.7) * 0.1;
                gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, shakeIntensity);
            }
        }
        
        // Alias for test compatibility
        const gameLoop = animate;
        const GameCore = { LevelManager };
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Calculate delta time for smooth movement
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            // STABILITY: Reset score counter each frame
            gameState.scoreThisFrame = 0;
            gameState.frameCount++;
            
            // STABILITY: Health monitoring every 5 seconds
            if (currentTime - gameState.lastHealthCheck > LIMITS.HEALTH_CHECK_INTERVAL) {
                gameState.lastHealthCheck = currentTime;
                performHealthCheck();
            }
            
            if (gameState.isPlaying) {
                // DIRECT player position update - NO INTERPOLATION!
                const targetX = LANE_POSITIONS[gameState.playerLane];
                player.position.x = targetX; // INSTANT LANE CHANGE!
                
                // Handle jumping - TRULY SMOOTH LANDING with parabolic descent
                if (gameState.playerAction === 'jumping') {
                    const deltaTime = 0.016;
                    
                    // Update vertical position
                    gameState.playerY += gameState.jumpVelocity * deltaTime;
                    
                    // Dynamic gravity based on height and velocity
                    let gravityStrength = 30; // Base gravity
                    
                    // Increase gravity when falling (negative velocity)
                    if (gameState.jumpVelocity < 0) {
                        // Apply air resistance for more realistic fall
                        const fallMultiplier = 1.3; // Makes falling slightly faster than rising
                        gravityStrength *= fallMultiplier;
                        
                        // Near ground - apply landing smoothing
                        if (gameState.playerY < 2.0) {
                            // Gradual gravity reduction near ground for soft landing
                            const landingFactor = gameState.playerY / 2.0; // 0 to 1 as we approach ground
                            gravityStrength *= (0.5 + landingFactor * 0.5); // Reduce gravity by up to 50%
                            
                            // Also apply velocity damping for extra smoothness
                            if (gameState.playerY < 1.0) {
                                gameState.jumpVelocity *= 0.95; // Slow down fall near ground
                            }
                        }
                    }
                    
                    // Apply gravity
                    gameState.jumpVelocity -= gravityStrength * deltaTime;
                    
                    // Terminal velocity cap (prevents too fast falling)
                    if (gameState.jumpVelocity < -25) {
                        gameState.jumpVelocity = -25;
                    }
                    
                    // ABSOLUTE TIMEOUT CHECK
                    const jumpDuration = performance.now() - gameState.jumpStartTime;
                    const shouldForceLand = jumpDuration > gameState.maxJumpDuration;
                    
                    // Check for landing
                    if (gameState.playerY <= 0) {
                        // Smooth final touchdown
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                        gameState.jumpStartTime = 0;
                        gameState.jumpCount = 0;
                        gameState.aerialCombo = 0;
                    } else if (shouldForceLand) {
                        // Forced landing - accelerate descent smoothly
                        if (gameState.playerY > 0.5) {
                            // Still high - increase downward velocity gradually
                            gameState.jumpVelocity = Math.min(gameState.jumpVelocity - 2, -15);
                        } else {
                            // Close to ground - land immediately
                            gameState.playerY = 0;
                            gameState.jumpVelocity = 0;
                            gameState.playerAction = 'running';
                            gameState.jumpStartTime = 0;
                            gameState.jumpCount = 0;
                            gameState.aerialCombo = 0;
                            
                            // Landing Audio & Visual - only when actually landing
                            audioManager.play('land');
                        
                            // Debug log if forced landing
                            if (shouldForceLand && gameState.playerY > 0) {
                                console.warn('⚠️ Jump timeout triggered - forced landing!');
                            }
                            
                            // Landing-Partikel
                            createParticleEffect(
                                new THREE.Vector3(player.position.x, 0.1, player.position.z),
                                0xAAAAAA,
                                'landing'
                            );
                        }
                        
                        // Mini screen shake for landing
                        screenShake(0.05, 100);
                    }
                }
                
                // Handle ducking
                if (gameState.playerAction === 'ducking') {
                    player.scale.y = 0.5;
                } else {
                    player.scale.y = 1;
                }
                
                player.position.y = gameState.playerY;
                
                // Handle invulnerability
                if (gameState.invulnerable) {
                    gameState.invulnerabilityTime -= 16; // ~16ms per frame at 60fps
                    
                    // Flash effect
                    const flashRate = Math.sin(Date.now() * 0.02) > 0;
                    player.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = flashRate ? 0.3 : 0.7;
                        }
                    });
                    
                    if (gameState.invulnerabilityTime <= 0) {
                        gameState.invulnerable = false;
                        // Restore normal player appearance
                        player.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = 1.0;
                                child.material.transparent = false;
                            }
                        });
                        // Restore original colors
                        if (player.children[0]) player.children[0].material.color.setHex(0x4A90E2); // Body
                        if (player.children[1]) player.children[1].material.color.setHex(0xF5B041); // Head
                    }
                }
                
                // Move track with smooth speed
                track.children.forEach(segment => {
                    segment.position.z += visualSpeed;
                    if (segment.position.z > 10) {
                        segment.position.z -= 100;
                    }
                });
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update current level
                LevelManager.update(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Move obstacles with smooth speed (unless in round transition)
                obstacles.forEach((obstacle, index) => {
                    if (!gameState.roundTransition) {
                        obstacle.mesh.position.z += visualSpeed;
                        obstacle.z = obstacle.mesh.position.z;
                    }
                    
                    if (obstacle.z > 10) {
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        // Only give score if obstacle was properly avoided (not hit)
                        if (!obstacle.hitPlayer) {
                            addScore(10); // SAFE SCORE UPDATE
                        }
                    }
                });
                
                // Move and cleanup collectibles (unless in round transition)
                gameState.activeCollectibles = gameState.activeCollectibles.filter(collectible => {
                    if (!gameState.roundTransition) {
                        collectible.mesh.position.z += visualSpeed;
                        
                        // Gentle floating animation
                        collectible.mesh.position.y += Math.sin(Date.now() * 0.003 + collectible.mesh.position.x) * 0.01;
                        collectible.mesh.rotation.y += 0.02; // Slow rotation
                    }
                    
                    if (collectible.mesh.position.z > 10) {
                        scene.remove(collectible.mesh);
                        return false; // Remove from array
                    }
                    return true;
                });
                
                // Spawn collectibles with 4-second interval
                spawnCollectible();
                
                // Spawn obstacles - FIXED for high-speed rounds
                const baseSpawnRate = 0.008; // Base spawn rate
                
                // FIX: Compensate for absolute speed, not just relative
                // At high speeds, obstacles pass by much faster, so we need MORE spawns
                const speedCompensation = Math.max(1, gameState.speed / 0.15); // Normalize to a reasonable base speed
                
                // Round-specific bonuses to ensure challenge increases
                let roundSpawnBonus = 1.0;
                switch(gameState.currentRound) {
                    case 1: 
                        roundSpawnBonus = 1.0; // Normal spawning
                        break;
                    case 2: 
                        roundSpawnBonus = 1.4; // 40% more obstacles
                        break;
                    case 3: 
                        roundSpawnBonus = 2.0; // DOUBLE obstacles for insane mode!
                        break;
                }
                
                // Final spawn rate calculation
                const spawnRate = baseSpawnRate * speedCompensation * roundSpawnBonus;
                
                // Debug spawn rate in Round 3
                if (gameState.currentRound === 3 && Math.random() < 0.01) {
                    console.log(`🎯 Round 3 Spawn - Speed: ${gameState.speed.toFixed(2)}, SpawnRate: ${(spawnRate * 100).toFixed(2)}%`);
                }
                
                if (Math.random() < spawnRate) {
                    const jumpObstacles = ['lowbarrier', 'jumpblock', 'hurdleset'];
                    const duckObstacles = ['highbarrier', 'duckbeam', 'wallgap'];
                    const flexibleObstacles = ['spikes'];
                    const movingObstacles = ['rotatingblade', 'swinginghammer', 'movingwall', 'bouncingball', 'spinninglaser'];
                    
                    let type;
                    const rand = Math.random();
                    const speedRatio = gameState.speed / gameState.maxSpeed;
                    
                    // Increase moving obstacle chance as speed increases
                    const movingChance = 0.05 + speedRatio * 0.15; // 5% to 20% chance
                    
                    if (rand < movingChance) {
                        // Moving obstacles (more frequent at higher speeds)
                        type = movingObstacles[Math.floor(Math.random() * movingObstacles.length)];
                    } else if (rand < 0.4 + movingChance) {
                        // Jump obstacles
                        type = jumpObstacles[Math.floor(Math.random() * jumpObstacles.length)];
                    } else if (rand < 0.8 + movingChance) {
                        // Duck obstacles
                        type = duckObstacles[Math.floor(Math.random() * duckObstacles.length)];
                    } else {
                        // Flexible obstacles
                        type = flexibleObstacles[Math.floor(Math.random() * flexibleObstacles.length)];
                    }
                    
                    const lane = Math.floor(Math.random() * 3);
                    createObstacle(type, lane, -30);
                }
                
                // Update camera with shake effect
                const baseX = player.position.x * 0.3;
                const baseY = 3 + Math.sin(Date.now() * 0.002) * 0.05;
                const baseZ = 8;
                
                // Apply screen shake
                const shakeX = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeY = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeZ = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 0.5;
                
                camera.position.x += (baseX + shakeX - camera.position.x) * 0.05;
                camera.position.y = baseY + shakeY;
                camera.position.z = baseZ + shakeZ;
                
                camera.lookAt(player.position.x * 0.2, 1, -3);
                
                // Update game timer
                const currentTime = Date.now();
                const elapsedTime = (currentTime - gameState.gameStartTime) / 1000;
                gameState.timeRemaining = Math.max(0, gameState.gameTime - elapsedTime);
                
                // SAFETY CHECK: Ensure controls stay active
                if (gameState.timeRemaining > 0 && !gameState.isGameOver) {
                    gameState.isPlaying = true; // Force playing state
                }
                
                // Check for victory (survived 60 seconds!)
                if (gameState.timeRemaining <= 0 && !gameState.isVictory && !gameState.isGameOver) {
                    console.log('Victory condition met - calling victoryGame()');
                    victoryGame();
                    return;
                }
                
                // Progressive speed increase based on current round
                const timeProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 to 1
                
                let speedMultiplier;
                switch(gameState.currentRound) {
                    case 1:
                        // Round 1: Gradual increase (0.08 → 0.35)
                        speedMultiplier = 1 + timeProgress * 3.375; // Results in 0.08 * 4.375 = 0.35
                        break;
                    case 2:
                        // Round 2: Moderate increase (0.28 → 0.525)
                        speedMultiplier = 1 + timeProgress * 0.875; // Results in 0.28 * 1.875 = 0.525
                        break;
                    case 3:
                        // Round 3: Slight increase but very fast (0.42 → 0.75)
                        speedMultiplier = 1 + timeProgress * 0.786; // Results in 0.42 * 1.786 = 0.75
                        break;
                    default:
                        speedMultiplier = 1 + timeProgress * 3.375;
                }
                
                gameState.speed = gameState.baseSpeed * speedMultiplier;
                gameState.speed = Math.min(gameState.speed, gameState.maxSpeed);
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update current level
                LevelManager.update(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Update dynamic audio based on speed
                updateDynamicAudio();
                
                // Update moving obstacles animations
                updateMovingObstacles(deltaTime);
                
                // Check collisions
                checkCollisions();
                
                updateUI();
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const canvas = document.getElementById('gameCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        // Event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        // Debug mode toggle for head tracking
        document.addEventListener('keydown', (e) => {
            if (e.key === 'h' || e.key === 'H') {
                if (headTracker) {
                    headTracker.debugMode = !headTracker.debugMode;
                    console.log(`🐛 Head Tracking Debug: ${headTracker.debugMode ? 'ON' : 'OFF'}`);
                    if (!headTracker.debugMode && headTracker.debugHUD) {
                        headTracker.debugHUD.remove();
                        headTracker.debugHUD = null;
                    }
                }
            }
        });
        
        // Gesture Control Integration with Dynamic Loading
        let gestureController = null;
        let gestureEnabled = false;
        let gestureModuleLoaded = false;
        
        const gestureBtn = document.getElementById('gestureControlBtn');
        const gestureCanvas = document.getElementById('gestureCanvas');
        const gestureStatus = document.getElementById('gestureStatus');
        const gestureStatusText = document.getElementById('gestureStatusText');
        const gestureCurrentText = document.getElementById('gestureCurrentText');
        
        // Check if gesture module is already loaded
        async function loadGestureModule() {
            if (gestureModuleLoaded || window.GestureControllerProjector) {
                gestureModuleLoaded = true;
                return true;
            }
            
            // Wait a bit for pre-loaded module
            await new Promise(resolve => setTimeout(resolve, 500));
            
            if (window.GestureControllerProjector) {
                gestureModuleLoaded = true;
                console.log('✅ Gesture Module already loaded');
                return true;
            }
            
            // Try loading again if not available
            try {
                console.log('🎮 Attempting to load Gesture Control Module...');
                const module = await import('./js/GestureControllerProjector.js');
                window.GestureControllerProjector = module.GestureControllerProjector || module.default;
                gestureModuleLoaded = true;
                console.log('✅ Gesture Module loaded on demand');
                return true;
            } catch (error) {
                console.error('❌ Module loading failed:', error);
                return false;
            }
        }
        
        // Initialize gesture control button
        if (gestureBtn) {
            console.log('🎮 Gesture Control Button found!');
            gestureBtn.style.display = 'block'; // Force visibility
            gestureBtn.style.visibility = 'visible';
            gestureBtn.addEventListener('click', async () => {
                if (!gestureEnabled) {
                    try {
                        // First ensure module is loaded
                        const moduleLoaded = await loadGestureModule();
                        if (!moduleLoaded) {
                            alert('Gestensteuerung konnte nicht geladen werden. Bitte Seite neu laden und erneut versuchen.');
                            return;
                        }
                        
                        // Initialize gesture controller
                        if (!gestureController && window.GestureControllerProjector) {
                            console.log('🎮 Initializing Gesture Controller...');
                            gestureController = new window.GestureControllerProjector({
                                videoElement: document.getElementById('gestureVideo'),
                                canvasElement: gestureCanvas,
                                onGestureDetected: handleGestureInput,
                                onStatsUpdate: updateGestureStats,
                                onError: handleGestureError,
                                onCalibrationComplete: () => {
                                    console.log('✅ Gesture calibration complete');
                                    gestureStatusText.textContent = 'Kalibriert';
                                },
                                debugMode: false,
                                projectorMode: true
                            });
                        }
                        
                        await gestureController.start();
                        gestureEnabled = true;
                        gestureBtn.textContent = '🛑 Gestensteuerung stoppen';
                        gestureBtn.classList.add('active');
                        gestureCanvas.classList.add('active');
                        gestureStatus.classList.add('active');
                        gestureStatusText.textContent = 'Aktiv';
                        console.log('✅ Gesture Control activated successfully');
                        
                    } catch (error) {
                        console.error('❌ Failed to start gesture control:', error);
                        alert(`Gestensteuerung Fehler: ${error.message}\n\nBitte stelle sicher dass:\n1. Kamera-Zugriff erlaubt ist\n2. HTTPS verwendet wird\n3. Chrome/Edge Browser verwendet wird`);
                    }
                } else {
                    // Stop gesture control
                    if (gestureController) {
                        gestureController.stop();
                    }
                    gestureEnabled = false;
                    gestureBtn.textContent = '🎮 Gestensteuerung aktivieren';
                    gestureBtn.classList.remove('active');
                    gestureCanvas.classList.remove('active');
                    gestureStatus.classList.remove('active');
                    gestureStatusText.textContent = 'Gestoppt';
                    gestureCurrentText.textContent = 'NONE';
                }
            });
        } else {
            console.warn('⚠️ Gesture Control Button not found or module not available');
            console.log('Button element:', gestureBtn);
            console.log('Module loaded:', window.GestureControllerProjector);
        }
        
        function handleGestureInput(gesture) {
            if (!gameState.isPlaying) return;
            
            gestureCurrentText.textContent = gesture;
            
            switch (gesture) {
                case 'MOVE_LEFT':
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        updatePlayerPosition();
                        const speedMultiplier = gameState.score / 5000;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    break;
                    
                case 'MOVE_RIGHT':
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        updatePlayerPosition();
                        const speedMultiplier = gameState.score / 5000;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    break;
                    
                case 'JUMP':
                    if (!gameState.isJumping && gameState.jumpCount < 2) {
                        gameState.isJumping = true;
                        gameState.jumpCount++;
                        gameState.jumpVelocity = config.jumpPower;
                        const speedMultiplier = gameState.score / 5000;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    }
                    break;
                    
                case 'DUCK':
                    if (!gameState.isDucking && !gameState.isJumping) {
                        gameState.isDucking = true;
                        const speedMultiplier = gameState.score / 5000;
                        // FIXED: Check if audioManager exists before using it
                    if (typeof audioManager !== 'undefined' && audioManager) {
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                    }
                    }
                    break;
                    
                case 'NONE':
                    if (gameState.isDucking) {
                        gameState.isDucking = false;
                    }
                    break;
            }
        }
        
        function updateGestureStats(stats) {
            // Optional: Update UI with gesture tracking stats
            if (stats.faceDetected && gestureStatusText) {
                gestureStatusText.textContent = `Aktiv (${stats.confidence ? (stats.confidence * 100).toFixed(0) : 0}%)`;
            }
        }
        
        function handleGestureError(error) {
            console.error('Gesture control error:', error);
            gestureStatusText.textContent = 'Fehler';
        }

        // Debug function for testing
        window.testFunction = function() {
            console.log('Test function works!');
        };
        
        // Gesture Control Debug Info
        window.debugGesture = function() {
            console.log('🎮 === GESTURE CONTROL DEBUG INFO ===');
            console.log('Button Element:', document.getElementById('gestureControlBtn'));
            console.log('Canvas Element:', document.getElementById('gestureCanvas'));
            console.log('Video Element:', document.getElementById('gestureVideo'));
            console.log('Status Element:', document.getElementById('gestureStatus'));
            console.log('Module Loaded:', !!window.GestureControllerProjector);
            console.log('Controller Instance:', gestureController);
            console.log('Gesture Enabled:', gestureEnabled);
            
            // Check visibility
            const btn = document.getElementById('gestureControlBtn');
            if (btn) {
                const rect = btn.getBoundingClientRect();
                console.log('Button Position:', { top: rect.top, right: rect.right, width: rect.width, height: rect.height });
                console.log('Button Display:', window.getComputedStyle(btn).display);
                console.log('Button Visibility:', window.getComputedStyle(btn).visibility);
                console.log('Button Z-Index:', window.getComputedStyle(btn).zIndex);
            }
            console.log('=====================================');
        };
        
        // Auto-run debug on page load
        setTimeout(() => {
            console.log('🎮 SubwayRunner V3.4-GESTURE-DEBUG loaded');
            window.debugGesture();
        }, 2000);

        // Initialize game when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM ready, starting game initialization...');
            init();
        });
    </script>
</body>
</html>