# üçéü•¶ V3.0 COLLECTIBLES IMPLEMENTATION PLAN

## üìã USER REQUIREMENTS
- **√ÑPFEL** (Apples) - nicht Kiwis!
- **BROKKOLIS** (Broccoli) - gr√ºnes Gem√ºse
- **4 Sekunden Abstand** zwischen Collectibles
- **Sichere Limitierung** - nicht zu viele gleichzeitig
- **Senior Developer Approach** - durchdacht und getestet

## üéØ TECHNICAL SPECIFICATIONS

### 1Ô∏è‚É£ **SPAWN TIMING SYSTEM**
```javascript
// 4-Second Interval System
gameState = {
    lastCollectibleTime: 0,
    collectibleInterval: 4000,  // 4 seconds
    activeCollectibles: [],     // Track all active items
    maxActiveCollectibles: 8,   // Max 8 gleichzeitig sichtbar
}

// Spawn Logic
const currentTime = performance.now();
const timeSinceLastSpawn = currentTime - gameState.lastCollectibleTime;

if (timeSinceLastSpawn >= gameState.collectibleInterval && 
    gameState.activeCollectibles.length < gameState.maxActiveCollectibles) {
    spawnCollectible();
    gameState.lastCollectibleTime = currentTime;
}
```

### 2Ô∏è‚É£ **APPLE IMPLEMENTATION** (statt Kiwi)
```javascript
function createApple(lane, z) {
    const appleGroup = new THREE.Group();
    
    // Red apple body
    const appleGeometry = new THREE.SphereGeometry(0.4, 16, 16);
    appleGeometry.scale(1, 1.1, 1); // Slightly taller
    
    const appleMaterial = new THREE.MeshLambertMaterial({
        color: 0xDC143C,      // Crimson red
        emissive: 0x8B0000,   // Dark red glow
        emissiveIntensity: 0.1
    });
    
    const apple = new THREE.Mesh(appleGeometry, appleMaterial);
    apple.position.y = 0.6; // Above ground for easy collection
    appleGroup.add(apple);
    
    // Brown stem
    const stemGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.15, 4);
    const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
    stem.position.y = 1.1;
    appleGroup.add(stem);
    
    // Green leaf
    const leafGeometry = new THREE.PlaneGeometry(0.15, 0.08);
    const leafMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x228B22,
        side: THREE.DoubleSide
    });
    const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
    leaf.position.set(0.05, 1.05, 0);
    leaf.rotation.z = Math.PI / 6;
    appleGroup.add(leaf);
    
    appleGroup.position.set(LANE_POSITIONS[lane], 0, z);
    return appleGroup;
}
```

### 3Ô∏è‚É£ **BROCCOLI IMPLEMENTATION** (optimiert)
```javascript
function createBroccoli(lane, z) {
    const broccoliGroup = new THREE.Group();
    
    // Green stem
    const stemGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.6, 6);
    const stemMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x4A7C4E  // Medium green
    });
    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
    stem.position.y = 0.3;
    broccoliGroup.add(stem);
    
    // Floret cluster (simplified for performance)
    const floretGeometry = new THREE.SphereGeometry(0.3, 8, 6);
    const floretMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x2D5016,      // Dark green
        flatShading: true     // For vegetable look
    });
    const florets = new THREE.Mesh(floretGeometry, floretMaterial);
    florets.position.y = 0.7;
    florets.scale.set(1.2, 0.8, 1.2); // Flatter top
    broccoliGroup.add(florets);
    
    broccoliGroup.position.set(LANE_POSITIONS[lane], 0, z);
    return broccoliGroup;
}
```

### 4Ô∏è‚É£ **SPAWN DISTRIBUTION**
```javascript
// Target: ~15 collectibles per 60-second game
// With 4-second intervals = exactly 15 spawns
// Distribution: 70% Apples, 30% Broccoli

function spawnCollectible() {
    // Check obstacle clearance
    const lane = Math.floor(Math.random() * 3);
    const spawnZ = -50; // Safe distance
    
    if (!isLaneSafe(lane, spawnZ)) return;
    
    // 70% Apple, 30% Broccoli
    const isApple = Math.random() < 0.7;
    const collectible = isApple ? 
        createApple(lane, spawnZ) : 
        createBroccoli(lane, spawnZ);
    
    gameState.activeCollectibles.push({
        mesh: collectible,
        type: isApple ? 'apple' : 'broccoli',
        lane: lane
    });
    
    scene.add(collectible);
}
```

### 5Ô∏è‚É£ **SAFETY MECHANISMS**
```javascript
// 1. Active collectible limit
if (gameState.activeCollectibles.length >= 8) {
    // Remove oldest if at limit
    const oldest = gameState.activeCollectibles.shift();
    scene.remove(oldest.mesh);
}

// 2. Distance check from obstacles
function isLaneSafe(lane, z) {
    for (const obstacle of obstacles) {
        if (obstacle.lane === lane && 
            Math.abs(obstacle.mesh.position.z - z) < 30) {
            return false; // Too close to obstacle
        }
    }
    return true;
}

// 3. Cleanup off-screen collectibles
gameState.activeCollectibles = gameState.activeCollectibles.filter(c => {
    if (c.mesh.position.z > 5) {
        scene.remove(c.mesh);
        return false;
    }
    return true;
});
```

## üìä EXPECTED RESULTS
- **Spawn Rate**: Exactly 1 collectible every 4 seconds
- **Total per Game**: ~15 collectibles (10-11 Apples, 4-5 Broccoli)
- **Active Limit**: Max 8 visible at once
- **Safe Distance**: 30+ units from obstacles
- **Performance**: Optimized meshes, automatic cleanup

## üß™ TESTING CHECKLIST
- [ ] Spawn timing exactly 4 seconds
- [ ] Apples appear red with stem and leaf
- [ ] Broccoli appears green with proper shape
- [ ] Max 8 collectibles visible
- [ ] No spawning near obstacles
- [ ] Smooth collection detection
- [ ] Performance stays at 60 FPS

## ‚ö†Ô∏è AVOIDING PAST MISTAKES
1. **NO COMPLEX GEOMETRIES** - Simple shapes only
2. **NO UNLIMITED SPAWNING** - Hard limit of 8 active
3. **NO HIGH SPAWN RATES** - Exactly 4-second intervals
4. **NO TESTING SHORTCUTS** - Full 60-second test required
5. **NO FEATURE CREEP** - Just apples and broccoli!