<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Subway Runner 3D - V3.9-MOBILE</title>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- MediaPipe Pose Detection CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/vision_bundle.js" crossorigin="anonymous"></script>
    
    <script type="module">
        // Pre-load Gesture Control Module
        import('./js/GestureControllerProjector.js')
            .then(module => {
                window.GestureControllerProjector = module.GestureControllerProjector || module.default;
                console.log('‚úÖ Gesture Module pre-loaded successfully');
            })
            .catch(error => {
                console.error('‚ùå Gesture Module pre-load failed:', error);
                // Fallback: Try alternative loading method
                const script = document.createElement('script');
                script.type = 'module';
                script.innerHTML = `
                    import { GestureControllerProjector } from './js/GestureControllerProjector.js';
                    window.GestureControllerProjector = GestureControllerProjector;
                `;
                document.head.appendChild(script);
            });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            max-width: 133.33vh; /* 4:3 aspect ratio */
            max-height: 75vw;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: right;
            z-index: 100;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        #menu h1 {
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        #menu button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #menu button:hover {
            background: #45a049;
        }
        
        #timer {
            font-size: 20px;
            margin-top: 5px;
        }
        
        #gestureControl {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            z-index: 9999 !important;
            display: block !important;
        }
        
        #gestureControlBtn {
            background: rgba(0, 255, 136, 0.9);
            color: #000;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0, 255, 136, 0.3);
            transition: all 0.3s;
        }
        
        #gestureControlBtn:hover {
            background: #00ff88;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.5);
        }
        
        #gestureControlBtn.active {
            background: #ff4444;
        }
        
        #gestureCanvas {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 180px;
            height: 135px;
            border: 2px solid #00ff88;
            border-radius: 8px;
            display: none;
            z-index: 150;
            background: #000;
        }
        
        #gestureCanvas.active {
            display: block;
        }
        
        #gestureStatus {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 10px;
            border-radius: 8px;
            font-size: 14px;
            display: none;
            z-index: 150;
        }
        
        #gestureStatus.active {
            display: block;
        }
        
        .timer-warning {
            color: #FF4444 !important;
            animation: pulse 0.5s infinite;
        }
        
        .timer-critical {
            color: #FF0000 !important;
            animation: fastPulse 0.2s infinite;
            font-weight: bold;
        }
        
        /* Audio Control Button */
        #audioToggle {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ff88;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s;
            user-select: none;
        }
        
        #audioToggle:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.1);
        }
        
        #audioToggle.muted {
            border-color: #ff4444;
            opacity: 0.7;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes fastPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        
        .name-input-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 16px;
            z-index: 300;
            text-align: center;
            min-width: 350px;
            border: 2px solid #4CAF50;
        }
        
        .name-input-dialog input {
            width: 200px;
            padding: 10px;
            margin: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }
        
        .name-input-dialog button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .name-input-dialog button:hover {
            background: #45a049;
        }
        
        .name-input-dialog button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .highscore-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            min-width: 200px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        .highscore-panel.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .highscore-panel.fading {
            opacity: 0;
        }
        
        .highscore-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .highscore-entry.current-player {
            color: #4CAF50;
            font-weight: bold;
        }
        
        /* Pose Detection Preview Window */
        #posePreview {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 8px;
            z-index: 500;
            display: none;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }
        
        #posePreview.active {
            display: block;
        }
        
        #poseVideo {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }
        
        #poseCanvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }
        
        #poseStatus {
            position: absolute;
            bottom: 5px;
            left: 5px;
            color: #00ff88;
            font-size: 10px;
            font-family: monospace;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 10;
        }
        
        #poseToggleBtn {
            position: fixed;
            top: 20px;
            right: 230px;
            padding: 10px 15px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            z-index: 501;
            transition: all 0.3s;
        }
        
        #poseToggleBtn:hover {
            background: #00cc70;
            transform: scale(1.05);
        }
        
        #poseToggleBtn.active {
            background: #ff6b6b;
        }
        
        /* Mobile UI Optimization */
        #mobileScoreBar {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 0 10px;
            z-index: 1000;
            align-items: center;
            justify-content: space-around;
            font-size: 14px;
            font-weight: 600;
        }
        
        #mobileInfoBar {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 0 10px;
            z-index: 1000;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            opacity: 0.8;
        }
        
        .mobile-score-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        /* Media Queries for Mobile */
        @media (max-width: 768px) or (pointer: coarse) {
            /* Hide desktop UI elements */
            #ui {
                display: none !important;
            }
            
            #instructions {
                display: none !important;
            }
            
            #gestureControl {
                display: none !important;
            }
            
            #poseToggleBtn {
                display: none !important;
            }
            
            #posePreview {
                display: none !important;
            }
            
            /* Show mobile UI */
            #mobileScoreBar {
                display: flex !important;
            }
            
            #mobileInfoBar {
                display: flex !important;
            }
            
            /* Adjust game container for mobile bars */
            #gameCanvas {
                position: fixed;
                top: 40px;
                bottom: 30px;
                left: 0;
                right: 0;
                width: 100% !important;
                height: calc(100vh - 70px) !important;
                max-width: none !important;
                max-height: none !important;
                border: none !important;
                border-radius: 0 !important;
            }
            
            /* Mobile menu adjustments */
            #menu {
                width: 90%;
                padding: 20px;
                font-size: 14px;
            }
            
            #menu h1 {
                font-size: 24px;
            }
            
            #menu p {
                font-size: 12px;
                margin: 5px 0;
            }
            
            #menu button {
                font-size: 16px;
                padding: 10px 20px;
            }
            
            /* Show mobile instructions in menu only */
            #menu .mobile-instructions {
                display: block;
                background: rgba(255, 255, 255, 0.1);
                padding: 10px;
                border-radius: 8px;
                margin: 10px 0;
            }
        }
        
        /* Desktop-only styles */
        @media (min-width: 769px) and (pointer: fine) {
            #mobileScoreBar, #mobileInfoBar {
                display: none !important;
            }
            
            #menu .mobile-instructions {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Audio Toggle Button -->
        <button id="audioToggle" class="muted" title="Toggle Sound">üîá</button>
        
        <!-- Mobile Score Bar (Top) -->
        <div id="mobileScoreBar">
            <div class="mobile-score-item">
                <span>Score:</span>
                <span id="mobileScore">0</span>
            </div>
            <div class="mobile-score-item">
                <span>üçé</span>
                <span id="mobileApples">0</span>
            </div>
            <div class="mobile-score-item">
                <span>ü•¶</span>
                <span id="mobileBroccolis">0</span>
            </div>
            <div class="mobile-score-item">
                <span>‚ù§Ô∏è</span>
                <span id="mobileLives">3</span>
            </div>
        </div>
        
        <!-- Mobile Info Bar (Bottom) -->
        <div id="mobileInfoBar">
            <span>Speed: <span id="mobileSpeed">100</span></span>
            <span> | </span>
            <span>Time: <span id="mobileTime">60</span>s</span>
        </div>
        
        <!-- Pose Detection Preview Window -->
        <button id="poseToggleBtn">üìπ Pose Detection</button>
        <div id="posePreview">
            <video id="poseVideo" autoplay playsinline></video>
            <canvas id="poseCanvas"></canvas>
            <div id="poseStatus">FPS: 0 | Pose: ‚ùå</div>
        </div>
        
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Speed: <span id="speed">100</span></div>
            <div>‚ù§Ô∏è Leben: <span id="lives">3</span></div>
            <div id="timer">‚è±Ô∏è Zeit: <span id="timeRemaining">60</span>s</div>
            <div>üçé √Ñpfel: <span id="apples">0</span></div>
            <div>ü•¶ Brokkoli: <span id="broccolis">0</span></div>
            <div style="font-size: 12px; opacity: 0.6; margin-top: 10px;">V4.0-MULTI-JUMP</div>
        </div>
        
        <div id="instructions">
            <div><strong>üéÆ Steuerung:</strong></div>
            <div class="desktop-controls">
                <div>A/D: Spurwechsel</div>
                <div>Leertaste/W: Springen ü¶ò</div>
                <div>S: Ducken ü¶Ü</div>
            </div>
            <div class="mobile-controls" style="display: none;">
                <div>‚óÄÔ∏è Wisch Links/Rechts ‚ñ∂Ô∏è</div>
                <div>‚¨ÜÔ∏è Wisch Hoch: Springen</div>
                <div>‚¨áÔ∏è Wisch Runter: Ducken</div>
                <div>üëÜ Doppeltipp: Multi-Jump</div>
            </div>
            <div><strong>üí° Tipps:</strong></div>
            <div>üü† Orange/Braun: √úberspringen!</div>
            <div>üîµ Blau/Grau oben: Ducken!</div>
            <div>üî¥ Stacheln: Beides m√∂glich!</div>
        </div>
        
        <div id="gestureControl">
            <button id="gestureControlBtn">üéÆ Gestensteuerung aktivieren</button>
            <div id="gestureStatus">
                <div>Status: <span id="gestureStatusText">Bereit</span></div>
                <div>Geste: <span id="gestureCurrentText">NONE</span></div>
            </div>
        </div>
        
        <video id="gestureVideo" style="display: none;" autoplay playsinline></video>
        <canvas id="gestureCanvas"></canvas>
        
        <div id="menu">
            <h1>üöá Subway Runner 3D</h1>
            <h2>‚è±Ô∏è 60-Sekunden Challenge!</h2>
            <p>√úberlebe 60 Sekunden bei stetig steigender Geschwindigkeit!</p>
            <p><strong>üéØ Ziel:</strong> 60 Sekunden √ºberleben</p>
            <p><strong>‚ö° Warnung:</strong> Wird sehr schnell!</p>
            
            <!-- Desktop Instructions -->
            <div class="desktop-instructions">
                <p><strong>üéÆ Steuerung:</strong></p>
                <p>A/D: Spurwechsel | W/Space: Springen | S: Ducken</p>
            </div>
            
            <!-- Mobile Instructions -->
            <div class="mobile-instructions">
                <p><strong>üì± Touch-Steuerung:</strong></p>
                <p>‚óÄÔ∏è Wisch Links/Rechts ‚ñ∂Ô∏è Lane wechseln</p>
                <p>‚¨ÜÔ∏è Wisch Hoch: Springen (mehrfach f√ºr Multi-Jump)</p>
                <p>‚¨áÔ∏è Wisch Runter: Ducken (Wisch hoch zum Aufstehen)</p>
            </div>
            
            <button onclick="startGame()">üéÆ Challenge starten!</button>
        </div>
        
        <div id="highscorePanel" class="highscore-panel">
            <div style="font-weight: bold; margin-bottom: 10px;">üèÜ TOP 10</div>
            <div id="highscoreList">Lade Bestenliste...</div>
        </div>
        
        <div id="nameInputDialog" class="name-input-dialog" style="display: none;">
            <h2>üéâ Neuer Highscore!</h2>
            <p>Gib deinen Namen ein:</p>
            <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="20">
            <br>
            <button onclick="submitHighscore()">üíæ Speichern</button>
            <button onclick="skipHighscore()">‚è≠Ô∏è √úberspringen</button>
        </div>
    </div>

    <script>
        // ============================================
        // POSE DETECTION SYSTEM (MediaPipe)
        // ============================================
        class PoseDetectionPreview {
            constructor() {
                this.video = null;
                this.canvas = null;
                this.ctx = null;
                this.isActive = false;
                this.poseLandmarker = null;
                this.lastVideoTime = -1;
                this.fps = 0;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                
                // Landmark indices for specific body parts
                this.landmarks = {
                    head: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],  // Face and head landmarks
                    leftHand: [15, 17, 19, 21],  // Left arm/hand
                    rightHand: [16, 18, 20, 22], // Right arm/hand
                    leftFoot: [27, 29, 31],      // Left leg/foot
                    rightFoot: [28, 30, 32]      // Right leg/foot
                };
                
                this.init();
            }
            
            async init() {
                // Get DOM elements
                this.video = document.getElementById('poseVideo');
                this.canvas = document.getElementById('poseCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Set canvas size
                this.canvas.width = 200;
                this.canvas.height = 150;
                
                // Setup button
                const toggleBtn = document.getElementById('poseToggleBtn');
                toggleBtn.addEventListener('click', () => this.toggle());
                
                // Initialize MediaPipe Pose
                await this.initializePose();
            }
            
            async initializePose() {
                try {
                    // Check if MediaPipe is loaded
                    if (typeof window.PoseLandmarker === 'undefined' && window.vision) {
                        window.PoseLandmarker = window.vision.PoseLandmarker;
                        window.FilesetResolver = window.vision.FilesetResolver;
                    }
                    
                    if (!window.PoseLandmarker || !window.FilesetResolver) {
                        console.warn('MediaPipe not loaded yet, retrying...');
                        setTimeout(() => this.initializePose(), 1000);
                        return;
                    }
                    
                    // Create the pose landmarker
                    const filesetResolver = await window.FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                    );
                    
                    this.poseLandmarker = await window.PoseLandmarker.createFromOptions(filesetResolver, {
                        baseOptions: {
                            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task',
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numPoses: 1,
                        minPoseDetectionConfidence: 0.5,
                        minPosePresenceConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    console.log('‚úÖ Pose Detection initialized');
                } catch (error) {
                    console.error('‚ùå Failed to initialize Pose Detection:', error);
                }
            }
            
            async toggle() {
                if (this.isActive) {
                    this.stop();
                } else {
                    await this.start();
                }
            }
            
            async start() {
                try {
                    // Request webcam access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: 640,
                            height: 480,
                            facingMode: 'user'
                        }
                    });
                    
                    this.video.srcObject = stream;
                    this.isActive = true;
                    
                    // Update UI
                    document.getElementById('posePreview').classList.add('active');
                    document.getElementById('poseToggleBtn').classList.add('active');
                    document.getElementById('poseToggleBtn').textContent = 'üõë Stop Pose';
                    
                    // Start detection loop
                    this.detectPose();
                    
                    console.log('‚úÖ Pose Detection started');
                } catch (error) {
                    console.error('‚ùå Failed to access webcam:', error);
                    alert('Kamera-Zugriff verweigert. Bitte erlauben Sie den Kamera-Zugriff.');
                }
            }
            
            stop() {
                // Stop video stream
                if (this.video.srcObject) {
                    const tracks = this.video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    this.video.srcObject = null;
                }
                
                this.isActive = false;
                
                // Update UI
                document.getElementById('posePreview').classList.remove('active');
                document.getElementById('poseToggleBtn').classList.remove('active');
                document.getElementById('poseToggleBtn').textContent = 'üìπ Pose Detection';
                
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                console.log('‚úÖ Pose Detection stopped');
            }
            
            async detectPose() {
                if (!this.isActive || !this.poseLandmarker) return;
                
                // Only process if video is ready
                if (this.video.readyState === 4) {
                    const startTimeMs = performance.now();
                    
                    // Skip if same frame
                    if (this.video.currentTime !== this.lastVideoTime) {
                        this.lastVideoTime = this.video.currentTime;
                        
                        try {
                            // Detect poses
                            const results = await this.poseLandmarker.detectForVideo(
                                this.video,
                                startTimeMs
                            );
                            
                            // Draw results
                            this.drawResults(results);
                            
                            // Update FPS
                            this.updateFPS();
                        } catch (error) {
                            console.error('Detection error:', error);
                        }
                    }
                }
                
                // Continue detection loop
                if (this.isActive) {
                    requestAnimationFrame(() => this.detectPose());
                }
            }
            
            drawResults(results) {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0];
                    
                    // Draw connections first (skeleton)
                    this.drawConnections(landmarks);
                    
                    // Draw landmarks with colored rectangles for body parts
                    this.drawBodyParts(landmarks);
                    
                    // Track head position for game control
                    this.trackHeadPosition(landmarks);
                    
                    // Update status with head tracking info
                    const headControlActive = this.centerX !== undefined ? 'üéØ' : 'üì∑';
                    document.getElementById('poseStatus').innerHTML = 
                        `FPS: ${this.fps} | Pose: ‚úÖ | Head: ${headControlActive}`;
                } else {
                    document.getElementById('poseStatus').innerHTML = 
                        `FPS: ${this.fps} | Pose: ‚ùå`;
                }
            }
            
            drawConnections(landmarks) {
                // Define connections (simplified skeleton)
                const connections = [
                    // Head
                    [0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8],
                    // Arms
                    [11, 13], [13, 15], [15, 17], [17, 19], [19, 21],
                    [12, 14], [14, 16], [16, 18], [18, 20], [20, 22],
                    // Body
                    [11, 12], [11, 23], [12, 24], [23, 24],
                    // Legs
                    [23, 25], [25, 27], [27, 29], [29, 31],
                    [24, 26], [26, 28], [28, 30], [30, 32]
                ];
                
                this.ctx.strokeStyle = 'rgba(0, 255, 136, 0.3)';
                this.ctx.lineWidth = 1;
                
                connections.forEach(([start, end]) => {
                    if (landmarks[start] && landmarks[end]) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(
                            landmarks[start].x * this.canvas.width,
                            landmarks[start].y * this.canvas.height
                        );
                        this.ctx.lineTo(
                            landmarks[end].x * this.canvas.width,
                            landmarks[end].y * this.canvas.height
                        );
                        this.ctx.stroke();
                    }
                });
            }
            
            drawBodyParts(landmarks) {
                // Draw head (red rectangles)
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.lineWidth = 2;
                this.landmarks.head.forEach(idx => {
                    if (landmarks[idx]) {
                        this.drawRectangle(
                            landmarks[idx].x * this.canvas.width,
                            landmarks[idx].y * this.canvas.height,
                            8, 8, '#ff000040'
                        );
                    }
                });
                
                // Draw hands (green rectangles)
                this.ctx.strokeStyle = '#00ff00';
                [...this.landmarks.leftHand, ...this.landmarks.rightHand].forEach(idx => {
                    if (landmarks[idx]) {
                        this.drawRectangle(
                            landmarks[idx].x * this.canvas.width,
                            landmarks[idx].y * this.canvas.height,
                            10, 10, '#00ff0040'
                        );
                    }
                });
                
                // Draw feet (blue rectangles)
                this.ctx.strokeStyle = '#0088ff';
                [...this.landmarks.leftFoot, ...this.landmarks.rightFoot].forEach(idx => {
                    if (landmarks[idx]) {
                        this.drawRectangle(
                            landmarks[idx].x * this.canvas.width,
                            landmarks[idx].y * this.canvas.height,
                            12, 12, '#0088ff40'
                        );
                    }
                });
            }
            
            drawRectangle(x, y, width, height, fillColor) {
                this.ctx.fillStyle = fillColor;
                this.ctx.fillRect(x - width/2, y - height/2, width, height);
                this.ctx.strokeRect(x - width/2, y - height/2, width, height);
            }
            
            trackHeadPosition(landmarks) {
                // Get nose position (landmark 0)
                const nose = landmarks[0];
                if (!nose) return;
                
                const headX = nose.x;
                
                // Initialize calibration on first detection
                if (this.centerX === undefined) {
                    this.centerX = headX;
                    this.leftThreshold = 0.08;  // 8% movement to trigger (more sensitive)
                    this.rightThreshold = 0.08;
                    this.lastLaneChange = 0;
                    this.laneChangeDelay = 400; // ms between lane changes (slightly slower)
                    console.log('üìè Head tracking calibrated at center:', this.centerX);
                    console.log('üéÆ Move your head left/right to control the player!');
                }
                
                // Calculate relative position
                const relativeX = headX - this.centerX;
                const now = Date.now();
                
                // Check if game is playing and enough time has passed
                if (gameState.isPlaying && (now - this.lastLaneChange > this.laneChangeDelay)) {
                    // Move left
                    if (relativeX < -this.leftThreshold && gameState.playerLane > 0) {
                        gameState.playerLane--;
                        this.lastLaneChange = now;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        console.log('üëà Head moved LEFT - Lane:', gameState.playerLane);
                    }
                    // Move right
                    else if (relativeX > this.rightThreshold && gameState.playerLane < 2) {
                        gameState.playerLane++;
                        this.lastLaneChange = now;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        console.log('üëâ Head moved RIGHT - Lane:', gameState.playerLane);
                    }
                }
                
                // Visual feedback on canvas
                this.ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                this.ctx.fillRect(headX * this.canvas.width - 5, nose.y * this.canvas.height - 5, 10, 10);
                
                // Draw threshold indicators
                if (this.centerX !== undefined) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.3)';
                    this.ctx.lineWidth = 1;
                    // Center line
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.centerX * this.canvas.width, 0);
                    this.ctx.lineTo(this.centerX * this.canvas.width, this.canvas.height);
                    this.ctx.stroke();
                    // Left threshold
                    this.ctx.beginPath();
                    this.ctx.moveTo((this.centerX - this.leftThreshold) * this.canvas.width, 0);
                    this.ctx.lineTo((this.centerX - this.leftThreshold) * this.canvas.width, this.canvas.height);
                    this.ctx.stroke();
                    // Right threshold
                    this.ctx.beginPath();
                    this.ctx.moveTo((this.centerX + this.rightThreshold) * this.canvas.width, 0);
                    this.ctx.lineTo((this.centerX + this.rightThreshold) * this.canvas.width, this.canvas.height);
                    this.ctx.stroke();
                }
            }
            
            updateFPS() {
                this.frameCount++;
                const now = performance.now();
                
                if (now - this.lastFpsUpdate >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
            }
        }
        
        // Initialize pose detection when page loads
        let poseDetection = null;
        document.addEventListener('DOMContentLoaded', () => {
            // Delay initialization to ensure MediaPipe is loaded
            setTimeout(() => {
                poseDetection = new PoseDetectionPreview();
                console.log('üéÆ Pose Detection System ready');
            }, 1000);
        });
        
        // ============================================
        // MOBILE TOUCH CONTROLLER
        // ============================================
        class TouchController {
            constructor() {
                this.touchStartX = 0;
                this.touchStartY = 0;
                this.touchStartTime = 0;
                this.touchEndX = 0;
                this.touchEndY = 0;
                
                // Double/Triple tap detection
                this.lastTapTime = 0;
                this.tapCount = 0;
                this.tapTimeout = null;
                
                // Swipe detection thresholds
                this.minSwipeDistance = 30; // Minimum distance for swipe
                this.maxSwipeTime = 300; // Maximum time for swipe (ms)
                this.doubleTapDelay = 300; // Max time between taps
                
                // Duck state tracking
                this.duckTimeout = null;
                this.isDucking = false;
                
                this.init();
            }
            
            init() {
                // Get canvas element
                const canvas = document.getElementById('gameCanvas');
                if (!canvas) return;
                
                // Add touch event listeners with passive: false for better control
                canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
                
                // Prevent default touch behaviors
                canvas.addEventListener('gesturestart', (e) => e.preventDefault());
                document.body.addEventListener('touchmove', (e) => {
                    if (e.target === canvas) e.preventDefault();
                }, { passive: false });
                
                console.log('üì± Touch Controller initialized');
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                if (!gameState.isPlaying) return;
                
                const touch = e.touches[0];
                this.touchStartX = touch.clientX;
                this.touchStartY = touch.clientY;
                this.touchStartTime = Date.now();
                
                // Double/Triple tap detection
                const currentTime = Date.now();
                const timeSinceLastTap = currentTime - this.lastTapTime;
                
                if (timeSinceLastTap < this.doubleTapDelay) {
                    this.tapCount++;
                } else {
                    this.tapCount = 1;
                }
                
                this.lastTapTime = currentTime;
                
                // Clear previous tap timeout
                if (this.tapTimeout) {
                    clearTimeout(this.tapTimeout);
                }
                
                // Set timeout to process taps
                this.tapTimeout = setTimeout(() => {
                    this.processTaps();
                }, this.doubleTapDelay);
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                if (!gameState.isPlaying) return;
                
                const touch = e.touches[0];
                this.touchEndX = touch.clientX;
                this.touchEndY = touch.clientY;
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                if (!gameState.isPlaying) return;
                
                const touch = e.changedTouches[0];
                this.touchEndX = touch.clientX;
                this.touchEndY = touch.clientY;
                
                // Calculate swipe
                const deltaX = this.touchEndX - this.touchStartX;
                const deltaY = this.touchEndY - this.touchStartY;
                const deltaTime = Date.now() - this.touchStartTime;
                
                // Check if it's a swipe (not a tap)
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                if (distance > this.minSwipeDistance && deltaTime < this.maxSwipeTime) {
                    // It's a swipe, cancel tap processing
                    if (this.tapTimeout) {
                        clearTimeout(this.tapTimeout);
                        this.tapTimeout = null;
                    }
                    this.tapCount = 0;
                    
                    // Determine swipe direction
                    this.processSwipe(deltaX, deltaY);
                }
            }
            
            processSwipe(deltaX, deltaY) {
                const absX = Math.abs(deltaX);
                const absY = Math.abs(deltaY);
                
                // Determine primary direction
                if (absX > absY) {
                    // Horizontal swipe
                    if (deltaX > 0) {
                        this.swipeRight();
                    } else {
                        this.swipeLeft();
                    }
                } else {
                    // Vertical swipe
                    if (deltaY > 0) {
                        this.swipeDown();
                    } else {
                        this.swipeUp();
                    }
                }
            }
            
            swipeLeft() {
                // Move lane left
                if (gameState.playerLane > 0) {
                    gameState.playerLane--;
                    const speedMultiplier = gameState.speed / gameState.maxSpeed;
                    audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    console.log('üì± Swipe Left - Lane:', gameState.playerLane);
                }
            }
            
            swipeRight() {
                // Move lane right
                if (gameState.playerLane < 2) {
                    gameState.playerLane++;
                    const speedMultiplier = gameState.speed / gameState.maxSpeed;
                    audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    console.log('üì± Swipe Right - Lane:', gameState.playerLane);
                }
            }
            
            swipeUp() {
                // If ducking, stand up
                if (gameState.playerAction === 'ducking') {
                    this.standUp();
                } 
                // If running, first jump
                else if (gameState.playerAction === 'running') {
                    this.jump();
                }
                // If already jumping, perform multi-jump
                else if (gameState.playerAction === 'jumping') {
                    this.performMultiJump();
                }
            }
            
            performMultiJump() {
                // Check current jump count and perform next jump level
                if (gameState.jumpCount === 1 && gameState.jumpCount < 3) {
                    // Second jump (Double Jump)
                    gameState.jumpVelocity = 12;
                    gameState.jumpCount = 2;
                    gameState.jumpStartTime = performance.now();
                    
                    const speedMultiplier = gameState.speed / gameState.maxSpeed;
                    audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    
                    // Double jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF8800,
                        'jump'
                    );
                    
                    console.log('üì± Swipe Up - Double Jump!');
                } 
                else if (gameState.jumpCount === 2 && gameState.jumpCount < 3) {
                    // Third jump (Triple Jump)
                    gameState.jumpVelocity = 14;
                    gameState.jumpCount = 3;
                    gameState.jumpStartTime = performance.now();
                    
                    const speedMultiplier = gameState.speed / gameState.maxSpeed;
                    audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    
                    // Triple jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF0088,
                        'jump'
                    );
                    
                    console.log('üì± Swipe Up - Triple Jump!');
                }
            }
            
            swipeDown() {
                // Duck
                if (gameState.playerAction === 'running') {
                    this.duck();
                }
                // If jumping, fast fall (slam down)
                else if (gameState.playerAction === 'jumping') {
                    gameState.jumpVelocity = -15; // Fast fall
                    console.log('üì± Swipe Down - Fast Fall');
                }
            }
            
            processTaps() {
                if (!gameState.isPlaying) return;
                
                console.log('üì± Taps detected:', this.tapCount);
                
                if (this.tapCount === 1) {
                    // Single tap - Jump
                    this.jump();
                } else if (this.tapCount === 2) {
                    // Double tap - Double Jump
                    this.doubleJump();
                } else if (this.tapCount >= 3) {
                    // Triple tap - Multi Jump
                    this.multiJump();
                }
                
                // Reset tap count
                this.tapCount = 0;
                this.tapTimeout = null;
            }
            
            jump() {
                if (gameState.playerAction === 'running') {
                    gameState.playerAction = 'jumping';
                    gameState.jumpVelocity = 10;
                    gameState.jumpStartTime = performance.now();
                    gameState.jumpCount = 1;
                    
                    const speedMultiplier = gameState.speed / gameState.maxSpeed;
                    audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    
                    // Jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, 0.1, player.position.z),
                        0xFFFF00,
                        'jump'
                    );
                    
                    console.log('üì± Jump!');
                }
            }
            
            doubleJump() {
                if (gameState.playerAction === 'jumping' && gameState.jumpCount < 2) {
                    gameState.jumpVelocity = 12;
                    gameState.jumpCount = 2;
                    gameState.jumpStartTime = performance.now();
                    
                    const speedMultiplier = gameState.speed / gameState.maxSpeed;
                    audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    
                    // Double jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF8800,
                        'jump'
                    );
                    
                    console.log('üì± Double Jump!');
                }
            }
            
            multiJump() {
                if (gameState.jumpCount < 3) {
                    gameState.playerAction = 'jumping';
                    gameState.jumpVelocity = 14;
                    gameState.jumpCount = 3;
                    gameState.jumpStartTime = performance.now();
                    
                    const speedMultiplier = gameState.speed / gameState.maxSpeed;
                    audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    
                    // Multi jump particles
                    createParticleEffect(
                        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
                        0xFF0088,
                        'jump'
                    );
                    
                    console.log('üì± Multi Jump!');
                }
            }
            
            duck() {
                gameState.playerAction = 'ducking';
                this.isDucking = true;
                
                const speedMultiplier = gameState.speed / gameState.maxSpeed;
                audioManager.playSpeedDependentSound('duck', speedMultiplier);
                
                // NO auto stand up - only manual with swipe up
                console.log('üì± Duck! (Swipe up to stand)');
            }
            
            standUp() {
                if (gameState.playerAction === 'ducking') {
                    gameState.playerAction = 'running';
                    this.isDucking = false;
                    
                    if (this.duckTimeout) {
                        clearTimeout(this.duckTimeout);
                        this.duckTimeout = null;
                    }
                    
                    console.log('üì± Stand Up!');
                }
            }
        }
        
        // Initialize touch controller
        let touchController = null;
        document.addEventListener('DOMContentLoaded', () => {
            // Check if mobile device
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile || 'ontouchstart' in window) {
                touchController = new TouchController();
                console.log('üì± Mobile device detected - Touch controls enabled');
                
                // Show mobile controls instructions
                const desktopControls = document.querySelector('.desktop-controls');
                const mobileControls = document.querySelector('.mobile-controls');
                if (desktopControls) desktopControls.style.display = 'none';
                if (mobileControls) mobileControls.style.display = 'block';
            }
            
            // Setup audio toggle button
            const audioToggle = document.getElementById('audioToggle');
            if (audioToggle) {
                // Set initial state based on AudioManager
                updateAudioButtonState();
                
                audioToggle.addEventListener('click', () => {
                    const isMuted = audioManager.toggleMute();
                    updateAudioButtonState();
                    
                    // Resume audio context if needed
                    if (!isMuted) {
                        audioManager.resume();
                    }
                });
            }
        });
        
        // Helper function to update audio button appearance
        function updateAudioButtonState() {
            const audioToggle = document.getElementById('audioToggle');
            if (audioToggle && audioManager) {
                if (audioManager.isMuted) {
                    audioToggle.textContent = 'üîá';
                    audioToggle.classList.add('muted');
                    audioToggle.title = 'Enable Sound';
                } else {
                    audioToggle.textContent = 'üîä';
                    audioToggle.classList.remove('muted');
                    audioToggle.title = 'Disable Sound';
                }
            }
        }
        
        // Modern Audio System with Real Sounds
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.masterVolume = 0.3;
                this.isMuted = true; // Start muted by default!
                this.audioBuffers = {}; // Cache for loaded sounds
                this.soundUrls = {
                    // Using free sound effects (these are example URLs - replace with actual working ones)
                    jump: 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=', // Placeholder
                    coin: 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=', // Placeholder
                    crash: null, // Will use synthesizer
                    whoosh: null, // Will use synthesizer
                    land: null, // Will use synthesizer
                    powerup: null, // Will use synthesizer
                };
                // DON'T initialize audio here - wait for user interaction!
                this.audioInitialized = false;
                this.loadMutePreference();
            }

            async initAudio() {
                if (this.audioInitialized) return; // Already initialized
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.isMuted ? 0 : this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);
                    this.createAdvancedSounds();
                    this.audioInitialized = true;
                    this.preloadSounds(); // Now load sounds after context is created
                    console.log('‚úÖ Audio system initialized on user interaction');
                } catch (error) {
                    console.log('Audio not supported');
                }
            }
            
            loadMutePreference() {
                const saved = localStorage.getItem('audioMuted');
                if (saved !== null) {
                    this.isMuted = saved === 'true';
                    if (this.masterGain) {
                        this.masterGain.gain.value = this.isMuted ? 0 : this.masterVolume;
                    }
                }
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.isMuted ? 0 : this.masterVolume;
                }
                localStorage.setItem('audioMuted', this.isMuted);
                return this.isMuted;
            }
            
            mute() {
                this.isMuted = true;
                if (this.masterGain) {
                    this.masterGain.gain.value = 0;
                }
                localStorage.setItem('audioMuted', 'true');
            }
            
            unmute() {
                this.isMuted = false;
                if (this.masterGain) {
                    this.masterGain.gain.value = this.masterVolume;
                }
                localStorage.setItem('audioMuted', 'false');
            }
            
            async preloadSounds() {
                // Preload any external sounds or base64 sounds
                for (const [name, url] of Object.entries(this.soundUrls)) {
                    if (url) {
                        try {
                            if (url.startsWith('data:')) {
                                // Base64 encoded sound
                                const response = await fetch(url);
                                const arrayBuffer = await response.arrayBuffer();
                                this.audioBuffers[name] = await this.audioContext.decodeAudioData(arrayBuffer);
                            } else if (url.startsWith('http')) {
                                // External URL
                                const response = await fetch(url, { mode: 'cors' });
                                const arrayBuffer = await response.arrayBuffer();
                                this.audioBuffers[name] = await this.audioContext.decodeAudioData(arrayBuffer);
                            }
                        } catch (error) {
                            console.log(`Could not load sound ${name}, will use synthesizer fallback`);
                        }
                    }
                }
            }
            
            playBuffer(name) {
                if (this.audioBuffers[name] && this.audioContext) {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = this.audioBuffers[name];
                    source.connect(this.masterGain);
                    source.start();
                    return true;
                }
                return false;
            }

            createTone(frequency, duration, type = 'sine', fadeOut = true) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                if (fadeOut) {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                } else {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                }
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            createNoise(duration, filterFreq = 1000) {
                if (!this.audioContext || this.isMuted) return; // Check muted!
                
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const source = this.audioContext.createBufferSource();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();
                
                source.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;
                
                source.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                source.start();
            }

            createAdvancedSounds() {
                // Enhanced realistic sounds using multiple layers
                this.sounds = {
                    jump: () => {
                        // Softer, more natural jump sound
                        this.createTone(100, 0.05, 'sine'); // Soft thud
                        setTimeout(() => this.createNoise(0.04, 1500), 20); // Light whoosh
                        // Removed reverb for cleaner sound
                    },
                    
                    land: () => {
                        // Subtle landing sound
                        this.createTone(60, 0.08, 'sine'); // Soft thud
                        this.createNoise(0.05, 600); // Light impact
                        // No reverb for cleaner sound
                    },
                    
                    duck: () => {
                        // Minimal duck sound
                        this.createNoise(0.06, 2000); // Soft swoosh
                        this.createTone(90, 0.06, 'sine'); // Light movement
                    },
                    
                    success: () => {
                        // Triumphant success with harmonic progression
                        const notes = [400, 500, 630, 800, 1000];
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.2, 'sine');
                                this.createReverbEffect(freq, 0.15, 0.6); // Rich reverb
                            }, i * 80);
                        });
                        // Add sparkle effect
                        setTimeout(() => {
                            for (let j = 0; j < 8; j++) {
                                setTimeout(() => this.createTone(1200 + j * 100, 0.05, 'sine'), j * 25);
                            }
                        }, 400);
                    },
                    
                    collision: () => {
                        // Softer collision sound
                        this.createNoise(0.15, 800); // Muffled impact
                        this.createTone(40, 0.2, 'sine', false); // Low bump
                        
                        if (window.gameState) {
                            gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, 0.15);
                        }
                    },
                    
                    coin: () => {
                        // Pleasant two-tone chime
                        this.createTone(800, 0.08, 'sine'); // First note
                        setTimeout(() => this.createTone(1200, 0.06, 'sine'), 40); // Second note
                        // Removed excessive shimmer effects
                    },
                    
                    whoosh: () => {
                        // Subtle lane change sound
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.5;
                        this.createNoise(0.08, 1500 + speedMultiplier * 500); // Light swoosh
                        // Removed tone for cleaner effect
                    },
                    
                    powerup: () => {
                        // Epic power-up activation sequence
                        const powerChord = [400, 500, 600, 750, 900];
                        powerChord.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.25, 'sine');
                                this.createReverbEffect(freq, 0.2, 0.8);
                            }, i * 60);
                        });
                        
                        // Add ascending energy effect
                        setTimeout(() => {
                            for (let m = 0; m < 12; m++) {
                                setTimeout(() => {
                                    this.createTone(1000 + m * 50, 0.04, 'triangle');
                                }, m * 30);
                            }
                        }, 300);
                    },
                    
                    // NEW: Ambient city sounds
                    ambient: () => {
                        if (!this.ambientPlaying) {
                            this.ambientPlaying = true;
                            this.playAmbientLoop();
                        }
                    },
                    
                    // NEW: Speed-based engine sound
                    engine: () => {
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.3;
                        const engineFreq = 40 + speedMultiplier * 60;
                        this.createTone(engineFreq, 0.2, 'sawtooth', false);
                    },
                    
                    // NEW: Near miss bonus sound
                    nearmiss: () => {
                        this.createTone(600, 0.08, 'sine');
                        setTimeout(() => this.createTone(800, 0.06, 'triangle'), 30);
                        this.createNoise(0.05, 5000); // Subtle whoosh
                    }
                };
            }

            // Enhanced reverb effect for depth
            createReverbEffect(frequency, duration, intensity) {
                if (!this.audioContext || this.isMuted) return; // Check muted!
                
                const delay = this.audioContext.createDelay(0.3);
                const feedback = this.audioContext.createGain();
                const wetGain = this.audioContext.createGain();
                
                delay.delayTime.value = 0.1;
                feedback.gain.value = intensity * 0.4;
                wetGain.gain.value = intensity * 0.3;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(wetGain);
                wetGain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            // Ambient city soundscape
            playAmbientLoop() {
                if (!this.audioContext || !this.ambientPlaying) return;
                
                // Distant traffic rumble
                const trafficFreq = 60 + Math.random() * 20;
                this.createTone(trafficFreq, 2.0, 'sawtooth', false);
                
                // Occasional distant sounds
                if (Math.random() > 0.7) {
                    setTimeout(() => {
                        this.createNoise(0.05, 800 + Math.random() * 1000);
                    }, Math.random() * 1000);
                }
                
                // Continue ambient loop
                setTimeout(() => this.playAmbientLoop(), 2000);
            }
            
            stopAmbient() {
                this.ambientPlaying = false;
            }
            
            // Dynamic sound based on game speed
            playSpeedDependentSound(soundName, speedMultiplier = 1) {
                const originalVolume = this.masterGain.gain.value;
                const speedVolume = Math.min(originalVolume * (0.8 + speedMultiplier * 0.4), 1.0);
                
                this.masterGain.gain.value = speedVolume;
                this.play(soundName);
                
                // Restore original volume
                setTimeout(() => {
                    this.masterGain.gain.value = originalVolume;
                }, 200);
            }
            
            play(soundName) {
                if (this.isMuted) return; // Don't play if muted
                
                // First try to play buffered/real sound
                if (this.playBuffer(soundName)) {
                    return; // Successfully played real sound
                }
                
                // Fall back to synthesizer sounds
                if (this.sounds[soundName]) {
                    try {
                        this.sounds[soundName]();
                    } catch (error) {
                        console.warn('Audio playback error:', error);
                    }
                }
            }

            async resume() {
                // First ensure audio is initialized
                if (!this.audioInitialized) {
                    await this.initAudio();
                }
                
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }
        }

        const audioManager = new AudioManager();
        audioManager.ambientPlaying = false;
        
        // Auto-start ambient sounds when game starts
        let ambientStarted = false;

        // Supabase Configuration - Disabled for now to fix startup issue
        const SUPABASE_URL = 'https://cquahsbgcycdmslcmmdz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNxdWFoc2JnY3ljZG1zbGNtbWR6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzY1MzU2NDUsImV4cCI6MjA1MjExMTY0NX0.7icZ7GGer0DAM2gxHpeXCOS6K-xLziVX9w0nwPmA0_k';
        
        // Initialize Supabase client
        let supabase = null;
        let highscores = [];
        let currentScore = 0;
        let currentSurvivalTime = 0;

        // TEMPORARILY DISABLED - Using localStorage only for now
        // The Supabase database needs the correct table (subway_runner_scores) to be created
        console.log('üì¥ Supabase temporarily disabled - using localStorage for highscores');
        supabase = null; // Explicitly set to null to use localStorage fallback
        
        // TODO: Create subway_runner_scores table in Supabase database
        // SQL is available in SUPABASE_SETUP.md

        // Highscore Management System
        class HighscoreManager {
            constructor() {
                this.localStorageKey = 'subwayRunner_highscores';
                this.loadHighscores();
            }

            async loadHighscores() {
                try {
                    if (supabase) {
                        const { data, error } = await supabase
                            .from('subway_runner_scores')
                            .select('*')
                            .order('score', { ascending: false })
                            .limit(10);
                        
                        if (!error && data) {
                            highscores = data;
                        } else {
                            throw new Error('Supabase error');
                        }
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    // Fallback to localStorage
                    const localScores = localStorage.getItem(this.localStorageKey);
                    highscores = localScores ? JSON.parse(localScores) : [];
                }
                this.displayHighscores();
            }

            async submitScore(playerName, score, survivalTime, isVictory) {
                const scoreEntry = {
                    player_name: playerName,
                    score: score,
                    survival_time: survivalTime,
                    is_victory: isVictory,
                    created_at: new Date().toISOString()
                };

                try {
                    if (supabase) {
                        const { data, error } = await supabase
                            .from('subway_runner_scores')
                            .insert([scoreEntry])
                            .select();
                        
                        if (error) throw error;
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    // Fallback to localStorage
                    highscores.push(scoreEntry);
                    highscores.sort((a, b) => b.score - a.score);
                    highscores = highscores.slice(0, 10); // Keep only top 10
                    localStorage.setItem(this.localStorageKey, JSON.stringify(highscores));
                }

                await this.loadHighscores();
            }

            isHighscore(score) {
                if (highscores.length < 10) return true;
                return score > highscores[9].score;
            }

            displayHighscores() {
                const list = document.getElementById('highscoreList');
                if (highscores.length === 0) {
                    list.innerHTML = 'Keine Scores vorhanden';
                    return;
                }

                let html = '';
                highscores.forEach((score, index) => {
                    const rank = index + 1;
                    const victoryIcon = score.is_victory ? 'üèÜ' : '';
                    const timeText = score.is_victory ? '60s' : `${score.survival_time}s`;
                    
                    html += `<div class="highscore-entry">
                        ${rank}. ${score.player_name} ${victoryIcon}<br>
                        <small>${score.score} pts - ${timeText}</small>
                    </div>`;
                });
                list.innerHTML = html;
            }
        }

        const highscoreManager = new HighscoreManager();
        
        // Highscore Panel Visibility Control
        let highscorePanelTimeout = null;
        
        function showHighscorePanelTemporarily() {
            const panel = document.getElementById('highscorePanel');
            if (!panel) return;
            
            // Show panel
            panel.classList.add('visible');
            panel.classList.remove('fading');
            
            // Hide after 5 seconds
            if (highscorePanelTimeout) {
                clearTimeout(highscorePanelTimeout);
            }
            
            highscorePanelTimeout = setTimeout(() => {
                hideHighscorePanel();
            }, 5000);
        }
        
        function showHighscorePanel() {
            const panel = document.getElementById('highscorePanel');
            if (!panel) return;
            panel.classList.add('visible');
            panel.classList.remove('fading');
        }
        
        function hideHighscorePanel() {
            const panel = document.getElementById('highscorePanel');
            if (!panel) return;
            
            panel.classList.add('fading');
            setTimeout(() => {
                panel.classList.remove('visible');
                panel.classList.remove('fading');
            }, 500);
        }

        // Make functions globally available for onclick handlers
        window.startGame = async function() {
            console.log('startGame called');
            try {
                await startGameInternal();
            } catch (error) {
                console.error('Error in startGame:', error);
            }
        };

        window.submitHighscore = function() {
            console.log('submitHighscore called');
            submitHighscoreInternal();
        };

        window.skipHighscore = function() {
            console.log('skipHighscore called');
            skipHighscoreInternal();
        };

        // Game state
        let gameState = {
            isPlaying: false,
            isGameOver: false,
            isVictory: false,
            score: 0,
            speed: 0.08, // Langsamerer Start
            baseSpeed: 0.08,
            maxSpeed: 0.45, // Sehr schnell am Ende!
            lives: 3,
            gameTime: 60, // 60 Sekunden
            timeRemaining: 60,
            gameStartTime: 0,
            playerLane: 1, // 0=left, 1=center, 2=right
            playerAction: 'running', // running, jumping, ducking
            playerY: 0,
            jumpVelocity: 0,
            // JUMP TIMEOUT SYSTEM
            jumpStartTime: 0,
            maxJumpDuration: 1000, // 1 second max jump time
            // MULTI-LEVEL JUMP SYSTEM (V4.0)
            jumpCount: 0,
            maxJumps: 4,
            currentHeightLevel: 1,
            aerialCombo: 0,
            obstacles: [],
            invulnerable: false,
            invulnerabilityTime: 0,
            timeScale: 1.0,
            cameraShakeIntensity: 0,
            cameraZoom: 1.0,
            slowMotionActive: false,
            // STABILITY FEATURES
            scoreThisFrame: 0,
            frameCount: 0,
            lastHealthCheck: 0,
            // COLLECTIBLES SYSTEM
            lastCollectibleTime: 0,
            collectibleInterval: 2500, // 2.5 seconds (increased from 4)
            activeCollectibles: [],
            maxActiveCollectibles: 10, // Increased from 8
            collectedApples: 0,
            collectedBroccolis: 0
        };
        
        // STABILITY LIMITS
        const LIMITS = {
            MAX_SCORE_PER_FRAME: 50,
            MAX_OBSTACLES: 20,
            MAX_SCENE_OBJECTS: 500,
            HEALTH_CHECK_INTERVAL: 5000 // 5 seconds
        };

        // ==================== LEVEL SYSTEM V3.3 ====================
        let currentLevel = 1;
        const LEVEL_PROGRESSION_THRESHOLD = 1000; // Points needed per level
        let nextLevelScore = LEVEL_PROGRESSION_THRESHOLD;
        
        // Level Manager
        const LevelManager = {
            levels: {},
            currentLevel: 1,
            levelObjects: [],
            
            registerLevel: function(id, level) {
                this.levels[id] = level;
            },
            
            loadLevel: function(levelId) {
                console.log(`üéÆ Loading Level ${levelId}`);
                
                // Cleanup previous level
                this.cleanup();
                
                // Load new level
                if (this.levels[levelId]) {
                    try {
                        this.currentLevel = levelId;
                        this.levels[levelId].load(scene, renderer);
                        
                        // Show level notification
                        this.showLevelNotification(levelId);
                        
                        // Update game state
                        currentLevel = levelId;
                        
                        // Clear loading flag on success
                        this.loadingLevel = null;
                    } catch (error) {
                        console.error(`Failed to load level ${levelId}:`, error);
                        // Reset loading flag on error
                        this.loadingLevel = null;
                        // Keep playing with current level
                        console.log('Continuing with current level due to load error');
                    }
                } else {
                    this.loadingLevel = null;
                }
            },
            
            cleanup: function() {
                // Remove all level-specific objects
                this.levelObjects.forEach(obj => {
                    if (obj.parent) {
                        obj.parent.remove(obj);
                    }
                    // Dispose geometries and materials
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (Array.isArray(obj.material)) {
                            obj.material.forEach(mat => mat.dispose());
                        } else {
                            obj.material.dispose();
                        }
                    }
                });
                this.levelObjects = [];
                
                // Let current level cleanup
                if (this.levels[this.currentLevel] && this.levels[this.currentLevel].cleanup) {
                    this.levels[this.currentLevel].cleanup();
                }
            },
            
            update: function(deltaTime) {
                // Update current level
                if (this.levels[this.currentLevel] && this.levels[this.currentLevel].update) {
                    this.levels[this.currentLevel].update(deltaTime);
                }
                
                // Check for level progression
                this.checkProgression();
            },
            
            checkProgression: function() {
                // Prevent progression during game over, victory, or while loading
                if (gameState.isGameOver || gameState.isVictory || this.loadingLevel) {
                    return;
                }
                
                // Prevent rapid-fire level changes
                const now = Date.now();
                if (this.lastLevelChange && (now - this.lastLevelChange) < 2000) {
                    return; // Wait at least 2 seconds between level changes
                }
                
                nextLevelScore = currentLevel * 1000; // Update for test compatibility
                const nextLevelThreshold = currentLevel * LEVEL_PROGRESSION_THRESHOLD;
                if (gameState.score >= nextLevelThreshold && currentLevel < 10 && this.levels[currentLevel + 1]) {
                    this.lastLevelChange = now;
                    currentLevel++; // INCREMENT BEFORE LOADING!
                    this.loadLevel(currentLevel);
                    nextLevelScore = currentLevel * 1000;
                }
            },
            
            checkLevelTransition: function() {
                // Alias for test compatibility
                this.checkProgression();
            },
            
            showLevelNotification: function(levelId) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 48px;
                    font-weight: bold;
                    color: #00ff00;
                    text-shadow: 0 0 20px rgba(0,255,0,0.8);
                    z-index: 10000;
                    pointer-events: none;
                `;
                
                const levelName = this.levels[levelId].name || `Level ${levelId}`;
                notification.textContent = `${levelName}!`;
                document.body.appendChild(notification);
                
                // Animate and remove
                setTimeout(() => {
                    notification.style.transition = 'opacity 1s';
                    notification.style.opacity = '0';
                    setTimeout(() => notification.remove(), 1000);
                }, 2000);
            },
            
            addLevelObject: function(obj) {
                this.levelObjects.push(obj);
            }
        };

        // ==================== LEVEL DEFINITIONS ====================
        
        // Level 1: Classic Subway
        const Level1 = {
            id: 1,
            name: "Classic Subway",
            description: "Classic underground subway environment",
            fogColor: 0x222222,
            fogDensity: 0.015,
            
            load: function(scene, renderer) {
                console.log('üöá Loading Level 1: Subway Tunnel');
                
                // Set fog and background
                scene.fog = new THREE.FogExp2(this.fogColor, this.fogDensity);
                renderer.setClearColor(this.fogColor);
                
                // Level 1 uses existing environment (buildings, street lamps, etc.)
                // No additional setup needed as it's the default
            },
            
            update: function(deltaTime) {
                // Level 1 has no special updates
            },
            
            cleanup: function() {
                // Level 1 doesn't need special cleanup
            }
        };

        // Level 2: Neon Night Run
        const Level2 = {
            id: 2,
            name: "Neon Night Run",
            description: "Cyberpunk city with neon lights",
            fogColor: 0x001133,
            fogDensity: 0.025,
            objects: {
                cyberpunkBuildings: [],
                neonLights: [],
                gridFloor: null
            },
            
            load: function(scene, renderer) {
                console.log('üåÉ Loading Level 2: Neon Night Run');
                
                // Update environment
                scene.fog = new THREE.FogExp2(this.fogColor, this.fogDensity);
                renderer.setClearColor(this.fogColor);
                
                // Safe environment handling - these objects don't exist
                // Skip hiding non-existent objects to prevent crashes
                console.log('Level 2 loading - skipping environment object hiding');
                
                // Create neon environment
                this.createEnvironment(scene);
            },
            
            createEnvironment: function(scene) {
                // Create neon grid floor
                const gridHelper = new THREE.GridHelper(100, 50, 0x00FFFF, 0x004444);
                gridHelper.position.y = -0.95;
                gridHelper.userData = { type: 'level2Grid' };
                scene.add(gridHelper);
                this.objects.gridFloor = gridHelper;
                LevelManager.addLevelObject(gridHelper);
                
                // Create cyberpunk buildings
                for (let i = 0; i < 20; i++) {
                    const buildingGroup = new THREE.Group();
                    const width = 6 + Math.random() * 4;
                    const height = 20 + Math.random() * 30;
                    const depth = 6 + Math.random() * 4;
                    
                    // Building body
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const buildingMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x111122,
                        emissive: 0x000011
                    });
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.y = height / 2;
                    buildingGroup.add(building);
                    
                    // Neon edges (wireframe)
                    const edgeGeometry = new THREE.EdgesGeometry(buildingGeometry);
                    const edgeMaterial = new THREE.LineBasicMaterial({ 
                        color: Math.random() > 0.5 ? 0x00FFFF : 0xFF00FF,
                        linewidth: 2
                    });
                    const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    edges.position.y = height / 2;
                    buildingGroup.add(edges);
                    this.objects.neonLights.push(edges);
                    
                    // Position building
                    const side = i % 2 === 0 ? 1 : -1;
                    buildingGroup.position.set(
                        side * (20 + Math.random() * 15),
                        0,
                        -i * 8
                    );
                    buildingGroup.userData = { type: 'cyberpunkBuilding' };
                    
                    scene.add(buildingGroup);
                    this.objects.cyberpunkBuildings.push(buildingGroup);
                    LevelManager.addLevelObject(buildingGroup);
                }
            },
            
            update: function(deltaTime) {
                // Animate neon lights
                this.objects.neonLights.forEach((light, index) => {
                    if (light.material) {
                        // Pulse effect
                        const pulse = Math.sin(Date.now() * 0.002 + index) * 0.3 + 0.7;
                        light.material.opacity = pulse;
                    }
                });
                
                // Move buildings forward
                this.objects.cyberpunkBuildings.forEach(building => {
                    building.position.z += gameState.speed * 0.7;
                    
                    // Recycle buildings
                    if (building.position.z > 10) {
                        building.position.z -= 200;
                    }
                });
            },
            
            cleanup: function() {
                try {
                    console.log('Neon level cleanup started');
                    
                    // Clear level objects safely with full error handling
                    if (this.objects) {
                        // Safe cleanup of arrays
                        ['cyberpunkBuildings', 'neonLights'].forEach(key => {
                            if (this.objects[key] && Array.isArray(this.objects[key])) {
                                this.objects[key].forEach(obj => {
                                    if (obj && obj.parent) {
                                        try { scene.remove(obj); } catch(e) {}
                                    }
                                });
                                this.objects[key] = [];
                            }
                        });
                        
                        // Safe cleanup of single objects
                        if (this.objects.gridFloor) {
                            try {
                                if (this.objects.gridFloor.parent) {
                                    scene.remove(this.objects.gridFloor);
                                }
                            } catch(e) {}
                            this.objects.gridFloor = null;
                        }
                    }
                    console.log('Neon level cleanup completed');
                } catch (error) {
                    console.error('Error during cleanup, but continuing:', error);
                    // Game continues even if cleanup fails
                }
            }
        };

        // Register levels
        LevelManager.registerLevel(1, Level1);
        LevelManager.registerLevel(2, Level2);
        
        // HEIGHT LEVEL SYSTEM (V4.0)
        const HEIGHT_LEVELS = {
            GROUND: 0,
            DUCKING: 0.5,
            STANDING: 1.0,
            JUMP_1: 3.0,
            JUMP_2: 5.0,
            JUMP_3: 7.0,
            SUPER: 8.0
        };
        
        // Get current player height level (0-5)
        function getPlayerHeightLevel() {
            const y = gameState.playerY;
            if (y >= HEIGHT_LEVELS.SUPER) return 5;
            if (y >= HEIGHT_LEVELS.JUMP_3) return 4;
            if (y >= HEIGHT_LEVELS.JUMP_2) return 3;
            if (y >= HEIGHT_LEVELS.JUMP_1) return 2;
            if (gameState.playerAction === 'ducking') return 0;
            return 1; // Standing
        }
        
        // SAFE SCORE FUNCTION WITH LIMITS
        function addScore(amount) {
            if (!gameState.isPlaying) return;
            
            // Limit score per frame
            if (gameState.scoreThisFrame + amount > LIMITS.MAX_SCORE_PER_FRAME) {
                amount = LIMITS.MAX_SCORE_PER_FRAME - gameState.scoreThisFrame;
            }
            
            if (amount > 0) {
                gameState.score += amount;
                gameState.scoreThisFrame += amount;
            }
        }
        
        // STABILITY: Health monitoring
        function performHealthCheck() {
            const health = {
                fps: gameState.frameCount / 5, // Rough FPS over last 5 seconds
                obstacles: obstacles.length,
                sceneObjects: scene.children.length,
                score: gameState.score,
                memory: performance.memory ? performance.memory.usedJSHeapSize / 1024 / 1024 : 'N/A'
            };
            
            console.log('=== HEALTH CHECK ===', health);
            
            // Reset frame counter
            gameState.frameCount = 0;
            
            // WARNINGS
            if (health.fps < 30) {
                console.warn('LOW FPS:', health.fps);
            }
            
            if (health.sceneObjects > LIMITS.MAX_SCENE_OBJECTS) {
                console.warn('TOO MANY OBJECTS:', health.sceneObjects);
            }
            
            if (health.score > 999999) {
                console.warn('SCORE OVERFLOW RISK:', health.score);
                gameState.score = 999999; // Cap score
            }
        }

        // Three.js setup
        let scene, camera, renderer, player, track, obstacles = [];
        const LANE_POSITIONS = [-2, 0, 2];
        
        // Environment object tracking for parallax movement
        let environmentObjects = {
            buildings: [],
            streetLamps: [],
            trafficSigns: [],
            streetLines: [],
            sidewalks: []
        };
        
        // Smooth speed system
        let visualSpeed = 0.08;
        let lastFrameTime = 0;
        const SPEED_LERP_FACTOR = 0.05;

        function init() {
            console.log('Initializing Three.js scene...');
            try {
                // Enhanced Scene
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x101020, 0.025); // Better fog

            // Camera (Subway Surfers perspective)
            camera = new THREE.PerspectiveCamera(60, 4/3, 0.1, 1000);
            camera.position.set(0, 3, 8);

            // Enhanced Renderer (SAFE improvements only)
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setClearColor(0x0a0a0f); // Darker background
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            // Removed tone mapping - can cause issues

            // Better lighting (SAFE)
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x4040aa, 0.3);
            scene.add(ambientLight);
            
            // Hemisphere light for natural look
            const hemisphereLight = new THREE.HemisphereLight(0x8888ff, 0x444488, 0.5);
            hemisphereLight.position.set(0, 50, 0);
            scene.add(hemisphereLight);

            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFE4B5, 1.2);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);

            // Atmospheric sky light for gradient
            const skyHemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.6);
            scene.add(skyHemisphereLight);

            // Rim lighting for urban atmosphere
            const rimLight = new THREE.DirectionalLight(0x4A90E2, 0.3);
            rimLight.position.set(-5, 8, -10);
            scene.add(rimLight);

            // Enhance renderer for better visuals
            // Removed tone mapping - can cause issues
            // Removed outputColorSpace - can cause issues

            // Create player
            createPlayer();
            
            // Create track
            createTrack();
            
            // Create environment
            createEnvironment();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
                // Start render loop
                animate();
                console.log('Three.js initialization complete');
            } catch (error) {
                console.error('Error initializing Three.js:', error);
            }
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            // Player body (torso) - Enhanced but SAFE
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4A90E2,
                emissive: 0x2A5090,
                emissiveIntensity: 0.2,
                shininess: 50
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.7;
            body.castShadow = true;
            body.receiveShadow = true;
            playerGroup.add(body);
            
            // Simple glow effect
            const glowGeometry = new THREE.BoxGeometry(0.65, 0.85, 0.35);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x6AB0FF,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(body.position);
            playerGroup.add(glow);

            // Player head - Better looking
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xF5B041,
                emissive: 0xF5B041,
                emissiveIntensity: 0.1,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.35;
            head.castShadow = true;
            playerGroup.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.4, 0.2);
            playerGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.4, 0.2);
            playerGroup.add(rightEye);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xF5B041 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            playerGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2C3E50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.0, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.0, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            // Cool Sneakers
            const shoeGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
            const shoeMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a1a,
                shininess: 80
            });
            
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.15, -0.35, 0.1);
            leftShoe.castShadow = true;
            playerGroup.add(leftShoe);
            
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.15, -0.35, 0.1);
            rightShoe.castShadow = true;
            playerGroup.add(rightShoe);
            
            // Shoe stripes (simple glow effect)
            const stripeGeometry = new THREE.BoxGeometry(0.22, 0.02, 0.42);
            const stripeMaterial = new THREE.MeshBasicMaterial({
                color: 0x00FF00,
                emissive: 0x00FF00
            });
            
            const leftStripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            leftStripe.position.set(-0.15, -0.32, 0.1);
            playerGroup.add(leftStripe);
            
            const rightStripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            rightStripe.position.set(0.15, -0.32, 0.1);
            playerGroup.add(rightStripe);

            // Backpack
            const backpackGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
            const backpackMaterial = new THREE.MeshLambertMaterial({ color: 0xE74C3C });
            const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.7, -0.25);
            backpack.castShadow = true;
            playerGroup.add(backpack);

            // Cap
            const capGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1);
            const capMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.55;
            cap.castShadow = true;
            playerGroup.add(cap);

            // Cap visor
            const visorGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.02);
            const visorMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 1.48, 0.2);
            visor.rotation.x = -0.3;
            visor.castShadow = true;
            playerGroup.add(visor);

            playerGroup.position.set(LANE_POSITIONS[gameState.playerLane], 0, 0);
            
            // FIX: Player should look forward (negative Z direction)
            playerGroup.rotation.y = Math.PI;
            
            scene.add(playerGroup);
            player = playerGroup;
        }

        function createTrack() {
            const trackGroup = new THREE.Group();
            
            // Create track segments
            for (let i = 0; i < 10; i++) {
                const segmentGroup = new THREE.Group();
                segmentGroup.position.z = -i * 10;
                
                // Main track
                const trackGeometry = new THREE.BoxGeometry(8, 0.1, 10);
                const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.receiveShadow = true;
                segmentGroup.add(trackMesh);
                
                // Lane dividers
                const dividerGeometry = new THREE.BoxGeometry(0.1, 0.05, 10);
                const dividerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
                
                const leftDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                leftDivider.position.x = -1;
                segmentGroup.add(leftDivider);
                
                const rightDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                rightDivider.position.x = 1;
                segmentGroup.add(rightDivider);
                
                trackGroup.add(segmentGroup);
            }
            
            scene.add(trackGroup);
            track = trackGroup;
        }

        function createEnvironment() {
            // Urban ground with asphalt texture
            const groundGeometry = new THREE.PlaneGeometry(80, 120);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(0, -1, -30);
            ground.receiveShadow = true;
            scene.add(ground);

            // Sidewalks
            const sidewalkGeometry = new THREE.PlaneGeometry(8, 120);
            const sidewalkMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x999999
            });
            
            const leftSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            leftSidewalk.rotation.x = -Math.PI / 2;
            leftSidewalk.position.set(-10, -0.98, -30);
            leftSidewalk.receiveShadow = true;
            leftSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(leftSidewalk);
            environmentObjects.sidewalks.push(leftSidewalk);
            
            const rightSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            rightSidewalk.rotation.x = -Math.PI / 2;
            rightSidewalk.position.set(10, -0.98, -30);
            rightSidewalk.receiveShadow = true;
            rightSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(rightSidewalk);
            environmentObjects.sidewalks.push(rightSidewalk);

            // Street lines
            for (let i = 0; i < 20; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.3, 2);
                const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const streetLine = new THREE.Mesh(lineGeometry, lineMaterial);
                streetLine.rotation.x = -Math.PI / 2;
                streetLine.position.set(0, -0.95, -i * 6);
                streetLine.userData = { 
                    type: 'streetLine', 
                    initialZ: -i * 6,
                    parallaxSpeed: 0.95 // 95% of game speed (close to track)
                };
                scene.add(streetLine);
                environmentObjects.streetLines.push(streetLine);
            }

            // Realistic city buildings
            for (let i = 0; i < 15; i++) {
                createRealisticBuilding(-15 - Math.random() * 8, -i * 8 - Math.random() * 4, 'left');
                createRealisticBuilding(15 + Math.random() * 8, -i * 8 - Math.random() * 4, 'right');
            }

            // Street lamps
            for (let i = 0; i < 12; i++) {
                createStreetLamp(-6, -i * 10);
                createStreetLamp(6, -i * 10);
            }

            // Traffic signs and urban details
            for (let i = 0; i < 8; i++) {
                if (Math.random() > 0.5) {
                    createTrafficSign(-7, -i * 12 - 5);
                    createTrafficSign(7, -i * 12 - 5);
                }
            }
        }

        function createRealisticBuilding(x, z, side) {
            const buildingGroup = new THREE.Group();
            
            // Building dimensions
            const width = 4 + Math.random() * 3;
            const depth = 4 + Math.random() * 3;
            const height = 8 + Math.random() * 12;
            
            // Main building structure
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create building materials with windows
            const buildingMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.2, 0.3 + Math.random() * 0.4)
            });
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2 - 1; // Ground level
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows
            const windowsPerFloor = Math.floor(width / 1.5);
            const floors = Math.floor(height / 3);
            
            for (let floor = 0; floor < floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    // Window facing the street
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const isLit = Math.random() > 0.4;
                    const windowMaterial = new THREE.MeshLambertMaterial({ 
                        color: isLit ? 0xFFFF88 : 0x222244,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    const windowX = -width/2 + 0.7 + w * 1.5;
                    const windowY = floor * 3 + 1.5;
                    const windowZ = side === 'left' ? depth/2 + 0.01 : -depth/2 - 0.01;
                    
                    window.position.set(windowX, windowY, windowZ);
                    if (side === 'right') window.rotation.y = Math.PI;
                    
                    buildingGroup.add(window);
                }
            }

            // Rooftop details
            if (Math.random() > 0.6) {
                // Air conditioning units
                const acGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const acMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const ac = new THREE.Mesh(acGeometry, acMaterial);
                ac.position.set(0, height/2 + 0.25, 0);
                ac.castShadow = true;
                buildingGroup.add(ac);
            }

            if (Math.random() > 0.7) {
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0, height/2 + 1, 0);
                buildingGroup.add(antenna);
            }

            buildingGroup.position.set(x, 0, z);
            buildingGroup.userData = { 
                type: 'building', 
                initialZ: z,
                parallaxSpeed: 0.7 + Math.random() * 0.2 // 70-90% of game speed
            };
            scene.add(buildingGroup);
            environmentObjects.buildings.push(buildingGroup);
        }

        function createStreetLamp(x, z) {
            const lampGroup = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1;
            pole.castShadow = true;
            lampGroup.add(pole);
            
            // Light fixture
            const lightGeometry = new THREE.SphereGeometry(0.3);
            const lightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFF88,
                emissive: 0x444400
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = 3;
            lampGroup.add(light);
            
            // Add point light
            const pointLight = new THREE.PointLight(0xFFFF88, 0.5, 10);
            pointLight.position.y = 3;
            lampGroup.add(pointLight);
            
            lampGroup.position.set(x, 0, z);
            lampGroup.userData = { 
                type: 'streetLamp', 
                initialZ: z,
                parallaxSpeed: 0.85 // 85% of game speed
            };
            scene.add(lampGroup);
            environmentObjects.streetLamps.push(lampGroup);
        }

        function createTrafficSign(x, z) {
            const signGroup = new THREE.Group();
            
            // Sign post
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.25;
            signGroup.add(post);
            
            // Sign board
            const signGeometry = new THREE.PlaneGeometry(1, 1);
            const signMaterial = new THREE.MeshLambertMaterial({ 
                color: Math.random() > 0.5 ? 0xFF4444 : 0x4444FF
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.y = 2;
            sign.rotation.y = x < 0 ? Math.PI/4 : -Math.PI/4;
            signGroup.add(sign);
            
            signGroup.position.set(x, 0, z);
            signGroup.userData = { 
                type: 'trafficSign', 
                initialZ: z,
                parallaxSpeed: 0.8 // 80% of game speed
            };
            scene.add(signGroup);
            environmentObjects.trafficSigns.push(signGroup);
        }

        function createObstacle(type, lane, z) {
            // STABILITY: Limit max obstacles
            if (obstacles.length >= LIMITS.MAX_OBSTACLES) {
                // Remove oldest obstacle
                const oldest = obstacles.shift();
                if (oldest && oldest.mesh) {
                    scene.remove(oldest.mesh);
                }
            }
            
            const obstacleGroup = new THREE.Group();
            obstacleGroup.position.set(LANE_POSITIONS[lane], 0, z);
            
            let obstacleGeometry, obstacleMaterial, height;
            
            switch (type) {
                case 'lowbarrier':
                    // Niedrige Barriere - muss √ºbersprungen werden
                    obstacleGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35
                    });
                    height = 0.8;
                    break;
                case 'highbarrier':
                    // Hohe Barriere - muss unterduckt werden
                    obstacleGeometry = new THREE.BoxGeometry(1.8, 0.4, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B0000
                    });
                    height = 0.4;
                    break;
                case 'spikes':
                    // Stacheln - √ºberspringen oder ducken
                    obstacleGeometry = new THREE.ConeGeometry(0.25, 0.6, 6);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF4500,
                        emissive: 0x221100
                    });
                    height = 0.6;
                    break;
                case 'jumpblock':
                    // Block zum √úberspringen - Concrete texture
                    obstacleGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B8B8B
                    });
                    height = 1.2;
                    // Add concrete details
                    const detailGeom = new THREE.BoxGeometry(0.1, 0.1, 1.3);
                    const detailMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    for (let i = 0; i < 4; i++) {
                        const detail = new THREE.Mesh(detailGeom, detailMat);
                        detail.position.set(
                            (i % 2 - 0.5) * 1.2, 
                            (Math.floor(i / 2) - 0.5) * 1.2, 
                            0
                        );
                        detail.castShadow = true;
                        obstacleGroup.add(detail);
                    }
                    break;
                case 'duckbeam':
                    // Balken zum Unterducken - Metal beam
                    obstacleGeometry = new THREE.BoxGeometry(2.2, 0.3, 0.8);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x4682B4
                    });
                    height = 0.3;
                    // Add support struts
                    const strutGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.8);
                    const strutMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
                    for (let i = 0; i < 2; i++) {
                        const strut = new THREE.Mesh(strutGeom, strutMat);
                        strut.position.set((i - 0.5) * 1.5, -0.75, 0);
                        strut.castShadow = true;
                        obstacleGroup.add(strut);
                    }
                    break;
                case 'hurdleset':
                    // H√ºrden-Set - mehrere niedrige H√ºrden
                    for (let i = 0; i < 3; i++) {
                        const hurdleGeometry = new THREE.BoxGeometry(1.4, 0.7, 0.2);
                        const hurdleMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22
                        });
                        const hurdle = new THREE.Mesh(hurdleGeometry, hurdleMaterial);
                        hurdle.position.set(0, 0.35, -0.5 + i * 0.5);
                        hurdle.castShadow = true;
                        hurdle.receiveShadow = true;
                        obstacleGroup.add(hurdle);
                        
                        // Add warning stripes
                        const stripeGeom = new THREE.PlaneGeometry(1.5, 0.1);
                        const stripeMat = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00,
                            transparent: true,
                            opacity: 0.8
                        });
                        const stripe = new THREE.Mesh(stripeGeom, stripeMat);
                        stripe.position.set(0, 0.6, -0.5 + i * 0.5 + 0.11);
                        obstacleGroup.add(stripe);
                    }
                    height = 0.7;
                    break;
                case 'wallgap':
                    // Wand mit L√ºcke zum Ducken - Industrial wall
                    const wallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090
                    });
                    
                    const wallLeft = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallLeft.position.set(-0.5, 1.25, 0);
                    wallLeft.castShadow = true;
                    wallLeft.receiveShadow = true;
                    obstacleGroup.add(wallLeft);
                    
                    const wallRight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallRight.position.set(0.5, 1.25, 0);
                    wallRight.castShadow = true;
                    wallRight.receiveShadow = true;
                    obstacleGroup.add(wallRight);
                    
                    const wallTop = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.8, 0.4),
                        wallMaterial
                    );
                    wallTop.position.set(0, 2.1, 0);
                    wallTop.castShadow = true;
                    wallTop.receiveShadow = true;
                    obstacleGroup.add(wallTop);
                    
                    // Add hazard warning lights
                    const lightGeom = new THREE.SphereGeometry(0.08);
                    const lightMat = new THREE.MeshLambertMaterial({ 
                        color: 0xFF0000,
                        emissive: 0x440000
                    });
                    const warningLight = new THREE.Mesh(lightGeom, lightMat);
                    warningLight.position.set(0, 1.3, 0.25);
                    obstacleGroup.add(warningLight);
                    
                    height = 1.3; // H√∂he der L√ºcke
                    break;
                    
                case 'rotatingblade':
                    // NEW: Rotating blade obstacle
                    const bladeGroup = new THREE.Group();
                    
                    // Central hub
                    const hubGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4);
                    const hubMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                    hub.position.y = 1;
                    bladeGroup.add(hub);
                    
                    // Rotating blades
                    for (let i = 0; i < 3; i++) {
                        const bladeGeometry = new THREE.BoxGeometry(2, 0.1, 0.2);
                        const bladeMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B0000,
                            emissive: 0x220000
                        });
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.y = 1;
                        blade.rotation.y = (i * Math.PI * 2) / 3;
                        blade.castShadow = true;
                        bladeGroup.add(blade);
                    }
                    
                    // Add warning lights
                    for (let j = 0; j < 2; j++) {
                        const warnLight = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06),
                            new THREE.MeshLambertMaterial({ 
                                color: 0xFF0000,
                                emissive: 0x330000
                            })
                        );
                        warnLight.position.set(j === 0 ? -1.2 : 1.2, 1.5, 0);
                        bladeGroup.add(warnLight);
                    }
                    
                    obstacleGroup.add(bladeGroup);
                    height = 2;
                    break;
                    
                case 'swinginghammer':
                    // NEW: Swinging hammer obstacle
                    const hammerGroup = new THREE.Group();
                    
                    // Support structure
                    const supportGeometry = new THREE.BoxGeometry(0.2, 3, 0.2);
                    const supportMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const support = new THREE.Mesh(supportGeometry, supportMaterial);
                    support.position.y = 1.5;
                    support.castShadow = true;
                    hammerGroup.add(support);
                    
                    // Swinging arm
                    const armGroup = new THREE.Group();
                    const armGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.y = -0.75;
                    arm.castShadow = true;
                    armGroup.add(arm);
                    
                    // Hammer head
                    const hammerGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
                    const hammerMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hammerHead = new THREE.Mesh(hammerGeometry, hammerMaterial);
                    hammerHead.position.y = -1.4;
                    hammerHead.castShadow = true;
                    armGroup.add(hammerHead);
                    
                    armGroup.position.y = 3;
                    hammerGroup.add(armGroup);
                    obstacleGroup.add(hammerGroup);
                    height = 1.8;
                    break;
                    
                case 'movingwall':
                    // NEW: Side-to-side moving wall
                    const movingWallGeometry = new THREE.BoxGeometry(0.3, 2, 1);
                    const movingWallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090,
                        transparent: true,
                        opacity: 0.9
                    });
                    const movingWall = new THREE.Mesh(movingWallGeometry, movingWallMaterial);
                    movingWall.position.y = 1;
                    movingWall.castShadow = true;
                    
                    // Add warning stripes
                    for (let k = 0; k < 4; k++) {
                        const stripeGeometry = new THREE.PlaneGeometry(0.35, 0.2);
                        const stripeMaterial = new THREE.MeshLambertMaterial({ 
                            color: k % 2 === 0 ? 0xFFFF00 : 0xFF0000
                        });
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.set(0.16, 0.5 + k * 0.4, 0);
                        movingWall.add(stripe);
                    }
                    
                    obstacleGroup.add(movingWall);
                    height = 2;
                    break;
                    
                case 'bouncingball':
                    // NEW: Bouncing ball obstacle - bounces up and down
                    const ballGroup = new THREE.Group();
                    
                    // Main bouncing ball
                    const ballGeometry = new THREE.SphereGeometry(0.6);
                    const ballMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35,
                        emissive: 0x331100
                    });
                    const bouncingBall = new THREE.Mesh(ballGeometry, ballMaterial);
                    bouncingBall.position.y = 1.5; // Starting height
                    bouncingBall.castShadow = true;
                    ballGroup.add(bouncingBall);
                    
                    // Shadow indicator on ground
                    const shadowGeometry = new THREE.CircleGeometry(0.4);
                    const shadowMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.3
                    });
                    const ballShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
                    ballShadow.rotation.x = -Math.PI / 2;
                    ballShadow.position.y = 0.01; // Just above ground
                    ballGroup.add(ballShadow);
                    
                    // Warning ring around bounce area
                    const ringGeometry = new THREE.RingGeometry(0.8, 1.0);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 0.6
                    });
                    const warningRing = new THREE.Mesh(ringGeometry, ringMaterial);
                    warningRing.rotation.x = -Math.PI / 2;
                    warningRing.position.y = 0.02;
                    ballGroup.add(warningRing);
                    
                    obstacleGroup.add(ballGroup);
                    height = 3; // Max bounce height
                    break;
                    
                case 'spinninglaser':
                    // NEW: Spinning laser beam obstacle
                    const laserGroup = new THREE.Group();
                    
                    // Central hub
                    const laserHubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6);
                    const laserHubMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x333333,
                        emissive: 0x110011
                    });
                    const laserHub = new THREE.Mesh(laserHubGeometry, laserHubMaterial);
                    laserHub.position.y = 1.2;
                    laserHub.castShadow = true;
                    laserGroup.add(laserHub);
                    
                    // Spinning laser beam (multiple segments for effect)
                    const laserBeamGroup = new THREE.Group();
                    for (let i = 0; i < 2; i++) {
                        const beamGeometry = new THREE.BoxGeometry(3, 0.1, 0.1);
                        const beamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0044,
                            emissive: 0x660022,
                            transparent: true,
                            opacity: 0.8
                        });
                        const laserBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                        laserBeam.position.y = 1.2;
                        laserBeam.rotation.y = i * Math.PI; // 180 degrees apart
                        laserBeam.castShadow = true;
                        laserBeamGroup.add(laserBeam);
                        
                        // Add glowing effect with smaller inner beam
                        const innerBeamGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
                        const innerBeamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFFFF,
                            emissive: 0xFF0044
                        });
                        const innerBeam = new THREE.Mesh(innerBeamGeometry, innerBeamMaterial);
                        innerBeam.position.copy(laserBeam.position);
                        innerBeam.rotation.copy(laserBeam.rotation);
                        laserBeamGroup.add(innerBeam);
                    }
                    
                    laserGroup.add(laserBeamGroup);
                    
                    // Warning lights at corners
                    for (let j = 0; j < 4; j++) {
                        const angle = (j * Math.PI) / 2;
                        const lightGeometry = new THREE.SphereGeometry(0.08);
                        const lightMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0000,
                            emissive: 0x440000
                        });
                        const warningLight = new THREE.Mesh(lightGeometry, lightMaterial);
                        warningLight.position.set(
                            Math.cos(angle) * 1.8,
                            0.2,
                            Math.sin(angle) * 1.8
                        );
                        laserGroup.add(warningLight);
                    }
                    
                    obstacleGroup.add(laserGroup);
                    height = 1.4; // Laser height
                    break;
            }
            
            // F√ºr einfache Hindernisse (nicht die komplexen oder neuen Typen)
            if (type !== 'hurdleset' && type !== 'wallgap' && 
                type !== 'rotatingblade' && type !== 'swinginghammer' && type !== 'movingwall' &&
                type !== 'bouncingball' && type !== 'spinninglaser') {
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.castShadow = true;
                
                if (type === 'spikes') {
                    obstacle.position.y = height / 2;
                } else if (type === 'duckbeam') {
                    obstacle.position.y = 1.4; // Optimale H√∂he f√ºr Ducken (aus git history)
                } else if (type === 'highbarrier') {
                    obstacle.position.y = 1.4; // Optimale H√∂he f√ºr Ducken (aus git history)
                } else {
                    obstacle.position.y = height / 2;
                }
                
                obstacleGroup.add(obstacle);
            }
            
            scene.add(obstacleGroup);
            
            // Enhanced obstacle data with animation properties
            const obstacleData = {
                mesh: obstacleGroup,
                type: type,
                lane: lane,
                z: z,
                height: height,
                animationTime: 0,
                rotationSpeed: 0,
                swingAmplitude: 0,
                swingSpeed: 0,
                movementRange: 0,
                movementSpeed: 0,
                initialX: LANE_POSITIONS[lane]
            };
            
            // Set animation properties for moving obstacles
            switch (type) {
                case 'rotatingblade':
                    obstacleData.rotationSpeed = 3 + Math.random() * 2; // Random rotation speed
                    break;
                case 'swinginghammer':
                    obstacleData.swingAmplitude = Math.PI / 3; // 60 degree swing
                    obstacleData.swingSpeed = 2 + Math.random(); // Random swing speed
                    break;
                case 'movingwall':
                    obstacleData.movementRange = 3; // Movement range across lanes
                    obstacleData.movementSpeed = 1.5 + Math.random() * 0.5;
                    break;
                case 'bouncingball':
                    obstacleData.bounceHeight = 2.5; // Max bounce height
                    obstacleData.bounceSpeed = 3 + Math.random() * 1.5; // Bounce frequency
                    break;
                case 'spinninglaser':
                    obstacleData.rotationSpeed = 2 + Math.random() * 1.5; // Laser spin speed
                    obstacleData.pulseSpeed = 4; // Warning light pulse
                    break;
            }
            
            obstacles.push(obstacleData);
        }

        // Create Apple collectible (red fruit) - DISTINCT from spikes!
        function createApple(lane, z) {
            const appleGroup = new THREE.Group();
            
            // Apple body - DISTINCTIVE APPLE SHAPE
            const appleGeometry = new THREE.SphereGeometry(0.35, 12, 12);
            // Scale to create apple shape: wider at top, narrower at bottom
            appleGeometry.scale(1.1, 1.2, 1.1);
            
            // Apply custom apple shape by modifying vertices
            const positions = appleGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const y = positions.getY(i);
                const x = positions.getX(i);
                const z = positions.getZ(i);
                
                // Create apple indentation at top
                if (y > 0.3) {
                    const indent = 1 - (y - 0.3) * 0.3;
                    positions.setX(i, x * indent);
                    positions.setZ(i, z * indent);
                }
                
                // Create apple bottom curve
                if (y < -0.2) {
                    const curve = 1 - Math.abs(y + 0.2) * 0.5;
                    positions.setX(i, x * curve);
                    positions.setZ(i, z * curve);
                }
            }
            appleGeometry.attributes.position.needsUpdate = true;
            
            // Bright red apple material - very different from orange spikes
            const appleMaterial = new THREE.MeshLambertMaterial({
                color: 0xFF0000,      // Pure red (not orange like spikes!)
                emissive: 0x660000,   // Dark red glow
                emissiveIntensity: 0.2
            });
            
            const apple = new THREE.Mesh(appleGeometry, appleMaterial);
            apple.position.y = 0.6;
            apple.castShadow = true;
            appleGroup.add(apple);
            
            // Thicker brown stem for visibility
            const stemGeometry = new THREE.CylinderGeometry(0.03, 0.04, 0.2, 6);
            const stemMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 1.05;
            appleGroup.add(stem);
            
            // Larger green leaf - more visible
            const leafGeometry = new THREE.PlaneGeometry(0.2, 0.12);
            const leafMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22,
                side: THREE.DoubleSide
            });
            const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
            leaf.position.set(0.08, 1.0, 0);
            leaf.rotation.z = Math.PI / 4;
            appleGroup.add(leaf);
            
            appleGroup.position.set(LANE_POSITIONS[lane], 0, z);
            appleGroup.userData = { type: 'apple', lane: lane };
            scene.add(appleGroup);
            
            return appleGroup;
        }

        // Create Broccoli collectible (green vegetable)
        function createBroccoli(lane, z) {
            const broccoliGroup = new THREE.Group();
            
            // Green stem
            const stemGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.6, 6);
            const stemMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A7C4E  // Medium green
            });
            const stem = new THREE.Mesh(stemGeometry, stemMaterial);
            stem.position.y = 0.3;
            stem.castShadow = true;
            broccoliGroup.add(stem);
            
            // Floret cluster (simplified for performance)
            const floretGeometry = new THREE.SphereGeometry(0.3, 8, 6);
            const floretMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2D5016,      // Dark green
                flatShading: true     // For vegetable look
            });
            const florets = new THREE.Mesh(floretGeometry, floretMaterial);
            florets.position.y = 0.7;
            florets.scale.set(1.2, 0.8, 1.2); // Flatter top
            florets.castShadow = true;
            broccoliGroup.add(florets);
            
            broccoliGroup.position.set(LANE_POSITIONS[lane], 0, z);
            broccoliGroup.userData = { type: 'broccoli', lane: lane };
            scene.add(broccoliGroup);
            
            return broccoliGroup;
        }

        // Check if lane is safe for spawning collectibles - IMPROVED
        function isLaneSafeForCollectible(lane, z) {
            const MIN_DISTANCE = 50; // Increased from 30 for fair gameplay
            
            for (const obstacle of obstacles) {
                if (obstacle.lane === lane) {
                    const distance = obstacle.mesh.position.z - z;
                    
                    // Check BOTH directions to prevent unfair placement
                    if (distance > 0 && distance < MIN_DISTANCE) {
                        // Obstacle is IN FRONT of collectible
                        return false;
                    }
                    if (distance < 0 && Math.abs(distance) < MIN_DISTANCE) {
                        // Obstacle is BEHIND collectible  
                        return false;
                    }
                }
                
                // Also check adjacent lanes for wide obstacles
                if (Math.abs(obstacle.lane - lane) === 1) {
                    const wideObstacles = ['wallgap', 'hurdleset', 'movingwall'];
                    if (wideObstacles.includes(obstacle.type)) {
                        const distance = Math.abs(obstacle.mesh.position.z - z);
                        if (distance < MIN_DISTANCE * 0.7) {
                            return false; // Wide obstacle nearby
                        }
                    }
                }
            }
            return true;
        }

        // Spawn collectible with improved interval and placement
        function spawnCollectible() {
            const currentTime = performance.now();
            const timeSinceLastSpawn = currentTime - gameState.lastCollectibleTime;
            
            // Only spawn if interval has passed and under limit
            if (timeSinceLastSpawn >= gameState.collectibleInterval && 
                gameState.activeCollectibles.length < gameState.maxActiveCollectibles) {
                
                // Random lane
                let lane = Math.floor(Math.random() * 3);
                // Varied spawn distance for more natural placement
                const spawnZ = -50 - Math.random() * 20; // Between -50 and -70
                
                if (!isLaneSafeForCollectible(lane, spawnZ)) {
                    // Try different lane if first is blocked
                    const altLane = (lane + 1 + Math.floor(Math.random() * 2)) % 3;
                    if (!isLaneSafeForCollectible(altLane, spawnZ)) {
                        return; // Skip this spawn if no safe lane
                    } else {
                        // Use alternative lane
                        lane = altLane;
                    }
                }
                
                // 70% Apple, 30% Broccoli
                const isApple = Math.random() < 0.7;
                const collectible = isApple ? 
                    createApple(lane, spawnZ) : 
                    createBroccoli(lane, spawnZ);
                
                gameState.activeCollectibles.push({
                    mesh: collectible,
                    type: isApple ? 'apple' : 'broccoli',
                    lane: lane
                });
                
                gameState.lastCollectibleTime = currentTime;
            }
        }

        async function startGameInternal() {
            // Resume audio context (will initialize on first call)
            await audioManager.resume();
            
            // Start ambient city sounds
            if (!ambientStarted) {
                audioManager.play('ambient');
                ambientStarted = true;
            }
            
            gameState.isPlaying = true;
            gameState.isGameOver = false;
            gameState.isVictory = false;
            gameState.score = 0;
            gameState.speed = gameState.baseSpeed;
            gameState.lives = 3;
            gameState.timeRemaining = gameState.gameTime;
            gameState.gameStartTime = Date.now();
            gameState.playerLane = 1;
            gameState.playerAction = 'running';
            gameState.playerY = 0;
            
            // Show highscore panel for first 5 seconds
            showHighscorePanelTemporarily();
            
            // Load Level 1
            currentLevel = 1;
            LevelManager.loadLevel(1);
            gameState.jumpVelocity = 0;
            gameState.jumpStartTime = 0; // Reset jump timer
            gameState.jumpCount = 0; // Reset jump counter
            gameState.aerialCombo = 0; // Reset aerial combo
            gameState.invulnerable = false;
            gameState.invulnerabilityTime = 0;
            gameState.timeScale = 1.0;
            gameState.cameraShakeIntensity = 0;
            gameState.slowMotionActive = false;
            
            // Reset collectibles
            gameState.lastCollectibleTime = 0;
            gameState.collectedApples = 0;
            gameState.collectedBroccolis = 0;
            gameState.activeCollectibles.forEach(c => scene.remove(c.mesh));
            gameState.activeCollectibles = [];
            
            // Clear obstacles
            obstacles.forEach(obs => scene.remove(obs.mesh));
            obstacles = [];
            
            // Start sound
            audioManager.play('powerup');
            
            document.getElementById('menu').style.display = 'none';
            updateUI();
        }

        function endGame() {
            // Prevent multiple game over calls
            if (gameState.isGameOver) {
                console.log('Game over already triggered, skipping');
                return;
            }
            
            // Hide highscore panel when game ends
            hideHighscorePanel();
            
            // Clear any pending timeout
            if (highscorePanelTimeout) {
                clearTimeout(highscorePanelTimeout);
                highscorePanelTimeout = null;
            }
            
            gameState.isPlaying = false;
            gameState.isGameOver = true;
            
            // Stop ambient sounds
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = Math.max(0, gameState.gameTime - Math.ceil(gameState.timeRemaining));
            
            // Check for highscore
            if (highscoreManager.isHighscore(currentScore)) {
                showNameInputDialog(false);
            } else {
                showGameOverMenu(false);
            }
        }

        function victoryGame() {
            // Prevent multiple victory calls
            if (gameState.isVictory) {
                console.log('Victory already triggered, skipping');
                return;
            }
            
            gameState.isPlaying = false;
            gameState.isVictory = true;
            
            // Stop ambient sounds
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = 60; // Full 60 seconds survived!
            
            // Victory celebration!
            audioManager.play('powerup');
            
            // Fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createParticleEffect(
                        new THREE.Vector3((Math.random() - 0.5) * 10, 5, -5),
                        [0xFF6B35, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFEDE57][i],
                        'success'
                    );
                }, i * 300);
            }
            
            // Always show name input for victory (it's always a highscore achievement!)
            showNameInputDialog(true);
        }

        function updateUI() {
            // Update desktop UI
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('speed').textContent = Math.floor(gameState.speed * 1000);
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('apples').textContent = gameState.collectedApples;
            document.getElementById('broccolis').textContent = gameState.collectedBroccolis;
            
            // Update mobile UI
            const mobileScore = document.getElementById('mobileScore');
            const mobileSpeed = document.getElementById('mobileSpeed');
            const mobileLives = document.getElementById('mobileLives');
            const mobileApples = document.getElementById('mobileApples');
            const mobileBroccolis = document.getElementById('mobileBroccolis');
            const mobileTime = document.getElementById('mobileTime');
            
            if (mobileScore) mobileScore.textContent = gameState.score;
            if (mobileSpeed) mobileSpeed.textContent = Math.floor(gameState.speed * 1000);
            if (mobileLives) mobileLives.textContent = gameState.lives;
            if (mobileApples) mobileApples.textContent = gameState.collectedApples;
            if (mobileBroccolis) mobileBroccolis.textContent = gameState.collectedBroccolis;
            if (mobileTime) mobileTime.textContent = Math.max(0, Math.ceil(gameState.timeRemaining));
            
            // Update timer with visual warnings
            const timeElement = document.getElementById('timeRemaining');
            const timerElement = document.getElementById('timer');
            timeElement.textContent = Math.max(0, Math.ceil(gameState.timeRemaining));
            
            // Timer visual states with audio warnings
            const timeLeft = Math.ceil(gameState.timeRemaining);
            
            // Show highscore panel in last 5 seconds
            if (timeLeft <= 5 && timeLeft > 0) {
                showHighscorePanel();
            }
            
            if (timeLeft <= 10) {
                timerElement.className = 'timer-critical';
                // Final countdown beeps
                if (timeLeft <= 5 && timeLeft > 0 && Math.ceil(gameState.timeRemaining) !== Math.ceil(gameState.timeRemaining + 0.016)) {
                    audioManager.play('coin'); // High pitched beep
                }
            } else if (timeLeft <= 20) {
                timerElement.className = 'timer-warning';
                // Warning at 20 seconds
                if (timeLeft === 20 && Math.abs(gameState.timeRemaining - 20) < 0.1) {
                    audioManager.play('duck'); // Warning sound
                }
            } else {
                timerElement.className = '';
            }
        }

        function showNameInputDialog(isVictory) {
            const dialog = document.getElementById('nameInputDialog');
            const title = dialog.querySelector('h2');
            
            if (isVictory) {
                title.innerHTML = 'üéâ VICTORY + HIGHSCORE! üéâ';
            } else {
                title.innerHTML = 'üéâ Neuer Highscore! üéâ';
            }
            
            dialog.style.display = 'block';
            document.getElementById('playerNameInput').focus();
        }

        function showGameOverMenu(isVictory) {
            const menu = document.getElementById('menu');
            
            if (isVictory) {
                menu.innerHTML = `
                    <h1>üéâ VICTORY! üéâ</h1>
                    <h2>Du hast 60 Sekunden √ºberlebt!</h2>
                    <p>Final Score: ${currentScore}</p>
                    <p>Du bist ein Subway Runner Champion! üèÜ</p>
                    <button onclick="startGame()">üéÆ Nochmal versuchen</button>
                `;
            } else {
                menu.innerHTML = `
                    <h1>Game Over!</h1>
                    <p>Final Score: ${currentScore}</p>
                    <p>Zeit √ºberlebt: ${currentSurvivalTime}s</p>
                    <button onclick="startGame()">üéÆ Nochmal spielen</button>
                `;
            }
            
            menu.style.display = 'block';
        }

        async function submitHighscoreInternal() {
            const nameInput = document.getElementById('playerNameInput');
            let playerName = nameInput.value.trim();
            
            if (!playerName) {
                playerName = 'Anonymous';
            }
            
            // Disable button while submitting
            const submitBtn = document.querySelector('#nameInputDialog button');
            submitBtn.disabled = true;
            submitBtn.textContent = 'üíæ Speichere...';
            
            try {
                await highscoreManager.submitScore(
                    playerName, 
                    currentScore, 
                    currentSurvivalTime, 
                    gameState.isVictory
                );
                
                // Hide dialog and show game over menu
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
                
                // Clear input for next time
                nameInput.value = '';
                
            } catch (error) {
                console.error('Error submitting highscore:', error);
                // Still hide dialog and continue
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
            }
            
            // Re-enable button
            submitBtn.disabled = false;
            submitBtn.textContent = 'üíæ Speichern';
        }

        function skipHighscoreInternal() {
            document.getElementById('nameInputDialog').style.display = 'none';
            showGameOverMenu(gameState.isVictory);
            document.getElementById('playerNameInput').value = '';
        }

        // Handle Enter key in name input
        document.addEventListener('DOMContentLoaded', () => {
            const nameInput = document.getElementById('playerNameInput');
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitHighscoreInternal();
                }
            });
        });

        function handleKeyDown(event) {
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    event.preventDefault();
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    event.preventDefault();
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    break;
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        // First jump
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = performance.now();
                        gameState.jumpCount = 1;
                        
                        // Audio & Visual Feedback
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                        audioManager.resume();
                        
                        // Jump particles - color based on jump number
                        createParticleEffect(
                            new THREE.Vector3(player.position.x, 0.1, player.position.z),
                            0xFFFF00, // Yellow for first jump
                            'jump'
                        );
                    } else if (gameState.playerAction === 'jumping' && 
                               gameState.jumpCount < gameState.maxJumps && 
                               gameState.playerY > 0.5) {
                        // Multi-jump system - up to 4 jumps
                        gameState.jumpCount++;
                        
                        // Jump force decreases with each jump
                        const jumpForce = 10 - (gameState.jumpCount - 1) * 1.5;
                        gameState.jumpVelocity = Math.max(jumpForce, 6);
                        gameState.jumpStartTime = performance.now(); // RESET timer!
                        
                        // Different particle colors for each jump level
                        const jumpColors = [0xFFFF00, 0xFF8800, 0xFF0088, 0x8800FF, 0x00FFFF];
                        const particleColor = jumpColors[Math.min(gameState.jumpCount - 1, 4)];
                        
                        // Audio pitch increases with jump count
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                        audioManager.resume(); // Resume audio context if needed
                        
                        // Sprung-Partikel
                        createParticleEffect(
                            new THREE.Vector3(player.position.x, 0.1, player.position.z),
                            0xFFFF00,
                            'jump'
                        );
                    }
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                    }
                    break;
            }
        }

        function handleKeyUp(event) {
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    gameState.playerAction = 'running';
                    break;
            }
        }

        function createParticleEffect(position, color, type) {
            let particleCount, spreadRange, speed, size;
            
            switch (type) {
                case 'success':
                    particleCount = 25;
                    spreadRange = 3;
                    speed = 4;
                    size = 0.06;
                    break;
                case 'explosion':
                    particleCount = 40;
                    spreadRange = 5;
                    speed = 6;
                    size = 0.08;
                    break;
                case 'jump':
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.04;
                    break;
                case 'landing':
                    particleCount = 20;
                    spreadRange = 3;
                    speed = 2;
                    size = 0.05;
                    break;
                default:
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.05;
            }
            
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 6, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true
                    })
                );
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spreadRange,
                    Math.random() * speed + 0.5,
                    (Math.random() - 0.5) * spreadRange
                );
                particle.life = 1.0;
                particle.originalSize = size;
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Enhanced particle animation
            const animateParticles = () => {
                particles.children.forEach((particle, index) => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(gameState.timeScale));
                    particle.velocity.y -= 0.15 * gameState.timeScale; // Gravity
                    particle.life -= 0.015 * gameState.timeScale;
                    
                    // Fancy effects based on type
                    if (type === 'explosion') {
                        particle.material.opacity = particle.life * 0.8;
                        particle.scale.setScalar(1 + (1 - particle.life) * 2);
                        particle.rotation.x += 0.1 * gameState.timeScale;
                        particle.rotation.y += 0.1 * gameState.timeScale;
                    } else if (type === 'success') {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(1 + Math.sin(Date.now() * 0.01 + index) * 0.3);
                    } else {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(particle.life);
                    }
                    
                    if (particle.life <= 0) {
                        particles.remove(particle);
                    }
                });
                
                if (particles.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }

        function startSlowMotion(duration = 800) {
            gameState.slowMotionActive = true;
            gameState.timeScale = 0.3;
            
            // Camera zoom effect
            const originalFov = camera.fov;
            camera.fov = originalFov * 0.8;
            camera.updateProjectionMatrix();
            
            setTimeout(() => {
                gameState.slowMotionActive = false;
                gameState.timeScale = 1.0;
                camera.fov = originalFov;
                camera.updateProjectionMatrix();
            }, duration);
        }

        function screenShake(intensity = 0.1, duration = 300) {
            gameState.cameraShakeIntensity = intensity;
            
            setTimeout(() => {
                gameState.cameraShakeIntensity = 0;
            }, duration);
        }

        function cameraZoomEffect(targetZoom = 1.2, duration = 500) {
            const originalFov = camera.fov;
            const targetFov = originalFov / targetZoom;
            
            const startTime = Date.now();
            const zoomAnimation = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.5) {
                    // Zoom in
                    const zoomProgress = progress * 2;
                    camera.fov = originalFov - (originalFov - targetFov) * zoomProgress;
                } else {
                    // Zoom out
                    const zoomProgress = (progress - 0.5) * 2;
                    camera.fov = targetFov + (originalFov - targetFov) * zoomProgress;
                }
                
                camera.updateProjectionMatrix();
                
                if (progress < 1) {
                    requestAnimationFrame(zoomAnimation);
                }
            };
            zoomAnimation();
        }

        function createExplosionRing(position, color = 0xFF6644) {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            ring.position.copy(position);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            // Animate ring expansion
            const animateRing = () => {
                ring.scale.x += 0.3;
                ring.scale.y += 0.3;
                ring.material.opacity -= 0.02;
                
                if (ring.material.opacity > 0) {
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ring);
                }
            };
            animateRing();
        }

        // Enhanced collision detection with precise bounding boxes and near-miss system
        function checkCollisions() {
            if (gameState.invulnerable) return;
            
            // Player bounding box calculation
            const playerBBox = calculatePlayerBoundingBox();
            
            obstacles.forEach((obstacle, index) => {
                // Calculate obstacle bounding box
                const obstacleBBox = calculateObstacleBoundingBox(obstacle);
                
                // Check for actual collision using 3D bounding box intersection
                const isColliding = boundingBoxIntersection(playerBBox, obstacleBBox);
                
                // ENHANCED DUCK COLLISION DETECTION - V4.0 WITH SUPER JUMP
                if (obstacle.type === 'duckbeam' || obstacle.type === 'highbarrier' || obstacle.type === 'wallgap') {
                    const playerX = LANE_POSITIONS[gameState.playerLane];
                    const obstacleX = obstacle.mesh.position.x;
                    const obstacleZ = obstacle.mesh.position.z;
                    
                    // Check if player is in same lane (X axis)
                    const inSameLane = Math.abs(playerX - obstacleX) < 1.0;
                    
                    // Check if obstacle is close enough in Z direction
                    const inCollisionZone = obstacleZ > -2 && obstacleZ < 2;
                    
                    if (inSameLane && inCollisionZone) {
                        const playerHeight = gameState.playerY;
                        const safeJumpHeight = 3.0; // Can jump over duck obstacles at this height
                        
                        // V4.0: Check if player is high enough to jump over
                        if (playerHeight >= safeJumpHeight) {
                            // SUPER JUMP SUCCESS! No collision when jumping high
                            console.log(`üöÄ SUPER JUMP! Cleared duck obstacle at height ${playerHeight.toFixed(1)}`);
                            
                            // Bonus points for skillful play
                            const heightBonus = Math.floor((playerHeight - safeJumpHeight) * 50);
                            addScore(200 + heightBonus);
                            gameState.aerialCombo++;
                            
                            // Show achievement
                            if (gameState.jumpCount >= 3) {
                                showScorePopup(300 + heightBonus, obstacle.mesh.position, 'SUPER JUMP!');
                            }
                            
                            // Special particle effect
                            createParticleEffect(
                                obstacle.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)),
                                0x00FFFF,
                                'success'
                            );
                            
                            // No collision - continue to next obstacle
                            return;
                        } else if (gameState.playerAction === 'ducking') {
                            // Normal ducking success
                            console.log(`‚úÖ DUCK SUCCESS! Player ducked properly.`);
                        } else {
                            // Collision - not ducking and not high enough
                            console.log(`üí• DUCK COLLISION! Height: ${playerHeight.toFixed(1)}, needed: ${safeJumpHeight}`);
                            handleCollision(obstacle, obstacleBBox);
                            scene.remove(obstacle.mesh);
                            obstacles.splice(index, 1);
                            return;
                        }
                    }
                }
                
                // Near-miss detection (close but not colliding)
                const nearMissDistance = 0.3; // Units for near-miss threshold
                const isNearMiss = !isColliding && boundingBoxDistance(playerBBox, obstacleBBox) < nearMissDistance;
                
                if (isColliding) {
                    // Check if player can avoid this collision
                    let canAvoid = false;
                    let avoidanceType = '';
                    
                    // Enhanced avoidance logic with precise hitbox checking
                    switch (obstacle.type) {
                        case 'lowbarrier':
                        case 'jumpblock':
                        case 'hurdleset':
                            // Must be jumped - check if player is high enough to clear
                            if (gameState.playerAction === 'jumping' && 
                                playerBBox.min.y > obstacleBBox.max.y - 0.2) {
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'highbarrier':
                        case 'duckbeam':
                        case 'wallgap':
                            // Must be ducked - check if player is low enough to pass under
                            if (gameState.playerAction === 'ducking' && 
                                playerBBox.max.y < obstacleBBox.min.y + 0.2) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else if (gameState.playerAction === 'jumping') {
                                // EXPLICITLY HANDLE: Cannot jump over duck obstacles!
                                console.warn('Cannot jump over duck obstacles - collision!');
                                canAvoid = false;
                                // Mark obstacle as hit for score tracking
                                obstacle.hitPlayer = true;
                            } else {
                                canAvoid = false;
                            }
                            break;
                            
                        case 'spikes':
                            // Flexible - can jump over or duck under
                            if ((gameState.playerAction === 'jumping' && playerBBox.min.y > obstacleBBox.max.y - 0.2) ||
                                (gameState.playerAction === 'ducking' && playerBBox.max.y < obstacleBBox.min.y + 0.2)) {
                                canAvoid = true;
                                avoidanceType = gameState.playerAction === 'jumping' ? 'jump' : 'duck';
                            }
                            break;
                            
                        case 'rotatingblade':
                            // Rotating blades - can only be ducked under
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 0.8) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'swinginghammer':
                            // Swinging hammer - timing-based avoidance
                            // Check if hammer is in safe position
                            const hammerAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                            const isSafePosition = Math.abs(hammerAngle) < obstacle.swingAmplitude * 0.3; // Safe zone
                            
                            if (isSafePosition) {
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && Math.abs(hammerAngle) > obstacle.swingAmplitude * 0.7) {
                                // Can duck under when hammer is at extreme positions
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'movingwall':
                            // Moving wall - must time movement or jump
                            const wallPosition = obstacle.mesh.position.x;
                            const playerPosition = LANE_POSITIONS[gameState.playerLane];
                            const wallDistance = Math.abs(wallPosition - playerPosition);
                            
                            if (wallDistance > 1.0) {
                                // Wall is far enough away
                                canAvoid = true;
                                avoidanceType = 'dodge';
                            } else if (gameState.playerAction === 'jumping' && playerBBox.min.y > 1.5) {
                                // Can jump over the wall
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'bouncingball':
                            // Bouncing ball - timing-based avoidance or ducking
                            const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                            
                            if (ballHeight < 0.8) {
                                // Ball is low - can run through
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && ballHeight > 1.5) {
                                // Ball is high, player is ducking
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else if (gameState.playerAction === 'jumping' && ballHeight < 1.2 && playerBBox.min.y > ballHeight + 0.3) {
                                // Ball is medium height, player jumps over
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'spinninglaser':
                            // Spinning laser - only ducking helps
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 1.1) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                    }
                    
                    if (canAvoid) {
                        // SUCCESSFUL AVOIDANCE!
                        let bonusScore = 50;
                        
                        // Precision bonus - closer calls get more points
                        const precision = 1 - (boundingBoxDistance(playerBBox, obstacleBBox) / nearMissDistance);
                        bonusScore += Math.floor(precision * 25);
                        
                        if (avoidanceType === 'jump') bonusScore += 25; // Jump bonus
                        
                        addScore(bonusScore); // SAFE SCORE UPDATE
                        
                        // Enhanced audio feedback with precision
                        if (precision > 0.8) {
                            audioManager.play('success'); // Perfect avoidance
                        } else {
                            audioManager.playSpeedDependentSound('coin', gameState.speed / gameState.maxSpeed);
                        }
                        
                        // Spectacular success particle effects
                        const effectPos = obstacle.mesh.position.clone();
                        const effectColor = avoidanceType === 'jump' ? 0x00FF00 : 0x00FFFF;
                        
                        createParticleEffect(effectPos, effectColor, 'success');
                        
                        // Precision-based additional effects
                        if (precision > 0.8) {
                            // Perfect execution - extra sparkles
                            createParticleEffect(
                                effectPos.clone().add(new THREE.Vector3(0, 1, 0)),
                                0xFFD700,
                                'success'
                            );
                            // Mini camera zoom for perfect execution
                            cameraZoomEffect(1.1, 200);
                        }
                        
                        // Score popup with precision indicator
                        showScorePopup(bonusScore, effectPos, precision > 0.8 ? 'PERFECT!' : 'NICE!');
                        
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        
                    } else {
                        // COLLISION DETECTED!
                        handleCollision(obstacle, obstacleBBox);
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                    }
                    
                } else if (isNearMiss) {
                    // NEAR MISS BONUS!
                    handleNearMiss(obstacle, playerBBox, obstacleBBox);
                }
            });
            
            // Check collectible collisions
            gameState.activeCollectibles.forEach((collectible, index) => {
                const collectibleBBox = {
                    min: new THREE.Vector3(
                        collectible.mesh.position.x - 0.5,
                        collectible.mesh.position.y - 0.5,
                        collectible.mesh.position.z - 0.5
                    ),
                    max: new THREE.Vector3(
                        collectible.mesh.position.x + 0.5,
                        collectible.mesh.position.y + 0.5,
                        collectible.mesh.position.z + 0.5
                    )
                };
                
                if (boundingBoxIntersection(playerBBox, collectibleBBox)) {
                    // Collected!
                    if (collectible.type === 'apple') {
                        gameState.collectedApples++;
                        addScore(50);
                        audioManager.play('collect');
                    } else if (collectible.type === 'broccoli') {
                        gameState.collectedBroccolis++;
                        addScore(100);
                        audioManager.play('collect');
                    }
                    
                    // Visual effect
                    createParticleEffect(
                        collectible.mesh.position.clone(),
                        collectible.type === 'apple' ? 0xFF0000 : 0x00FF00,
                        'collect'
                    );
                    
                    // Remove collectible
                    scene.remove(collectible.mesh);
                    gameState.activeCollectibles.splice(index, 1);
                }
            });
        }
        
        // Calculate precise player bounding box based on current action
        function calculatePlayerBoundingBox() {
            const playerX = LANE_POSITIONS[gameState.playerLane];
            const playerY = gameState.playerY;
            
            let width = 0.8;  // Player width
            let height = 1.5; // Player height
            let depth = 0.6;  // Player depth
            
            // Adjust hitbox based on action
            if (gameState.playerAction === 'ducking') {
                height = 0.6;
                depth = 0.8; // Slightly larger depth when ducking
            } else if (gameState.playerAction === 'jumping') {
                // Tighter hitbox when jumping for more precise collision
                width = 0.7;
                depth = 0.5;
            }
            
            return {
                min: new THREE.Vector3(
                    playerX - width/2,
                    playerY,
                    -depth/2
                ),
                max: new THREE.Vector3(
                    playerX + width/2,
                    playerY + height,
                    depth/2
                )
            };
        }
        
        // Calculate obstacle bounding box based on type and mesh
        function calculateObstacleBoundingBox(obstacle) {
            const pos = obstacle.mesh.position;
            let width, height, depth;
            
            // Obstacle-specific bounding box dimensions
            switch (obstacle.type) {
                case 'lowbarrier':
                    width = 1.5; height = 0.8; depth = 0.3;
                    break;
                case 'highbarrier':
                    width = 1.8; height = 0.4; depth = 0.3;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'jumpblock':
                    width = 1.2; height = 1.2; depth = 1.2;
                    break;
                case 'spikes':
                    width = 0.5; height = 0.6; depth = 0.5;
                    break;
                case 'duckbeam':
                    width = 2.2; height = 0.3; depth = 0.8;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'hurdleset':
                    width = 1.4; height = 0.7; depth = 1.5; // Covers multiple hurdles
                    break;
                case 'wallgap':
                    width = 1.8; height = 1.3; depth = 0.4;
                    // Gap height consideration
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.3, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 2.5, pos.z + depth/2)
                    };
                case 'rotatingblade':
                    // Dynamic hitbox based on rotation - always dangerous
                    width = 2.2; height = 2; depth = 0.4;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'swinginghammer':
                    // Dynamic hitbox for swinging hammer - wider danger zone
                    width = 2.5; height = 1.8; depth = 0.8;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'movingwall':
                    // Moving wall uses actual position
                    width = 0.4; height = 2; depth = 1;
                    break;
                case 'bouncingball':
                    // Dynamic hitbox based on ball position
                    const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                    width = 1.2; height = ballHeight + 0.6; depth = 1.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'spinninglaser':
                    // Laser beam danger zone - wider when spinning
                    width = 3.2; height = 1.4; depth = 3.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.1, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.3, pos.z + depth/2)
                    };
                default:
                    width = 1.0; height = 1.0; depth = 1.0;
            }
            
            return {
                min: new THREE.Vector3(
                    pos.x - width/2,
                    pos.y,
                    pos.z - depth/2
                ),
                max: new THREE.Vector3(
                    pos.x + width/2,
                    pos.y + height,
                    pos.z + depth/2
                )
            };
        }
        
        // Check if two 3D bounding boxes intersect
        function boundingBoxIntersection(bbox1, bbox2) {
            return (bbox1.min.x <= bbox2.max.x && bbox1.max.x >= bbox2.min.x) &&
                   (bbox1.min.y <= bbox2.max.y && bbox1.max.y >= bbox2.min.y) &&
                   (bbox1.min.z <= bbox2.max.z && bbox1.max.z >= bbox2.min.z);
        }
        
        // Calculate minimum distance between two bounding boxes
        function boundingBoxDistance(bbox1, bbox2) {
            const dx = Math.max(0, Math.max(bbox1.min.x - bbox2.max.x, bbox2.min.x - bbox1.max.x));
            const dy = Math.max(0, Math.max(bbox1.min.y - bbox2.max.y, bbox2.min.y - bbox1.max.y));
            const dz = Math.max(0, Math.max(bbox1.min.z - bbox2.max.z, bbox2.min.z - bbox1.max.z));
            
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // Enhanced collision handling with type-specific effects
        function handleCollision(obstacle, obstacleBBox) {
            // Slow motion for dramatic effect
            startSlowMotion(1000);
            
            // Type-specific collision audio
            audioManager.play('collision');
            
            // Lose life
            loseLife();
            
            // Enhanced collision effects based on obstacle material
            const collisionPos = obstacle.mesh.position.clone();
            let effectColor = 0xFF4444;
            
            switch (obstacle.type) {
                case 'jumpblock':
                case 'wallgap':
                    effectColor = 0x888888; // Concrete dust
                    break;
                case 'duckbeam':
                    effectColor = 0x4682B4; // Metal sparks
                    break;
                case 'spikes':
                    effectColor = 0xFF4500; // Fire/sparks
                    break;
            }
            
            // Main explosion with material-appropriate color
            createParticleEffect(collisionPos, effectColor, 'explosion');
            
            // Multiple secondary explosions for dramatic effect
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 1,
                        (Math.random() - 0.5) * 1
                    );
                    createParticleEffect(
                        collisionPos.clone().add(offset),
                        effectColor,
                        'explosion'
                    );
                }, i * 150);
            }
            
            // Screen shake intensity based on obstacle size
            const shakeIntensity = Math.min(0.5, (obstacleBBox.max.y - obstacleBBox.min.y) * 0.3);
            screenShake(shakeIntensity, 600);
            
            // Camera zoom for impact
            cameraZoomEffect(1.25, 400);
        }
        
        // Near-miss detection and bonus system
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            // Prevent multiple near-miss triggers for same obstacle
            if (obstacle.nearMissTriggered) return;
            obstacle.nearMissTriggered = true;
            
            // Calculate how close the call was
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const nearMissBonus = Math.floor((0.3 - distance) * 100); // Closer = more points
            
            addScore(nearMissBonus); // SAFE SCORE UPDATE
            
            // Near-miss audio feedback
            audioManager.play('nearmiss');
            
            // Visual feedback for near miss
            const effectPos = obstacle.mesh.position.clone();
            createParticleEffect(effectPos, 0xFFFF00, 'nearmiss'); // Yellow sparkles
            
            // Show near-miss popup
            showScorePopup(nearMissBonus, effectPos, 'CLOSE!');
        }
        
        // Update animations for moving obstacles
        function updateMovingObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                obstacle.animationTime += deltaTime * 0.001; // Convert to seconds
                
                switch (obstacle.type) {
                    case 'rotatingblade':
                        // Rotate the blade group
                        const bladeGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (bladeGroup) {
                            bladeGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                            
                            // Add warning sound for fast rotating blades
                            if (obstacle.rotationSpeed > 4 && Math.random() > 0.98) {
                                audioManager.createNoise(0.02, 800 + Math.random() * 400);
                            }
                        }
                        break;
                        
                    case 'swinginghammer':
                        // Swing the hammer arm
                        const hammerGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (hammerGroup) {
                            const armGroup = hammerGroup.children.find(child => child.type === 'Group');
                            if (armGroup) {
                                const swingAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                                armGroup.rotation.z = swingAngle;
                                
                                // Add swoosh sound at swing extremes
                                if (Math.abs(swingAngle) > obstacle.swingAmplitude * 0.8 && Math.random() > 0.95) {
                                    audioManager.createNoise(0.03, 1200 + Math.abs(swingAngle) * 500);
                                }
                            }
                        }
                        break;
                        
                    case 'movingwall':
                        // Move the wall side to side
                        const movingWall = obstacle.mesh.children[0];
                        if (movingWall) {
                            const movement = Math.sin(obstacle.animationTime * obstacle.movementSpeed) * obstacle.movementRange;
                            obstacle.mesh.position.x = obstacle.initialX + movement;
                            
                            // Add mechanical sound when changing direction
                            const prevMovement = Math.sin((obstacle.animationTime - deltaTime * 0.001) * obstacle.movementSpeed) * obstacle.movementRange;
                            if (Math.sign(movement) !== Math.sign(prevMovement) && Math.random() > 0.9) {
                                audioManager.createTone(150, 0.1, 'square');
                            }
                        }
                        break;
                        
                    case 'bouncingball':
                        // Bounce the ball up and down with realistic physics
                        const ballGroup = obstacle.mesh.children[0];
                        if (ballGroup) {
                            const ball = ballGroup.children[0]; // The actual ball
                            const shadow = ballGroup.children[1]; // Ground shadow
                            const ring = ballGroup.children[2]; // Warning ring
                            
                            if (ball && shadow && ring) {
                                // Bouncing motion using sine wave with gravity simulation
                                const bouncePhase = obstacle.animationTime * obstacle.bounceSpeed;
                                const bounceHeight = Math.abs(Math.sin(bouncePhase)) * obstacle.bounceHeight;
                                ball.position.y = 0.6 + bounceHeight; // 0.6 is ball radius
                                
                                // Scale shadow based on height (higher = smaller shadow)
                                const shadowScale = 1 - (bounceHeight / obstacle.bounceHeight) * 0.3;
                                shadow.scale.set(shadowScale, 1, shadowScale);
                                
                                // Pulse warning ring
                                const ringPulse = 1 + Math.sin(obstacle.animationTime * 8) * 0.2;
                                ring.scale.set(ringPulse, 1, ringPulse);
                                
                                // Add bounce sound at impact
                                if (bounceHeight < 0.2 && Math.random() > 0.97) {
                                    audioManager.createTone(200 + Math.random() * 100, 0.1, 'square');
                                }
                            }
                        }
                        break;
                        
                    case 'spinninglaser':
                        // Spin the laser beams and pulse warning lights
                        const laserGroup = obstacle.mesh.children[0];
                        if (laserGroup) {
                            const laserBeamGroup = laserGroup.children.find(child => child.type === 'Group');
                            
                            if (laserBeamGroup) {
                                // Rotate laser beams
                                laserBeamGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                                
                                // Pulse warning lights
                                const pulseFactor = (Math.sin(obstacle.animationTime * obstacle.pulseSpeed) + 1) / 2;
                                laserGroup.children.forEach(child => {
                                    if (child.geometry && child.geometry.type === 'SphereGeometry') {
                                        child.material.emissive.setHex(pulseFactor > 0.5 ? 0x440000 : 0x220000);
                                    }
                                });
                                
                                // Add laser whir sound
                                if (obstacle.rotationSpeed > 2.5 && Math.random() > 0.98) {
                                    audioManager.createNoise(0.02, 1500 + Math.random() * 500);
                                }
                            }
                        }
                        break;
                }
            });
        }

        function showScorePopup(score, position) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#00FF00';
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.fillText(`+${score}`, 64, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            
            sprite.position.copy(position);
            sprite.position.y += 2;
            sprite.scale.set(2, 1, 1);
            scene.add(sprite);
            
            // Animate popup
            const startY = sprite.position.y;
            const animatePopup = () => {
                sprite.position.y += 0.05;
                sprite.material.opacity -= 0.02;
                
                if (sprite.material.opacity > 0) {
                    requestAnimationFrame(animatePopup);
                } else {
                    scene.remove(sprite);
                }
            };
            animatePopup();
        }

        function loseLife() {
            gameState.lives--;
            
            // Make player invulnerable for 2 seconds
            gameState.invulnerable = true;
            gameState.invulnerabilityTime = 2000;
            
            // Visual feedback - make player flash red
            player.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0xFF6B6B);
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            
            if (gameState.lives <= 0) {
                endGame();
            }
        }

        // Smooth linear interpolation function
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        // Enhanced environment movement with parallax and smooth speed
        function updateEnvironmentMovement(deltaTime) {
            // Smooth speed interpolation
            visualSpeed = lerp(visualSpeed, gameState.speed, SPEED_LERP_FACTOR);
            
            // Move all environment objects with parallax effect
            Object.keys(environmentObjects).forEach(category => {
                environmentObjects[category].forEach((obj, index) => {
                    if (obj && obj.userData) {
                        const parallaxSpeed = visualSpeed * obj.userData.parallaxSpeed;
                        obj.position.z += parallaxSpeed;
                        
                        // Reset object position when it goes too far
                        if (obj.position.z > 50) {
                            // Calculate new spawn position based on object type
                            let resetDistance = -150;
                            if (obj.userData.type === 'building') {
                                resetDistance = -200 - Math.random() * 50;
                            } else if (obj.userData.type === 'streetLamp') {
                                resetDistance = -120;
                            } else if (obj.userData.type === 'streetLine') {
                                resetDistance = -120;
                            }
                            
                            obj.position.z = resetDistance;
                            
                            // Add some variation for buildings
                            if (obj.userData.type === 'building') {
                                // Randomize building properties
                                const side = obj.position.x < 0 ? 'left' : 'right';
                                const baseX = side === 'left' ? -15 : 15;
                                obj.position.x = baseX + (Math.random() - 0.5) * 8;
                                
                                // Update parallax speed slightly for variation
                                obj.userData.parallaxSpeed = 0.7 + Math.random() * 0.2;
                            }
                        }
                    }
                });
            });
        }
        
        // Dynamic audio system that responds to speed
        let lastEngineTime = 0;
        function updateDynamicAudio() {
            const currentTime = performance.now();
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Engine sound every 800ms, pitch increases with speed
            if (currentTime - lastEngineTime > 800) {
                audioManager.play('engine');
                lastEngineTime = currentTime;
            }
            
            // High-speed wind effects
            if (speedRatio > 0.7 && Math.random() > 0.95) {
                // Occasional high-speed wind whoosh
                audioManager.createNoise(0.08, 4000 + speedRatio * 2000);
            }
            
            // Master volume adjustment based on speed for intensity
            const baseVolume = 0.3;
            const speedVolume = baseVolume * (0.8 + speedRatio * 0.4);
            if (audioManager.audioContext && audioManager.masterGain) {
                audioManager.masterGain.gain.setValueAtTime(speedVolume, audioManager.audioContext.currentTime);
            }
        }
        
        // Enhanced motion blur effect at high speeds
        function updateVisualEffects() {
            const speedRatio = visualSpeed / gameState.maxSpeed;
            
            // Dynamic fog based on speed
            if (scene.fog) {
                scene.fog.near = 20 - speedRatio * 10; // Closer fog at high speed
                scene.fog.far = 60 + speedRatio * 20; // Extended range
            }
            
            // Camera FOV effect for speed sensation
            const baseFov = 60;
            const speedFov = baseFov + speedRatio * 15; // Wider FOV at high speed
            camera.fov = lerp(camera.fov, speedFov, 0.02);
            camera.updateProjectionMatrix();
            
            // Enhanced camera shake at high speeds
            if (speedRatio > 0.7) {
                const shakeIntensity = (speedRatio - 0.7) * 0.1;
                gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, shakeIntensity);
            }
        }
        
        // Alias for test compatibility
        const gameLoop = animate;
        const GameCore = { LevelManager };
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Calculate delta time for smooth movement
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            // STABILITY: Reset score counter each frame
            gameState.scoreThisFrame = 0;
            gameState.frameCount++;
            
            // STABILITY: Health monitoring every 5 seconds
            if (currentTime - gameState.lastHealthCheck > LIMITS.HEALTH_CHECK_INTERVAL) {
                gameState.lastHealthCheck = currentTime;
                performHealthCheck();
            }
            
            if (gameState.isPlaying) {
                // Update player position
                const targetX = LANE_POSITIONS[gameState.playerLane];
                player.position.x += (targetX - player.position.x) * 0.1;
                
                // Handle jumping - TRULY SMOOTH LANDING with parabolic descent
                if (gameState.playerAction === 'jumping') {
                    const deltaTime = 0.016;
                    
                    // Update vertical position
                    gameState.playerY += gameState.jumpVelocity * deltaTime;
                    
                    // Dynamic gravity based on height and velocity
                    let gravityStrength = 30; // Base gravity
                    
                    // Increase gravity when falling (negative velocity)
                    if (gameState.jumpVelocity < 0) {
                        // Apply air resistance for more realistic fall
                        const fallMultiplier = 1.3; // Makes falling slightly faster than rising
                        gravityStrength *= fallMultiplier;
                        
                        // Near ground - apply landing smoothing
                        if (gameState.playerY < 2.0) {
                            // Gradual gravity reduction near ground for soft landing
                            const landingFactor = gameState.playerY / 2.0; // 0 to 1 as we approach ground
                            gravityStrength *= (0.5 + landingFactor * 0.5); // Reduce gravity by up to 50%
                            
                            // Also apply velocity damping for extra smoothness
                            if (gameState.playerY < 1.0) {
                                gameState.jumpVelocity *= 0.95; // Slow down fall near ground
                            }
                        }
                    }
                    
                    // Apply gravity
                    gameState.jumpVelocity -= gravityStrength * deltaTime;
                    
                    // Terminal velocity cap (prevents too fast falling)
                    if (gameState.jumpVelocity < -25) {
                        gameState.jumpVelocity = -25;
                    }
                    
                    // ABSOLUTE TIMEOUT CHECK
                    const jumpDuration = performance.now() - gameState.jumpStartTime;
                    const shouldForceLand = jumpDuration > gameState.maxJumpDuration;
                    
                    // Check for landing
                    if (gameState.playerY <= 0) {
                        // Smooth final touchdown
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                        gameState.jumpStartTime = 0;
                        gameState.jumpCount = 0;
                        gameState.aerialCombo = 0;
                    } else if (shouldForceLand) {
                        // Forced landing - accelerate descent smoothly
                        if (gameState.playerY > 0.5) {
                            // Still high - increase downward velocity gradually
                            gameState.jumpVelocity = Math.min(gameState.jumpVelocity - 2, -15);
                        } else {
                            // Close to ground - land immediately
                            gameState.playerY = 0;
                            gameState.jumpVelocity = 0;
                            gameState.playerAction = 'running';
                            gameState.jumpStartTime = 0;
                            gameState.jumpCount = 0;
                            gameState.aerialCombo = 0;
                            
                            // Landing Audio & Visual - only when actually landing
                            audioManager.play('land');
                        
                            // Debug log if forced landing
                            if (shouldForceLand && gameState.playerY > 0) {
                                console.warn('‚ö†Ô∏è Jump timeout triggered - forced landing!');
                            }
                            
                            // Landing-Partikel
                            createParticleEffect(
                                new THREE.Vector3(player.position.x, 0.1, player.position.z),
                                0xAAAAAA,
                                'landing'
                            );
                        }
                        
                        // Mini screen shake for landing
                        screenShake(0.05, 100);
                    }
                }
                
                // Handle ducking
                if (gameState.playerAction === 'ducking') {
                    player.scale.y = 0.5;
                } else {
                    player.scale.y = 1;
                }
                
                player.position.y = gameState.playerY;
                
                // Handle invulnerability
                if (gameState.invulnerable) {
                    gameState.invulnerabilityTime -= 16; // ~16ms per frame at 60fps
                    
                    // Flash effect
                    const flashRate = Math.sin(Date.now() * 0.02) > 0;
                    player.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = flashRate ? 0.3 : 0.7;
                        }
                    });
                    
                    if (gameState.invulnerabilityTime <= 0) {
                        gameState.invulnerable = false;
                        // Restore normal player appearance
                        player.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = 1.0;
                                child.material.transparent = false;
                            }
                        });
                        // Restore original colors
                        if (player.children[0]) player.children[0].material.color.setHex(0x4A90E2); // Body
                        if (player.children[1]) player.children[1].material.color.setHex(0xF5B041); // Head
                    }
                }
                
                // Move track with smooth speed
                track.children.forEach(segment => {
                    segment.position.z += visualSpeed;
                    if (segment.position.z > 10) {
                        segment.position.z -= 100;
                    }
                });
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update current level
                LevelManager.update(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Move obstacles with smooth speed
                obstacles.forEach((obstacle, index) => {
                    obstacle.mesh.position.z += visualSpeed;
                    obstacle.z = obstacle.mesh.position.z;
                    
                    if (obstacle.z > 10) {
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        // Only give score if obstacle was properly avoided (not hit)
                        if (!obstacle.hitPlayer) {
                            addScore(10); // SAFE SCORE UPDATE
                        }
                    }
                });
                
                // Move and cleanup collectibles
                gameState.activeCollectibles = gameState.activeCollectibles.filter(collectible => {
                    collectible.mesh.position.z += visualSpeed;
                    
                    // Gentle floating animation
                    collectible.mesh.position.y += Math.sin(Date.now() * 0.003 + collectible.mesh.position.x) * 0.01;
                    collectible.mesh.rotation.y += 0.02; // Slow rotation
                    
                    if (collectible.mesh.position.z > 10) {
                        scene.remove(collectible.mesh);
                        return false; // Remove from array
                    }
                    return true;
                });
                
                // Spawn collectibles with 4-second interval
                spawnCollectible();
                
                // Spawn obstacles - REDUCED frequency for better balance
                const baseSpawnRate = 0.008; // Reduced from 0.012 (33% less obstacles)
                const spawnSpeedMultiplier = 1 + (gameState.speed / gameState.maxSpeed) * 1.0; // Reduced from 1.5
                const spawnRate = baseSpawnRate * spawnSpeedMultiplier;
                
                if (Math.random() < spawnRate) {
                    const jumpObstacles = ['lowbarrier', 'jumpblock', 'hurdleset'];
                    const duckObstacles = ['highbarrier', 'duckbeam', 'wallgap'];
                    const flexibleObstacles = ['spikes'];
                    const movingObstacles = ['rotatingblade', 'swinginghammer', 'movingwall', 'bouncingball', 'spinninglaser'];
                    
                    let type;
                    const rand = Math.random();
                    const speedRatio = gameState.speed / gameState.maxSpeed;
                    
                    // Increase moving obstacle chance as speed increases
                    const movingChance = 0.05 + speedRatio * 0.15; // 5% to 20% chance
                    
                    if (rand < movingChance) {
                        // Moving obstacles (more frequent at higher speeds)
                        type = movingObstacles[Math.floor(Math.random() * movingObstacles.length)];
                    } else if (rand < 0.4 + movingChance) {
                        // Jump obstacles
                        type = jumpObstacles[Math.floor(Math.random() * jumpObstacles.length)];
                    } else if (rand < 0.8 + movingChance) {
                        // Duck obstacles
                        type = duckObstacles[Math.floor(Math.random() * duckObstacles.length)];
                    } else {
                        // Flexible obstacles
                        type = flexibleObstacles[Math.floor(Math.random() * flexibleObstacles.length)];
                    }
                    
                    const lane = Math.floor(Math.random() * 3);
                    createObstacle(type, lane, -30);
                }
                
                // Update camera with shake effect
                const baseX = player.position.x * 0.3;
                const baseY = 3 + Math.sin(Date.now() * 0.002) * 0.05;
                const baseZ = 8;
                
                // Apply screen shake
                const shakeX = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeY = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeZ = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 0.5;
                
                camera.position.x += (baseX + shakeX - camera.position.x) * 0.05;
                camera.position.y = baseY + shakeY;
                camera.position.z = baseZ + shakeZ;
                
                camera.lookAt(player.position.x * 0.2, 1, -3);
                
                // Update game timer
                const currentTime = Date.now();
                const elapsedTime = (currentTime - gameState.gameStartTime) / 1000;
                gameState.timeRemaining = Math.max(0, gameState.gameTime - elapsedTime);
                
                // Check for victory (survived 60 seconds!)
                if (gameState.timeRemaining <= 0 && !gameState.isVictory && !gameState.isGameOver) {
                    console.log('Victory condition met - calling victoryGame()');
                    victoryGame();
                    return;
                }
                
                // Progressive speed increase - exponential curve for dramatic effect
                const timeProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 to 1
                const speedMultiplier = 1 + Math.pow(timeProgress, 1.5) * 4.5; // 1x to 5.5x speed
                gameState.speed = gameState.baseSpeed * speedMultiplier;
                gameState.speed = Math.min(gameState.speed, gameState.maxSpeed);
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update current level
                LevelManager.update(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Update dynamic audio based on speed
                updateDynamicAudio();
                
                // Update moving obstacles animations
                updateMovingObstacles(deltaTime);
                
                // Check collisions
                checkCollisions();
                
                updateUI();
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const canvas = document.getElementById('gameCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        // Event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        // Gesture Control Integration with Dynamic Loading
        let gestureController = null;
        let gestureEnabled = false;
        let gestureModuleLoaded = false;
        
        const gestureBtn = document.getElementById('gestureControlBtn');
        const gestureCanvas = document.getElementById('gestureCanvas');
        const gestureStatus = document.getElementById('gestureStatus');
        const gestureStatusText = document.getElementById('gestureStatusText');
        const gestureCurrentText = document.getElementById('gestureCurrentText');
        
        // Check if gesture module is already loaded
        async function loadGestureModule() {
            if (gestureModuleLoaded || window.GestureControllerProjector) {
                gestureModuleLoaded = true;
                return true;
            }
            
            // Wait a bit for pre-loaded module
            await new Promise(resolve => setTimeout(resolve, 500));
            
            if (window.GestureControllerProjector) {
                gestureModuleLoaded = true;
                console.log('‚úÖ Gesture Module already loaded');
                return true;
            }
            
            // Try loading again if not available
            try {
                console.log('üéÆ Attempting to load Gesture Control Module...');
                const module = await import('./js/GestureControllerProjector.js');
                window.GestureControllerProjector = module.GestureControllerProjector || module.default;
                gestureModuleLoaded = true;
                console.log('‚úÖ Gesture Module loaded on demand');
                return true;
            } catch (error) {
                console.error('‚ùå Module loading failed:', error);
                return false;
            }
        }
        
        // Initialize gesture control button
        if (gestureBtn) {
            console.log('üéÆ Gesture Control Button found!');
            gestureBtn.style.display = 'block'; // Force visibility
            gestureBtn.style.visibility = 'visible';
            gestureBtn.addEventListener('click', async () => {
                if (!gestureEnabled) {
                    try {
                        // First ensure module is loaded
                        const moduleLoaded = await loadGestureModule();
                        if (!moduleLoaded) {
                            alert('Gestensteuerung konnte nicht geladen werden. Bitte Seite neu laden und erneut versuchen.');
                            return;
                        }
                        
                        // Initialize gesture controller
                        if (!gestureController && window.GestureControllerProjector) {
                            console.log('üéÆ Initializing Gesture Controller...');
                            gestureController = new window.GestureControllerProjector({
                                videoElement: document.getElementById('gestureVideo'),
                                canvasElement: gestureCanvas,
                                onGestureDetected: handleGestureInput,
                                onStatsUpdate: updateGestureStats,
                                onError: handleGestureError,
                                onCalibrationComplete: () => {
                                    console.log('‚úÖ Gesture calibration complete');
                                    gestureStatusText.textContent = 'Kalibriert';
                                },
                                debugMode: false,
                                projectorMode: true
                            });
                        }
                        
                        await gestureController.start();
                        gestureEnabled = true;
                        gestureBtn.textContent = 'üõë Gestensteuerung stoppen';
                        gestureBtn.classList.add('active');
                        gestureCanvas.classList.add('active');
                        gestureStatus.classList.add('active');
                        gestureStatusText.textContent = 'Aktiv';
                        console.log('‚úÖ Gesture Control activated successfully');
                        
                    } catch (error) {
                        console.error('‚ùå Failed to start gesture control:', error);
                        alert(`Gestensteuerung Fehler: ${error.message}\n\nBitte stelle sicher dass:\n1. Kamera-Zugriff erlaubt ist\n2. HTTPS verwendet wird\n3. Chrome/Edge Browser verwendet wird`);
                    }
                } else {
                    // Stop gesture control
                    if (gestureController) {
                        gestureController.stop();
                    }
                    gestureEnabled = false;
                    gestureBtn.textContent = 'üéÆ Gestensteuerung aktivieren';
                    gestureBtn.classList.remove('active');
                    gestureCanvas.classList.remove('active');
                    gestureStatus.classList.remove('active');
                    gestureStatusText.textContent = 'Gestoppt';
                    gestureCurrentText.textContent = 'NONE';
                }
            });
        } else {
            console.warn('‚ö†Ô∏è Gesture Control Button not found or module not available');
            console.log('Button element:', gestureBtn);
            console.log('Module loaded:', window.GestureControllerProjector);
        }
        
        function handleGestureInput(gesture) {
            if (!gameState.isPlaying) return;
            
            gestureCurrentText.textContent = gesture;
            
            switch (gesture) {
                case 'MOVE_LEFT':
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        updatePlayerPosition();
                        const speedMultiplier = gameState.score / 5000;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    break;
                    
                case 'MOVE_RIGHT':
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        updatePlayerPosition();
                        const speedMultiplier = gameState.score / 5000;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                    }
                    break;
                    
                case 'JUMP':
                    if (!gameState.isJumping && gameState.jumpCount < 2) {
                        gameState.isJumping = true;
                        gameState.jumpCount++;
                        gameState.jumpVelocity = config.jumpPower;
                        const speedMultiplier = gameState.score / 5000;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                    }
                    break;
                    
                case 'DUCK':
                    if (!gameState.isDucking && !gameState.isJumping) {
                        gameState.isDucking = true;
                        const speedMultiplier = gameState.score / 5000;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                    }
                    break;
                    
                case 'NONE':
                    if (gameState.isDucking) {
                        gameState.isDucking = false;
                    }
                    break;
            }
        }
        
        function updateGestureStats(stats) {
            // Optional: Update UI with gesture tracking stats
            if (stats.faceDetected && gestureStatusText) {
                gestureStatusText.textContent = `Aktiv (${stats.confidence ? (stats.confidence * 100).toFixed(0) : 0}%)`;
            }
        }
        
        function handleGestureError(error) {
            console.error('Gesture control error:', error);
            gestureStatusText.textContent = 'Fehler';
        }

        // Debug function for testing
        window.testFunction = function() {
            console.log('Test function works!');
        };
        
        // Gesture Control Debug Info
        window.debugGesture = function() {
            console.log('üéÆ === GESTURE CONTROL DEBUG INFO ===');
            console.log('Button Element:', document.getElementById('gestureControlBtn'));
            console.log('Canvas Element:', document.getElementById('gestureCanvas'));
            console.log('Video Element:', document.getElementById('gestureVideo'));
            console.log('Status Element:', document.getElementById('gestureStatus'));
            console.log('Module Loaded:', !!window.GestureControllerProjector);
            console.log('Controller Instance:', gestureController);
            console.log('Gesture Enabled:', gestureEnabled);
            
            // Check visibility
            const btn = document.getElementById('gestureControlBtn');
            if (btn) {
                const rect = btn.getBoundingClientRect();
                console.log('Button Position:', { top: rect.top, right: rect.right, width: rect.width, height: rect.height });
                console.log('Button Display:', window.getComputedStyle(btn).display);
                console.log('Button Visibility:', window.getComputedStyle(btn).visibility);
                console.log('Button Z-Index:', window.getComputedStyle(btn).zIndex);
            }
            console.log('=====================================');
        };
        
        // Auto-run debug on page load
        setTimeout(() => {
            console.log('üéÆ SubwayRunner V3.4-GESTURE-DEBUG loaded');
            window.debugGesture();
        }, 2000);

        // Initialize game when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM ready, starting game initialization...');
            init();
        });
    </script>
</body>
</html>