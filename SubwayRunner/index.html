<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subway Runner 3D - Challenge</title>
    <!-- BUGFIX: CSP headers to allow MediaPipe and other external resources -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdn.jsdelivr.net https://storage.googleapis.com; connect-src 'self' https://umvrurelsxpxmyzcvrcd.supabase.co https://storage.googleapis.com; worker-src 'self' blob:; img-src 'self' data: blob:; media-src 'self' blob:; font-src 'self' https://fonts.googleapis.com https://fonts.gstatic.com; style-src-elem 'self' 'unsafe-inline' https://fonts.googleapis.com;">
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <!-- MediaPipe CDN for Gesture Control -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            max-width: 133.33vh; /* 4:3 aspect ratio */
            max-height: 75vw;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #versionInfo {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #FFD700;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 999;
            background: rgba(0,0,0,0.8);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,215,0,0.5);
            font-family: monospace;
            line-height: 1.2;
        }
        
        /* Visual Enhancement Styles */
        .speed-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 50;
        }
        
        .speed-line {
            position: absolute;
            width: 2px;
            height: 100px;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0.6), rgba(255,255,255,0));
            animation: speedLineMove 0.3s linear;
        }
        
        @keyframes speedLineMove {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            to {
                transform: translateY(100vh);
                opacity: 0;
            }
        }
        
        .vignette-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%);
            z-index: 60;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .vignette-overlay.active {
            opacity: 1;
        }
        
        /* ENHANCED: Magnet Visual Effect - Blue/Magnetic Vignette */
        .magnet-vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(30, 144, 255, 0.3) 70%, rgba(0, 100, 200, 0.5) 100%);
            box-shadow: inset 0 0 100px rgba(30, 144, 255, 0.3);
            z-index: 61;
            opacity: 0;
            transition: opacity 0.5s;
            animation: magnetPulse 2s ease-in-out infinite;
        }

        @keyframes magnetPulse {
            0%, 100% { 
                filter: brightness(1) hue-rotate(0deg);
                box-shadow: inset 0 0 100px rgba(30, 144, 255, 0.3);
            }
            50% { 
                filter: brightness(1.2) hue-rotate(10deg);
                box-shadow: inset 0 0 120px rgba(30, 144, 255, 0.5);
            }
        }

        .magnet-vignette.active {
            opacity: 1;
        }
        
        /* UI Element Animations */
        .ui-glow {
            animation: uiGlow 2s ease-in-out infinite;
        }
        
        @keyframes uiGlow {
            0%, 100% {
                filter: drop-shadow(0 0 5px rgba(255,215,0,0.5));
            }
            50% {
                filter: drop-shadow(0 0 15px rgba(255,215,0,0.8));
            }
        }
        
        .ui-bounce {
            animation: uiBounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes uiBounce {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }
        
        /* Motion Blur Effect */
        .motion-blur {
            filter: blur(0px);
            transition: filter 0.2s;
        }
        
        .motion-blur.active {
            filter: blur(2px);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: right;
            z-index: 100;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        #menu h1 {
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        #menu button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #menu button:hover {
            background: #45a049;
        }
        
        #timer {
            font-size: 20px;
            margin-top: 5px;
        }
        
        .timer-warning {
            color: #FF4444 !important;
            animation: pulse 0.5s infinite;
        }
        
        .timer-critical {
            color: #FF0000 !important;
            animation: fastPulse 0.2s infinite;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes fastPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-20px); }
            60% { transform: translateY(-10px); }
        }
        
        /* Near Miss and Milestone displays positioning */
        #nearMissDisplay {
            position: absolute;
            top: 150px;
            right: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: pulse 0.5s ease-in-out;
        }
        
        #milestoneDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
        }
        
        #multiplierDisplay {
            opacity: 0.8;
        }
        
        .name-input-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 16px;
            z-index: 300;
            text-align: center;
            min-width: 350px;
            border: 2px solid #4CAF50;
        }
        
        .name-input-dialog input {
            width: 200px;
            padding: 10px;
            margin: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }
        
        .name-input-dialog button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .name-input-dialog button:hover {
            background: #45a049;
        }
        
        .name-input-dialog button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .highscore-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            min-width: 200px;
            font-size: 12px;
        }
        
        .highscore-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .highscore-entry.current-player {
            color: #4CAF50;
            font-weight: bold;
        }
        
        /* Gesture Control UI */
        #gestureControls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 200;
        }
        
        #gestureToggle {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #gestureToggle:hover {
            background: #00cc70;
            transform: translateY(-2px);
        }
        
        #gestureToggle.active {
            background: #ff4444;
            color: white;
        }
        
        #calibrateBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #calibrateBtn:hover {
            background: #45a049;
        }
        
        #calibrateBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #gestureStatus {
            color: #00ff88;
            font-weight: bold;
        }
        
        /* Video preview for gesture control */
        #gestureCanvas {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #00ff88;
            border-radius: 8px;
            background: #000;
            z-index: 150;
            display: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        #gestureCanvas.active {
            display: block;
        }
        
        /* Gesture indicator */
        .gesture-feedback {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 250;
        }
        
        .gesture-feedback.show {
            opacity: 1;
        }
        
        /* Trick System Announcer */
        #trickAnnouncer {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 300;
            pointer-events: none;
        }
        
        .trick-announcement {
            font-size: 60px;
            font-weight: bold;
            text-transform: uppercase;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px currentColor;
            animation: trickPop 1s ease-out;
            margin-bottom: 10px;
        }
        
        @keyframes trickPop {
            0% {
                transform: scale(0) rotate(-180deg);
                opacity: 0;
            }
            50% {
                transform: scale(1.3) rotate(10deg);
            }
            100% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
        }
        
        .trick-points {
            font-size: 36px;
            color: #FFD700;
            font-weight: bold;
            animation: slideUp 0.8s ease-out;
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        /* Mystery Box Gambling UI */
        #mysteryBoxUI {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 500;
            display: none;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5), inset 0 0 20px rgba(255, 215, 0, 0.2);
            min-width: 500px;
        }
        
        #mysteryBoxUI h2 {
            color: #FFD700;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            animation: pulse 1s infinite;
        }
        
        .gambling-options {
            display: flex;
            justify-content: space-around;
            margin-top: 30px;
            gap: 20px;
        }
        
        .gambling-button {
            padding: 20px 30px;
            font-size: 24px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }
        
        .gambling-button:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        .gambling-button.safe {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            color: white;
            border: 2px solid #229954;
        }
        
        .gambling-button.risk {
            background: linear-gradient(135deg, #f39c12, #f1c40f);
            color: #2c3e50;
            border: 2px solid #d68910;
        }
        
        .gambling-button.yolo {
            background: linear-gradient(135deg, #c0392b, #e74c3c);
            color: white;
            border: 2px solid #a93226;
            animation: yoloPulse 0.5s infinite;
        }
        
        @keyframes yoloPulse {
            0%, 100% {
                box-shadow: 0 0 10px rgba(231, 76, 60, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(231, 76, 60, 1), 0 0 50px rgba(231, 76, 60, 0.6);
            }
        }
        
        .gambling-odds {
            font-size: 14px;
            margin-top: 5px;
            opacity: 0.8;
        }
        
        .gambling-result {
            font-size: 48px;
            font-weight: bold;
            margin: 30px 0;
            opacity: 0;
            transform: scale(0);
            animation: resultReveal 1s ease-out forwards;
        }
        
        @keyframes resultReveal {
            to {
                opacity: 1;
                transform: scale(1) rotate(360deg);
            }
        }
        
        .gambling-stats {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            z-index: 200;
        }
        
        /* Power-Up Fusion UI */
        #fusionContainer {
            position: absolute;
            bottom: 120px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 150;
            pointer-events: none;
        }
        
        .fusion-slot {
            width: 80px;
            height: 80px;
            border: 3px dashed rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            background: rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            pointer-events: auto;
            cursor: pointer;
        }
        
        .fusion-slot.filled {
            border-color: #4ECDC4;
            background: rgba(78, 205, 196, 0.2);
            animation: fusionPulse 1s ease-in-out infinite;
        }
        
        .fusion-slot.ready {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        @keyframes fusionPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .fusion-combine-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FFD700, #FF6B6B);
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
            display: none;
            align-self: center;
            animation: fusionRotate 3s linear infinite;
            pointer-events: auto;
        }
        
        .fusion-combine-btn.active {
            display: block;
        }
        
        @keyframes fusionRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Adrenaline Mode Effects */
        #adrenalineOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0, 100, 255, 0.3) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 90;
        }
        
        #adrenalineOverlay.active {
            opacity: 1;
            animation: adrenalinePulse 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes adrenalinePulse {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }
        
        #perfectStreakDisplay {
            position: absolute;
            top: 150px;
            right: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #00FFFF;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            z-index: 100;
            display: none;
        }
        
        #perfectStreakDisplay.active {
            display: block;
            animation: streakGlow 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes streakGlow {
            from { transform: scale(1); text-shadow: 0 0 10px rgba(0, 255, 255, 0.8); }
            to { transform: scale(1.1); text-shadow: 0 0 20px rgba(0, 255, 255, 1); }
        }
        
        .matrix-lines {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 91;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .matrix-lines.active {
            opacity: 0.7;
        }
        
        .matrix-line {
            position: absolute;
            width: 2px;
            height: 100px;
            background: linear-gradient(to bottom, transparent, #00FF00, transparent);
            animation: matrixFall 2s linear infinite;
        }
        
        @keyframes matrixFall {
            from { transform: translateY(-100px); }
            to { transform: translateY(100vh); }
        }
        
        /* FEATURE 7: Rampage Mode Effects */
        #rampageDisplay {
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8), 0 0 40px rgba(255, 0, 0, 0.5);
            animation: rampagePulse 0.5s ease-in-out infinite alternate;
        }
        
        @keyframes rampagePulse {
            from { transform: scale(1); filter: brightness(1); }
            to { transform: scale(1.05); filter: brightness(1.3); }
        }
        
        .rampage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(255, 0, 0, 0.2) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 89;
        }
        
        .rampage-overlay.active {
            opacity: 1;
            animation: rampageFlash 0.3s ease-in-out infinite alternate;
        }
        
        @keyframes rampageFlash {
            from { background: radial-gradient(ellipse at center, transparent 40%, rgba(255, 0, 0, 0.2) 100%); }
            to { background: radial-gradient(ellipse at center, transparent 40%, rgba(255, 100, 0, 0.3) 100%); }
        }
        
        /* FEATURE 8: Flight Mode Effects */
        #flightDisplay {
            text-shadow: 0 0 15px rgba(0, 204, 255, 0.8);
            animation: flightFloat 1s ease-in-out infinite;
        }
        
        /* FEATURE 9: Daily Challenge & Achievement Styles */
        .achievement-popup {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            border: 3px solid #FFD700;
            border-radius: 20px;
            padding: 30px 50px;
            text-align: center;
            z-index: 600;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            animation: achievementPop 0.5s ease-out;
        }
        
        @keyframes achievementPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(10deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }
        
        .achievement-icon {
            font-size: 72px;
            margin-bottom: 10px;
            animation: bounce 1s ease-in-out infinite;
        }
        
        .achievement-title {
            font-size: 28px;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            margin-bottom: 10px;
        }
        
        .achievement-description {
            font-size: 18px;
            color: #ECF0F1;
            margin-bottom: 15px;
        }
        
        .achievement-reward {
            font-size: 24px;
            color: #00FF00;
            font-weight: bold;
        }
        
        /* FEATURE 10: Roulette & Score Surge Styles */
        #rouletteModal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(ellipse at center, #2c3e50 0%, #000000 100%);
            border: 4px solid #FFD700;
            border-radius: 20px;
            padding: 40px;
            text-align: center;
            z-index: 700;
            display: none;
            min-width: 600px;
            box-shadow: 0 0 100px rgba(255, 215, 0, 0.5), inset 0 0 50px rgba(255, 215, 0, 0.2);
        }
        
        .roulette-wheel {
            width: 400px;
            height: 400px;
            margin: 20px auto;
            position: relative;
            border: 8px solid #FFD700;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                #FF0000 0deg 36deg,    /* 0.5x - Red */
                #FFA500 36deg 108deg,   /* 1x - Orange */
                #0000FF 108deg 216deg,  /* 2x - Blue */
                #00FF00 216deg 288deg,  /* 3x - Green */
                #FF00FF 288deg 324deg,  /* 5x - Purple */
                #FFD700 324deg 360deg   /* 10x - Gold */
            );
            transition: transform 4s cubic-bezier(0.17, 0.67, 0.83, 0.67);
        }
        
        .roulette-pointer {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 40px solid #FFD700;
            z-index: 10;
        }
        
        .roulette-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            background: #2c3e50;
            border: 4px solid #FFD700;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: #FFD700;
        }
        
        .roulette-segments {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .roulette-segment-text {
            position: absolute;
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        
        .spin-button {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            color: #000;
            border: none;
            padding: 20px 60px;
            font-size: 32px;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            transition: all 0.3s;
            box-shadow: 0 5px 20px rgba(255, 215, 0, 0.5);
        }
        
        .spin-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(255, 215, 0, 0.7);
        }
        
        .spin-button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        @keyframes rainbow {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        
        .score-token {
            animation: tokenFloat 2s ease-in-out infinite;
        }
        
        @keyframes tokenFloat {
            0%, 100% { transform: translateY(0) rotateY(0deg); }
            50% { transform: translateY(-10px) rotateY(180deg); }
        }
        
        @keyframes flightFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        .flight-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(135, 206, 235, 0.1) 0%, transparent 50%, rgba(135, 206, 235, 0.1) 100%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 88;
        }
        
        .flight-overlay.active {
            opacity: 1;
        }
        
        .altitude-meter {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #00CCFF;
            border-radius: 10px;
            display: none;
            z-index: 150;
        }
        
        .altitude-meter.active {
            display: block;
        }
        
        .altitude-indicator {
            position: absolute;
            width: 100%;
            height: 10%;
            background: #00CCFF;
            border-radius: 5px;
            bottom: 0;
            transition: height 0.2s ease;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Version Info Display -->
        <div id="versionInfo">
            🚀 V4.0.5-BALANCED<br>
            📅 07.07.2025
        </div>
        
        <!-- DevOps Monitoring Panel -->
        <div id="devopsPanel" style="
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            display: none;
            min-width: 200px;
            border: 1px solid #00ff00;
            z-index: 1000;
        ">
            <div style="font-weight: bold; margin-bottom: 5px;">🚀 DevOps Monitor</div>
            <div id="devopsFPS">FPS: --</div>
            <div id="devopsMemory">Memory: --</div>
            <div id="devopsErrors">Errors: 0</div>
            <div id="devopsFeatures">Features: --</div>
            <div id="devopsMode">Mode: Normal</div>
        </div>
        
        <!-- Visual Effects Overlays -->
        <div id="speedLines" class="speed-lines"></div>
        <div id="vignetteOverlay" class="vignette-overlay"></div>
        <div id="magnetVignette" class="magnet-vignette"></div>
        
        <!-- Adrenaline Mode Overlay -->
        <div id="adrenalineOverlay"></div>
        <div class="matrix-lines" id="matrixLines"></div>
        
        <!-- FEATURE 7: Rampage Mode Overlay -->
        <div class="rampage-overlay" id="rampageOverlay"></div>
        
        <!-- FEATURE 8: Flight Mode Overlay -->
        <div class="flight-overlay" id="flightOverlay"></div>
        <div class="altitude-meter" id="altitudeMeter">
            <div class="altitude-indicator" id="altitudeIndicator"></div>
        </div>
        
        <!-- Perfect Streak Display -->
        <div id="perfectStreakDisplay">
            <div>PERFECT STREAK: <span id="streakCount">0</span></div>
            <div id="adrenalineStatus" style="font-size: 18px; color: #FFD700;"></div>
        </div>
        
        <!-- Power-Up Fusion UI -->
        <div id="fusionContainer">
            <div class="fusion-slot" id="fusionSlot1" data-slot="1"></div>
            <button class="fusion-combine-btn" id="fusionCombineBtn">⚡</button>
            <div class="fusion-slot" id="fusionSlot2" data-slot="2"></div>
        </div>
        
        <!-- Gesture Control UI -->
        <div id="gestureControls">
            <button id="gestureToggle" onclick="toggleGestureControl()">🎥 Gesten aktivieren</button>
            <button id="calibrateBtn" onclick="calibrateGestures()" disabled>🎯 Kalibrieren</button>
            <span id="gestureStatus">Gesten: Inaktiv</span>
        </div>
        
        <!-- Gesture Feedback -->
        <div class="gesture-feedback" id="gestureFeedback"></div>
        
        <!-- Hidden video element for camera -->
        <video id="gestureVideo" style="display: none;" autoplay playsinline></video>
        
        <!-- Canvas for gesture preview -->
        <canvas id="gestureCanvas"></canvas>
        
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Speed: <span id="speed">100</span></div>
            <div>❤️ Leben: <span id="lives">3</span></div>
            <div id="timer">⏱️ Zeit: <span id="timeRemaining">60</span>s</div>
            
            <!-- NEW: Power-Up & Coins UI -->
            <div id="collectiblesCounter" style="color: #8BC34A; font-weight: bold;">
                🥝 <span id="kiwiCount">0</span>/30 | 🥦 <span id="broccoliCount">0</span>/7
                <div style="font-size: 12px; margin-top: 2px;">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; width: 60px; height: 8px; overflow: hidden;">
                            <div id="kiwiProgress" style="background: #FFD700; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; width: 40px; height: 8px; overflow: hidden;">
                            <div id="broccoliProgress" style="background: #8BC34A; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="comboDisplay" style="color: #FF6B35; display: none; font-size: 20px; animation: pulse 0.5s infinite;">
                COMBO x<span id="comboMultiplier">1</span>!
            </div>
            
            <!-- NEW: Near Miss Display -->
            <div id="nearMissDisplay" style="color: #FFD700; display: none; font-size: 18px; font-weight: bold;">
                NEAR MISS! x<span id="nearMissCount">1</span>
                <div style="font-size: 14px;">+<span id="nearMissBonus">50</span> Bonus!</div>
            </div>
            
            <!-- NEW: Milestone Display -->
            <div id="milestoneDisplay" style="color: #00FF00; display: none; font-size: 24px; font-weight: bold; animation: bounce 1s;">
                <span id="milestoneIcon">🏁</span> <span id="milestoneText">500m!</span>
                <div style="font-size: 16px;">+<span id="milestoneBonus">500</span> Punkte!</div>
            </div>
            
            <!-- NEW: Score Multiplier Display -->
            <div id="multiplierDisplay" style="color: #FF1493; font-size: 16px; font-weight: bold; margin-top: 5px;">
                Multiplikator: x<span id="currentMultiplier">1.0</span>
            </div>
            <div id="powerUpDisplay" style="color: #4ECDC4; display: none; font-weight: bold;">
                <span id="powerUpIcon">⚡</span> <span id="powerUpName">Speed</span>: <span id="powerUpTime">8</span>s
            </div>
            
            <!-- NEW: Skill Combo UI -->
            <div id="skillComboDisplay" style="color: #FF4500; display: none; font-size: 22px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                <span id="skillComboIcon">🔥</span> SKILL COMBO x<span id="skillComboCount">1</span>! 
                <div style="font-size: 14px; color: #FFD700;"><span id="skillComboBonus">+100</span> Punkte!</div>
            </div>
            
            <!-- NEW: Environment Display -->
            <div id="environmentDisplay" style="color: #87CEEB; font-weight: bold; margin-top: 10px;">
                🏙️ <span id="currentEnvironment">Straße</span>
            </div>
            
            <!-- NEW: Difficulty Progress Display -->
            <div id="difficultyDisplay" style="color: #FFB347; font-weight: bold; margin-top: 5px; font-size: 14px;">
                📈 Schwierigkeit: <span id="difficultyLevel">Leicht</span>
            </div>
            
            <!-- FEATURE 7: Rampage Mode Display -->
            <div id="rampageDisplay" style="color: #FF0000; display: none; font-weight: bold; margin-top: 10px; font-size: 20px;">
                💪 RAMPAGE MODE! <span id="rampageTime">10</span>s
                <div style="font-size: 14px;">Destruction Streak: <span id="destructionStreak">0</span></div>
            </div>
            
            <!-- FEATURE 8: Flight Mode Display -->
            <div id="flightDisplay" style="color: #00CCFF; display: none; font-weight: bold; margin-top: 10px;">
                🚀 FLIGHT MODE! <span id="flightTime">3</span>s
                <div style="font-size: 14px;">Altitude: <span id="flightAltitude">0</span>m</div>
                <div style="font-size: 12px; color: #87CEEB;">W/S to control altitude</div>
            </div>
            
            <!-- FEATURE 9: Daily Challenge Display -->
            <div id="dailyChallengeDisplay" style="color: #FFD700; display: none; font-weight: bold; margin-top: 10px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;">
                📅 Daily: <span id="challengeName">Loading...</span>
                <div style="font-size: 12px;">Progress: <span id="challengeProgress">0</span>/<span id="challengeTarget">0</span></div>
                <div id="challengeCompleteStatus" style="font-size: 14px; color: #00FF00; display: none;">✅ COMPLETE! +<span id="challengeReward">0</span></div>
            </div>
            
            <!-- FEATURE 10: Multiplier & Roulette Display - DISABLED (User wants NO coins) -->
            <div id="scoreTokenDisplay" style="color: #FFD700; display: none; font-weight: bold; margin-top: 5px;">
                🪙 Score Tokens: <span id="tokenCount">0</span>/3
                <div id="rouletteReady" style="font-size: 14px; color: #00FF00; display: none;">🎰 ROULETTE READY!</div>
            </div>
            <div id="surgeModeDisplay" style="color: #FF00FF; display: none; font-weight: bold; margin-top: 5px; font-size: 18px; animation: rainbow 2s linear infinite;">
                💎 SCORE SURGE MODE! x<span id="surgeMultiplier">2</span>
                <div style="font-size: 14px;">Time: <span id="surgeTime">15</span>s</div>
            </div>
        </div>
        
        <!-- Trick Announcer -->
        <div id="trickAnnouncer"></div>
        
        <!-- Mystery Box Gambling UI -->
        <div id="mysteryBoxUI">
            <h2>🎲 MYSTERY BOX 🎲</h2>
            <p style="color: #ECF0F1; font-size: 18px;">Choose your fate wisely!</p>
            <div class="gambling-options">
                <div>
                    <button class="gambling-button safe" onclick="chooseGamble('safe')">
                        <div>SAFE</div>
                        <div style="font-size: 16px;">+200 Points</div>
                    </button>
                    <div class="gambling-odds">Guaranteed! ✅</div>
                </div>
                <div>
                    <button class="gambling-button risk" onclick="chooseGamble('risk')">
                        <div>RISK</div>
                        <div style="font-size: 16px;">+800 / -300</div>
                    </button>
                    <div class="gambling-odds">50/50 Chance ⚖️</div>
                </div>
                <div>
                    <button class="gambling-button yolo" onclick="chooseGamble('yolo')">
                        <div>YOLO!</div>
                        <div style="font-size: 16px;">+2000 / ☠️</div>
                    </button>
                    <div class="gambling-odds">30% Win / 70% Death 💀</div>
                </div>
            </div>
            <div id="gamblingResult" class="gambling-result"></div>
        </div>
        
        <!-- Gambling Statistics -->
        <div id="gamblingStats" class="gambling-stats" style="display: none;">
            <div>🎰 Gambling Stats</div>
            <div>Wins: <span id="gamblingWins">0</span></div>
            <div>Losses: <span id="gamblingLosses">0</span></div>
            <div>Total Gambled: <span id="totalGambled">0</span></div>
        </div>
        
        <!-- FEATURE 9: Achievement Popup -->
        <div id="achievementPopup" class="achievement-popup" style="display: none;">
            <div class="achievement-icon" id="achievementIcon">🏆</div>
            <div class="achievement-title" id="achievementTitle">Achievement Unlocked!</div>
            <div class="achievement-description" id="achievementDescription">Description</div>
            <div class="achievement-reward">+<span id="achievementReward">0</span> Points!</div>
        </div>
        
        <!-- FEATURE 10: Roulette Modal -->
        <div id="rouletteModal">
            <h2 style="color: #FFD700; font-size: 36px; margin-bottom: 20px;">🎰 MULTIPLIER ROULETTE 🎰</h2>
            <p style="color: #ECF0F1; font-size: 18px; margin-bottom: 20px;">Spin to multiply your score!</p>
            
            <div class="roulette-wheel" id="rouletteWheel">
                <div class="roulette-pointer"></div>
                <div class="roulette-segments">
                    <div class="roulette-segment-text" style="top: 15%; left: 50%; transform: translateX(-50%);">10x</div>
                    <div class="roulette-segment-text" style="top: 25%; left: 75%; transform: translateX(-50%);">0.5x</div>
                    <div class="roulette-segment-text" style="top: 50%; left: 85%; transform: translateX(-50%);">1x</div>
                    <div class="roulette-segment-text" style="top: 75%; left: 75%; transform: translateX(-50%);">2x</div>
                    <div class="roulette-segment-text" style="top: 85%; left: 50%; transform: translateX(-50%);">3x</div>
                    <div class="roulette-segment-text" style="top: 75%; left: 25%; transform: translateX(-50%);">5x</div>
                </div>
                <div class="roulette-center">?</div>
            </div>
            
            <button class="spin-button" id="spinButton" onclick="spinRoulette()">SPIN!</button>
            <div id="rouletteResult" style="margin-top: 20px; font-size: 32px; color: #FFD700; font-weight: bold;"></div>
        </div>
        
        <div id="instructions">
            <div><strong>🎮 Steuerung:</strong></div>
            <div>A/D: Spurwechsel</div>
            <div>Leertaste/W: Springen 🦘</div>
            <div>S: Ducken 🦆</div>
            <div><strong>📱 Touch-Steuerung:</strong></div>
            <div>← → Wischen: Spurwechsel</div>
            <div>↑ Wischen: Springen</div>
            <div>↓ Wischen: Ducken</div>
            <div><strong>💡 Tipps:</strong></div>
            <div>🟠 Orange/Braun: Überspringen!</div>
            <div>🔵 Blau/Grau oben: Ducken!</div>
            <div>🔴 Stacheln: Beides möglich!</div>
            <div><strong>🎯 Neue Features:</strong></div>
            <div>⚡ Near-Miss Bonus!</div>
            <div>🏁 Meilenstein-Belohnungen!</div>
            <div>🔥 Combo-Multiplikator!</div>
        </div>
        
        <div id="menu">
            <h1>🚇 Subway Runner 3D</h1>
            <h2>⏱️ 60-Sekunden Challenge!</h2>
            <p>Überlebe 60 Sekunden bei stetig steigender Geschwindigkeit!</p>
            <p><strong>🎯 Ziel:</strong> 60 Sekunden überleben</p>
            <p><strong>⚡ Warnung:</strong> Wird sehr schnell!</p>
            <p><strong>🎮 Steuerung:</strong></p>
            <p>A/D: Spurwechsel | W/Space: Springen | S: Ducken</p>
            <button onclick="startGame()">🎮 Challenge starten!</button>
        </div>
        
        <div id="highscorePanel" class="highscore-panel">
            <div style="font-weight: bold; margin-bottom: 10px;">🏆 TOP 10</div>
            <div id="highscoreList">Lade Bestenliste...</div>
        </div>
        
        <div id="nameInputDialog" class="name-input-dialog" style="display: none;">
            <h2>🎉 Neuer Highscore!</h2>
            <p>Gib deinen Namen ein:</p>
            <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="20">
            <br>
            <button onclick="submitHighscore()">💾 Speichern</button>
            <button onclick="skipHighscore()">⏭️ Überspringen</button>
        </div>
    </div>

    <script>
        // Audio System
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.masterVolume = 0.3;
                this.backgroundMusic = null;
                this.musicVolume = 0.15; // Lower volume for background music
                this.musicGain = null;
                this.musicLoaded = false;
                this.musicPlaying = false;
                this.initAudio();
            }

            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Create separate gain node for background music
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.gain.value = this.musicVolume;
                    this.musicGain.connect(this.audioContext.destination);
                    
                    this.createAdvancedSounds();
                    
                    // Preload background music (but don't play yet)
                    this.preloadBackgroundMusic();
                } catch (error) {
                    console.log('Audio not supported');
                }
            }

            async preloadBackgroundMusic() {
                try {
                    console.log('🎵 Starting background music preload...');
                    // Try to load background music file (multiple formats)
                    const musicPaths = [
                        'sounds/background/background.mp3',
                        'sounds/background/background.wav',
                        'sounds/background/game-music.mp3',
                        'sounds/background/game-music.wav',
                        'sounds/background/subway-theme.mp3',
                        'sounds/background/subway-theme.wav'
                    ];
                    
                    for (let path of musicPaths) {
                        try {
                            console.log(`🎵 Trying to load background music: ${path}`);
                            const audio = new Audio(path);
                            audio.preload = 'metadata'; // Changed from 'auto' for large files
                            audio.loop = true;
                            audio.volume = 0; // Start silent
                            audio.crossOrigin = 'anonymous'; // Fix CORS issues
                            
                            // Test if file exists by trying to load it
                            await new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => {
                                    console.log(`⏰ Timeout loading: ${path}`);
                                    reject(new Error('Timeout'));
                                }, 10000); // 10 second timeout for large files
                                
                                audio.addEventListener('canplaythrough', () => {
                                    clearTimeout(timeout);
                                    console.log(`✅ Background music loaded: ${path}`);
                                    this.backgroundMusic = audio;
                                    this.musicLoaded = true;
                                    resolve();
                                });
                                audio.addEventListener('loadedmetadata', () => {
                                    console.log(`📊 Music metadata loaded: ${path} (${audio.duration}s)`);
                                });
                                audio.addEventListener('error', (e) => {
                                    clearTimeout(timeout);
                                    console.log(`❌ Audio error for ${path}:`, e);
                                    reject(e);
                                });
                                audio.load();
                            });
                            break; // If successful, stop trying other files
                        } catch (error) {
                            console.log(`❌ Failed to load: ${path}`);
                            continue; // Try next file
                        }
                    }
                    
                    if (!this.musicLoaded) {
                        console.log('🎵 No background music found - running without music');
                    }
                } catch (error) {
                    console.log('Background music preload failed:', error);
                }
            }

            startBackgroundMusic() {
                if (!this.backgroundMusic || !this.musicLoaded || this.musicPlaying) return;
                
                try {
                    this.backgroundMusic.currentTime = 0;
                    this.backgroundMusic.volume = this.musicVolume;
                    this.backgroundMusic.play();
                    this.musicPlaying = true;
                    
                    // Fade in effect
                    this.fadeInMusic();
                    console.log('🎵 Background music started');
                } catch (error) {
                    console.log('Failed to start background music:', error);
                }
            }

            stopBackgroundMusic() {
                if (!this.backgroundMusic || !this.musicPlaying) return;
                
                try {
                    this.fadeOutMusic(() => {
                        this.backgroundMusic.pause();
                        this.backgroundMusic.currentTime = 0;
                        this.musicPlaying = false;
                        console.log('🎵 Background music stopped');
                    });
                } catch (error) {
                    console.log('Failed to stop background music:', error);
                }
            }

            fadeInMusic(duration = 2000) {
                if (!this.backgroundMusic) return;
                
                const startVolume = 0;
                const endVolume = this.musicVolume;
                const steps = 20;
                const stepDuration = duration / steps;
                const volumeStep = (endVolume - startVolume) / steps;
                
                this.backgroundMusic.volume = startVolume;
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        if (this.backgroundMusic && this.musicPlaying) {
                            this.backgroundMusic.volume = Math.min(startVolume + (volumeStep * i), endVolume);
                        }
                    }, stepDuration * i);
                }
            }

            fadeOutMusic(callback, duration = 1000) {
                if (!this.backgroundMusic) return;
                
                const startVolume = this.backgroundMusic.volume;
                const steps = 20;
                const stepDuration = duration / steps;
                const volumeStep = startVolume / steps;
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        if (this.backgroundMusic) {
                            this.backgroundMusic.volume = Math.max(startVolume - (volumeStep * i), 0);
                            if (i === steps && callback) {
                                callback();
                            }
                        }
                    }, stepDuration * i);
                }
            }

            setMusicVolume(volume) {
                this.musicVolume = Math.max(0, Math.min(1, volume));
                if (this.backgroundMusic) {
                    this.backgroundMusic.volume = this.musicVolume;
                }
            }

            createTone(frequency, duration, type = 'sine', fadeOut = true) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                if (fadeOut) {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                } else {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                }
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            createNoise(duration, filterFreq = 1000) {
                if (!this.audioContext) return;
                
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const source = this.audioContext.createBufferSource();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();
                
                source.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;
                
                source.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                source.start();
            }

            createAdvancedSounds() {
                // Enhanced realistic sounds using multiple layers
                this.sounds = {
                    jump: () => {
                        // Multi-layered jump sound: impact + whoosh + landing prep
                        this.createTone(180, 0.08, 'sine'); // Base thump
                        setTimeout(() => this.createTone(320, 0.12, 'triangle'), 20); // Whoosh up
                        setTimeout(() => this.createNoise(0.06, 4000), 40); // Air resistance
                        this.createReverbEffect(240, 0.15, 0.3); // Echo for depth
                    },
                    
                    land: () => {
                        // Heavy landing with ground impact and dust
                        this.createTone(80, 0.15, 'square'); // Deep thud
                        this.createNoise(0.12, 800); // Ground crunch
                        setTimeout(() => this.createNoise(0.08, 1500), 50); // Dust settle
                        this.createReverbEffect(120, 0.2, 0.4); // Ground echo
                    },
                    
                    duck: () => {
                        // Quick duck sound with fabric/wind
                        this.createTone(140, 0.15, 'sawtooth');
                        this.createNoise(0.1, 3500); // Wind resistance
                        setTimeout(() => this.createTone(110, 0.1, 'sine'), 80); // Body movement
                    },
                    
                    success: () => {
                        // Triumphant success with harmonic progression
                        const notes = [400, 500, 630, 800, 1000];
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.2, 'sine');
                                this.createReverbEffect(freq, 0.15, 0.6); // Rich reverb
                            }, i * 80);
                        });
                        // Add sparkle effect
                        setTimeout(() => {
                            for (let j = 0; j < 8; j++) {
                                setTimeout(() => this.createTone(1200 + j * 100, 0.05, 'sine'), j * 25);
                            }
                        }, 400);
                    },
                    
                    collision: () => {
                        // Dramatic collision with multiple impact layers
                        this.createNoise(0.4, 1200); // Main crash
                        this.createTone(60, 0.6, 'sawtooth', false); // Low rumble
                        setTimeout(() => this.createNoise(0.25, 2500), 100); // Glass/debris
                        setTimeout(() => this.createTone(200, 0.3, 'square'), 150); // Metal impact
                        this.createReverbEffect(150, 0.8, 0.7); // Long echo
                        
                        // Add screen shake intensity based on collision
                        if (window.gameState) {
                            gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, 0.3);
                        }
                    },
                    
                    coin: () => {
                        // Magical kiwi collection with sparkle
                        this.createTone(800, 0.12, 'sine');
                        setTimeout(() => this.createTone(1200, 0.1, 'sine'), 40);
                        setTimeout(() => this.createTone(1600, 0.08, 'triangle'), 80);
                        this.createReverbEffect(1000, 0.2, 0.5); // Magical echo
                        // Add subtle high-frequency shimmer
                        setTimeout(() => {
                            for (let k = 0; k < 4; k++) {
                                setTimeout(() => this.createTone(2000 + k * 200, 0.03, 'sine'), k * 15);
                            }
                        }, 120);
                    },
                    
                    whoosh: () => {
                        // Enhanced lane change with speed-dependent pitch
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.5;
                        const baseFreq = 2000 + speedMultiplier * 2000;
                        this.createNoise(0.15 + speedMultiplier * 0.1, baseFreq);
                        this.createTone(250 + speedMultiplier * 100, 0.1, 'triangle');
                    },
                    
                    powerup: () => {
                        // Epic power-up activation sequence
                        const powerChord = [400, 500, 600, 750, 900];
                        powerChord.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.25, 'sine');
                                this.createReverbEffect(freq, 0.2, 0.8);
                            }, i * 60);
                        });
                        
                        // Add ascending energy effect
                        setTimeout(() => {
                            for (let m = 0; m < 12; m++) {
                                setTimeout(() => {
                                    this.createTone(1000 + m * 50, 0.04, 'triangle');
                                }, m * 30);
                            }
                        }, 300);
                    },
                    
                    // NEW: Ambient city sounds
                    ambient: () => {
                        if (!this.ambientPlaying) {
                            this.ambientPlaying = true;
                            this.playAmbientLoop();
                        }
                    },
                    
                    // NEW: Speed-based engine sound
                    engine: () => {
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.3;
                        const engineFreq = 40 + speedMultiplier * 60;
                        this.createTone(engineFreq, 0.2, 'sawtooth', false);
                    },
                    
                    // NEW: Near miss bonus sound
                    nearmiss: () => {
                        this.createTone(600, 0.08, 'sine');
                        setTimeout(() => this.createTone(800, 0.06, 'triangle'), 30);
                        this.createNoise(0.05, 5000); // Subtle whoosh
                    }
                };
            }

            // Enhanced reverb effect for depth
            createReverbEffect(frequency, duration, intensity) {
                if (!this.audioContext) return;
                
                const delay = this.audioContext.createDelay(0.3);
                const feedback = this.audioContext.createGain();
                const wetGain = this.audioContext.createGain();
                
                delay.delayTime.value = 0.1;
                feedback.gain.value = intensity * 0.4;
                wetGain.gain.value = intensity * 0.3;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(wetGain);
                wetGain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            // Ambient city soundscape
            playAmbientLoop() {
                if (!this.audioContext || !this.ambientPlaying) return;
                
                // Distant traffic rumble
                const trafficFreq = 60 + Math.random() * 20;
                this.createTone(trafficFreq, 2.0, 'sawtooth', false);
                
                // Occasional distant sounds
                if (Math.random() > 0.7) {
                    setTimeout(() => {
                        this.createNoise(0.05, 800 + Math.random() * 1000);
                    }, Math.random() * 1000);
                }
                
                // Continue ambient loop
                setTimeout(() => this.playAmbientLoop(), 2000);
            }
            
            stopAmbient() {
                this.ambientPlaying = false;
            }
            
            // Dynamic sound based on game speed
            playSpeedDependentSound(soundName, speedMultiplier = 1) {
                const originalVolume = this.masterGain.gain.value;
                const speedVolume = Math.min(originalVolume * (0.8 + speedMultiplier * 0.4), 1.0);
                
                this.masterGain.gain.value = speedVolume;
                this.play(soundName);
                
                // Restore original volume
                setTimeout(() => {
                    this.masterGain.gain.value = originalVolume;
                }, 200);
            }
            
            setPlaybackRate(rate) {
                // Simplified implementation - affects new sounds only
                // For a full implementation, we'd need to track all active sources
                this.playbackRate = rate || 1.0;
            }
            
            play(soundName) {
                if (this.sounds[soundName]) {
                    try {
                        this.sounds[soundName]();
                    } catch (error) {
                        console.warn('Audio playback error:', error);
                    }
                } else {
                    // BUGFIX: Silently ignore missing sound effects to prevent console spam
                    // console.log(`Sound effect '${soundName}' not available`);
                }
            }

            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        const audioManager = new AudioManager();
        audioManager.ambientPlaying = false;
        
        // ==================== MEMORY LEAK PREVENTION ====================
        window.MemoryManager = {
            maxSceneChildren: 500,
            cleanupInterval: null,
            
            init: function() {
                // Regular cleanup every 30 seconds
                this.cleanupInterval = setInterval(() => {
                    this.performCleanup();
                }, 30000);
            },
            
            performCleanup: function() {
                if (!scene) return;
                
                const currentChildren = scene.children.length;
                if (currentChildren > this.maxSceneChildren) {
                    console.warn(`⚠️ Scene has ${currentChildren} objects, performing cleanup...`);
                    
                    // Remove old particles
                    const particles = scene.children.filter(child => 
                        child.userData && child.userData.isParticle && 
                        Date.now() - (child.userData.createdAt || 0) > 5000
                    );
                    
                    particles.forEach(particle => {
                        scene.remove(particle);
                        if (particle.geometry) particle.geometry.dispose();
                        if (particle.material) particle.material.dispose();
                    });
                    
                    // Remove orphaned objects
                    const orphans = scene.children.filter(child => 
                        child.position && (child.position.z > 20 || child.position.z < -100)
                    );
                    
                    orphans.forEach(orphan => {
                        scene.remove(orphan);
                        if (orphan.geometry) orphan.geometry.dispose();
                        if (orphan.material) orphan.material.dispose();
                    });
                    
                    console.log(`✅ Cleaned up ${particles.length + orphans.length} objects`);
                }
            },
            
            dispose: function() {
                if (this.cleanupInterval) {
                    clearInterval(this.cleanupInterval);
                    this.cleanupInterval = null;
                }
            }
        };
        
        window.MemoryManager.init();
        
        // ==================== GAME RECOVERY SYSTEM ====================
        window.GameRecovery = {
            lastValidState: null,
            recoveryAttempts: 0,
            maxRecoveryAttempts: 3,
            
            saveState: function() {
                if (!gameState || !gameState.isPlaying) return;
                
                this.lastValidState = {
                    score: gameState.score,
                    lives: gameState.lives,
                    speed: gameState.speed,
                    timeRemaining: gameState.timeRemaining,
                    playerLane: gameState.playerLane,
                    collectedKiwis: gameState.collectedKiwis,
                    collectedBroccolis: gameState.collectedBroccolis
                };
            },
            
            attemptRecovery: function() {
                this.recoveryAttempts++;
                
                if (this.recoveryAttempts > this.maxRecoveryAttempts) {
                    console.error('Max recovery attempts reached, reloading page...');
                    window.location.reload();
                    return;
                }
                
                console.warn(`🔧 Attempting game recovery (attempt ${this.recoveryAttempts})...`);
                
                if (this.lastValidState) {
                    // Restore last valid state
                    Object.assign(gameState, this.lastValidState);
                    
                    // Clear potentially corrupted data
                    obstacles.forEach(obs => scene.remove(obs.mesh));
                    obstacles = [];
                    
                    gameState.kiwis.forEach(kiwi => scene.remove(kiwi.mesh));
                    gameState.kiwis = [];
                    
                    gameState.broccolis.forEach(broccoli => scene.remove(broccoli.mesh));
                    gameState.broccolis = [];
                    
                    // Reset player position
                    if (player) {
                        player.position.set(LANE_POSITIONS[gameState.playerLane], 0.8, 0);
                    }
                    
                    console.log('✅ Game state recovered');
                    window.UIManager?.showNotification('Game recovered from error', 'info');
                } else {
                    // No valid state, restart game
                    console.warn('No valid state to recover, restarting...');
                    resetGameState();
                    startGameInternal();
                }
            },
            
            reset: function() {
                this.recoveryAttempts = 0;
                this.lastValidState = null;
            }
        };
        
        // Save game state periodically
        setInterval(() => {
            if (gameState && gameState.isPlaying) {
                window.GameRecovery.saveState();
            }
        }, 5000);
        
        // CRITICAL FIX: Centralized score management to prevent explosion
        function addScore(amount, source = 'unknown') {
            // Add to queue instead of directly to score
            gameState.scoreQueue += Math.max(0, Math.floor(amount));
            
            // Debug logging for score tracking
            if (amount > 0) {
                console.log(`🎯 Score queued: +${amount} from ${source} (queue: ${gameState.scoreQueue})`);
            }
        }
        
        function processScoreQueue() {
            const currentTime = performance.now();
            
            // Only process queue every scoreUpdateInterval
            if (currentTime - gameState.lastScoreUpdate < gameState.scoreUpdateInterval) {
                return;
            }
            
            if (gameState.scoreQueue > 0) {
                // Apply limited amount from queue
                const scoreToAdd = Math.min(gameState.scoreQueue, gameState.maxScorePerUpdate);
                gameState.score += scoreToAdd;
                gameState.scoreQueue -= scoreToAdd;
                
                gameState.lastScoreUpdate = currentTime;
                
                console.log(`📊 Score processed: +${scoreToAdd} (total: ${gameState.score}, remaining queue: ${gameState.scoreQueue})`);
            }
        }
        
        // Auto-start ambient sounds when game starts
        let ambientStarted = false;

        // ========================================
        // DEVOPS MONITORING & FEATURE FLAG SYSTEM
        // ========================================
        
        // Feature Flag System with runtime control
        const FeatureFlags = {
            // Mega Feature Flags (10 total)
            COMBO_EXPLOSIONS: true,        // Feature 1 - Working
            DYNAMIC_THEMES: false,         // Feature 2 - Disabled (incomplete)
            POWER_UP_FUSION: true,         // Feature 3 - Working
            ADRENALINE_MODE: true,         // Feature 4 - Working
            TRICK_SYSTEM: false,           // Feature 5 - Disabled (incomplete)
            MYSTERY_GAMBLING: false,       // Feature 6 - Disabled (incomplete)
            OBSTACLE_DESTRUCTION: true,    // Feature 7 - Working
            FLIGHT_MODE: true,             // Feature 8 - Working
            DAILY_CHALLENGES: false,       // Feature 9 - Disabled (incomplete)
            MULTIPLIER_ROULETTE: false,    // Feature 10 - Disabled (incomplete)
            
            // Sub-feature flags
            GESTURE_CONTROL: true,
            SOUND_EFFECTS: true,
            PARTICLE_EFFECTS: true,
            ADVANCED_PHYSICS: true,
            LEADERBOARDS: true,
            ANALYTICS: true,
            
            // Rollout percentages (0-100)
            rolloutPercentages: {
                COMBO_EXPLOSIONS: 100,
                DYNAMIC_THEMES: 0,
                POWER_UP_FUSION: 100,
                ADRENALINE_MODE: 100,
                TRICK_SYSTEM: 0,
                MYSTERY_GAMBLING: 0,
                OBSTACLE_DESTRUCTION: 100,
                FLIGHT_MODE: 100,
                DAILY_CHALLENGES: 0,
                MULTIPLIER_ROULETTE: 0
            },
            
            // Check if feature is enabled for user
            isEnabled(featureName) {
                if (!this[featureName]) return false;
                
                // Check rollout percentage
                const percentage = this.rolloutPercentages[featureName];
                if (percentage !== undefined && percentage < 100) {
                    const userHash = this.getUserHash();
                    const threshold = userHash % 100;
                    return threshold < percentage;
                }
                
                return true;
            },
            
            // Generate consistent user hash for A/B testing
            getUserHash() {
                const userId = localStorage.getItem('userId') || this.generateUserId();
                let hash = 0;
                for (let i = 0; i < userId.length; i++) {
                    hash = ((hash << 5) - hash) + userId.charCodeAt(i);
                    hash = hash & hash;
                }
                return Math.abs(hash);
            },
            
            generateUserId() {
                const id = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('userId', id);
                return id;
            },
            
            // Runtime feature toggle
            toggle(featureName, enabled) {
                if (this.hasOwnProperty(featureName)) {
                    this[featureName] = enabled;
                    DevOpsMonitor.logEvent('feature_toggled', {
                        feature: featureName,
                        enabled: enabled,
                        timestamp: Date.now()
                    });
                }
            },
            
            // Set rollout percentage
            setRollout(featureName, percentage) {
                this.rolloutPercentages[featureName] = Math.max(0, Math.min(100, percentage));
                DevOpsMonitor.logEvent('rollout_changed', {
                    feature: featureName,
                    percentage: percentage
                });
            }
        };
        
        // Production Error Logging & Monitoring System
        class DevOpsMonitor {
            static sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            static errorQueue = [];
            static metrics = {
                fps: [],
                memoryUsage: [],
                loadTimes: {},
                featureUsage: {},
                errorCounts: {},
                performance: {
                    avgFps: 0,
                    minFps: 60,
                    maxFps: 60,
                    frameDrops: 0,
                    lagSpikes: 0
                }
            };
            static rollbackThresholds = {
                errorRate: 0.1,        // 10% error rate
                crashRate: 0.05,       // 5% crash rate
                performanceDrop: 0.3,  // 30% FPS drop
                memoryLeak: 100        // 100MB memory increase
            };
            static healthCheckInterval = null;
            static analyticsBuffer = [];
            static isInSafeMode = false;
            
            // Initialize monitoring
            static init() {
                this.setupErrorHandlers();
                this.startPerformanceMonitoring();
                this.startHealthChecks();
                this.initializeAnalytics();
                console.log('🚀 DevOps Monitor initialized - Session:', this.sessionId);
            }
            
            // Global error handlers
            static setupErrorHandlers() {
                // Catch unhandled errors
                window.addEventListener('error', (event) => {
                    this.logError({
                        type: 'unhandled_error',
                        message: event.message,
                        filename: event.filename,
                        line: event.lineno,
                        column: event.colno,
                        stack: event.error?.stack,
                        userAgent: navigator.userAgent,
                        timestamp: Date.now()
                    });
                });
                
                // Catch promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    this.logError({
                        type: 'unhandled_rejection',
                        reason: event.reason,
                        promise: event.promise,
                        timestamp: Date.now()
                    });
                });
                
                // Monitor resource loading errors
                window.addEventListener('error', (event) => {
                    if (event.target !== window) {
                        this.logError({
                            type: 'resource_error',
                            tagName: event.target.tagName,
                            src: event.target.src || event.target.href,
                            timestamp: Date.now()
                        });
                    }
                }, true);
            }
            
            // Log errors with context
            static logError(error) {
                const errorEntry = {
                    ...error,
                    sessionId: this.sessionId,
                    gameState: this.getGameContext(),
                    performance: this.getCurrentPerformance(),
                    features: this.getActiveFeatures()
                };
                
                this.errorQueue.push(errorEntry);
                
                // Track error counts
                const errorType = error.type || 'unknown';
                this.metrics.errorCounts[errorType] = (this.metrics.errorCounts[errorType] || 0) + 1;
                
                // Check if we need to trigger rollback
                this.checkRollbackConditions();
                
                // Send to analytics
                this.sendAnalytics('error', errorEntry);
                
                console.error('🚨 Error logged:', errorEntry);
            }
            
            // Performance monitoring
            static startPerformanceMonitoring() {
                let lastTime = performance.now();
                let frameCount = 0;
                
                const measureFPS = () => {
                    const currentTime = performance.now();
                    const deltaTime = currentTime - lastTime;
                    
                    if (deltaTime >= 1000) {
                        const fps = Math.round((frameCount * 1000) / deltaTime);
                        this.metrics.fps.push(fps);
                        
                        // Keep only last 60 samples
                        if (this.metrics.fps.length > 60) {
                            this.metrics.fps.shift();
                        }
                        
                        // Update performance metrics
                        this.updatePerformanceMetrics(fps);
                        
                        frameCount = 0;
                        lastTime = currentTime;
                    }
                    
                    frameCount++;
                    requestAnimationFrame(measureFPS);
                };
                
                requestAnimationFrame(measureFPS);
                
                // Monitor memory usage
                if (performance.memory) {
                    setInterval(() => {
                        this.metrics.memoryUsage.push({
                            usedJSHeapSize: performance.memory.usedJSHeapSize,
                            totalJSHeapSize: performance.memory.totalJSHeapSize,
                            jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
                            timestamp: Date.now()
                        });
                        
                        // Keep only last 100 samples
                        if (this.metrics.memoryUsage.length > 100) {
                            this.metrics.memoryUsage.shift();
                        }
                        
                        // Check for memory leaks
                        this.checkMemoryLeaks();
                    }, 5000);
                }
            }
            
            // Update performance metrics
            static updatePerformanceMetrics(currentFps) {
                const metrics = this.metrics.performance;
                
                // Update min/max
                metrics.minFps = Math.min(metrics.minFps, currentFps);
                metrics.maxFps = Math.max(metrics.maxFps, currentFps);
                
                // Calculate average
                const fpsArray = this.metrics.fps;
                metrics.avgFps = Math.round(fpsArray.reduce((a, b) => a + b, 0) / fpsArray.length);
                
                // Detect frame drops
                if (currentFps < 30) {
                    metrics.frameDrops++;
                }
                
                // Detect lag spikes
                if (currentFps < metrics.avgFps * 0.5) {
                    metrics.lagSpikes++;
                }
            }
            
            // Check memory leaks
            static checkMemoryLeaks() {
                if (this.metrics.memoryUsage.length < 10) return;
                
                const recent = this.metrics.memoryUsage.slice(-10);
                const old = this.metrics.memoryUsage.slice(0, 10);
                
                const recentAvg = recent.reduce((a, b) => a + b.usedJSHeapSize, 0) / recent.length;
                const oldAvg = old.reduce((a, b) => a + b.usedJSHeapSize, 0) / old.length;
                
                const increase = (recentAvg - oldAvg) / 1024 / 1024; // Convert to MB
                
                if (increase > this.rollbackThresholds.memoryLeak) {
                    this.logEvent('memory_leak_detected', {
                        increase: increase + 'MB',
                        oldAvg: (oldAvg / 1024 / 1024).toFixed(2) + 'MB',
                        recentAvg: (recentAvg / 1024 / 1024).toFixed(2) + 'MB'
                    });
                }
            }
            
            // Health check system
            static startHealthChecks() {
                this.healthCheckInterval = setInterval(() => {
                    const health = {
                        fps: this.metrics.performance.avgFps,
                        memory: performance.memory ? 
                            (performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit * 100).toFixed(2) + '%' : 
                            'N/A',
                        errors: Object.values(this.metrics.errorCounts).reduce((a, b) => a + b, 0),
                        uptime: Math.floor((Date.now() - parseInt(this.sessionId.split('_')[1])) / 1000),
                        features: this.getActiveFeatures()
                    };
                    
                    this.logEvent('health_check', health);
                }, 30000); // Every 30 seconds
            }
            
            // Feature usage tracking
            static trackFeatureUsage(featureName, action = 'used') {
                if (!this.metrics.featureUsage[featureName]) {
                    this.metrics.featureUsage[featureName] = {
                        uses: 0,
                        errors: 0,
                        avgDuration: 0,
                        lastUsed: null
                    };
                }
                
                const feature = this.metrics.featureUsage[featureName];
                feature.uses++;
                feature.lastUsed = Date.now();
                
                this.sendAnalytics('feature_usage', {
                    feature: featureName,
                    action: action,
                    timestamp: Date.now()
                });
            }
            
            // Rollback system
            static checkRollbackConditions() {
                const totalErrors = Object.values(this.metrics.errorCounts).reduce((a, b) => a + b, 0);
                const sessionDuration = (Date.now() - parseInt(this.sessionId.split('_')[1])) / 1000;
                const errorRate = totalErrors / Math.max(1, sessionDuration / 60); // Errors per minute
                
                // Check error rate threshold
                if (errorRate > this.rollbackThresholds.errorRate * 60) {
                    this.triggerRollback('high_error_rate', { errorRate, threshold: this.rollbackThresholds.errorRate * 60 });
                }
                
                // Check performance degradation
                if (this.metrics.performance.avgFps < 60 * (1 - this.rollbackThresholds.performanceDrop)) {
                    this.triggerRollback('performance_degradation', { 
                        avgFps: this.metrics.performance.avgFps, 
                        threshold: 60 * (1 - this.rollbackThresholds.performanceDrop) 
                    });
                }
            }
            
            // Trigger rollback to safe mode
            static triggerRollback(reason, details) {
                if (this.isInSafeMode) return;
                
                console.warn('🚨 ROLLBACK TRIGGERED:', reason, details);
                
                this.logEvent('rollback_triggered', {
                    reason,
                    details,
                    timestamp: Date.now()
                });
                
                // Enter safe mode
                this.enterSafeMode();
                
                // Notify user
                this.showRollbackNotification(reason);
            }
            
            // Enter safe mode with minimal features
            static enterSafeMode() {
                this.isInSafeMode = true;
                
                // Disable all non-essential features
                const essentialFeatures = ['COMBO_EXPLOSIONS', 'POWER_UP_FUSION', 'OBSTACLE_DESTRUCTION'];
                
                for (let feature in FeatureFlags) {
                    if (typeof FeatureFlags[feature] === 'boolean' && !essentialFeatures.includes(feature)) {
                        FeatureFlags[feature] = false;
                    }
                }
                
                // Reduce graphics quality
                if (window.renderer) {
                    window.renderer.setPixelRatio(1);
                }
                
                // Disable particle effects
                FeatureFlags.PARTICLE_EFFECTS = false;
                
                this.logEvent('safe_mode_activated', {
                    timestamp: Date.now(),
                    disabledFeatures: Object.keys(FeatureFlags).filter(f => !FeatureFlags[f])
                });
            }
            
            // Show rollback notification
            static showRollbackNotification(reason) {
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(255, 0, 0, 0.9);
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    font-size: 18px;
                    z-index: 10000;
                    text-align: center;
                    max-width: 400px;
                `;
                notification.innerHTML = `
                    <h3>⚠️ Performance Issue Detected</h3>
                    <p>The game has entered safe mode due to ${reason.replace(/_/g, ' ')}.</p>
                    <p>Some features have been disabled to ensure smooth gameplay.</p>
                    <button onclick="DevOpsMonitor.dismissNotification(this.parentElement)" style="
                        margin-top: 10px;
                        padding: 10px 20px;
                        background: white;
                        color: black;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                    ">OK</button>
                `;
                document.body.appendChild(notification);
            }
            
            static dismissNotification(element) {
                element.remove();
            }
            
            // Analytics system
            static initializeAnalytics() {
                // Send buffered analytics every 10 seconds
                setInterval(() => {
                    if (this.analyticsBuffer.length > 0) {
                        this.flushAnalytics();
                    }
                }, 10000);
                
                // Track page visibility
                document.addEventListener('visibilitychange', () => {
                    this.logEvent('visibility_changed', {
                        hidden: document.hidden,
                        timestamp: Date.now()
                    });
                });
                
                // Track user engagement
                let lastActivity = Date.now();
                ['click', 'keydown', 'touchstart'].forEach(event => {
                    document.addEventListener(event, () => {
                        const now = Date.now();
                        if (now - lastActivity > 60000) { // 1 minute of inactivity
                            this.logEvent('user_returned', {
                                inactivityDuration: now - lastActivity
                            });
                        }
                        lastActivity = now;
                    });
                });
            }
            
            // Send analytics data
            static sendAnalytics(eventType, data) {
                const event = {
                    type: eventType,
                    data: data,
                    sessionId: this.sessionId,
                    timestamp: Date.now(),
                    context: {
                        url: window.location.href,
                        userAgent: navigator.userAgent,
                        screen: {
                            width: window.screen.width,
                            height: window.screen.height
                        },
                        viewport: {
                            width: window.innerWidth,
                            height: window.innerHeight
                        }
                    }
                };
                
                this.analyticsBuffer.push(event);
                
                // Flush if buffer is getting large
                if (this.analyticsBuffer.length > 100) {
                    this.flushAnalytics();
                }
            }
            
            // Flush analytics buffer
            static flushAnalytics() {
                if (this.analyticsBuffer.length === 0) return;
                
                const events = [...this.analyticsBuffer];
                this.analyticsBuffer = [];
                
                // In production, this would send to an analytics endpoint
                console.log('📊 Analytics batch:', events.length, 'events');
                
                // Store locally for debugging
                const stored = JSON.parse(localStorage.getItem('devops_analytics') || '[]');
                stored.push(...events);
                
                // Keep only last 1000 events
                if (stored.length > 1000) {
                    stored.splice(0, stored.length - 1000);
                }
                
                localStorage.setItem('devops_analytics', JSON.stringify(stored));
            }
            
            // Log custom events
            static logEvent(eventName, data) {
                this.sendAnalytics('custom_event', {
                    name: eventName,
                    ...data
                });
            }
            
            // Get current game context
            static getGameContext() {
                if (!window.gameState) return null;
                
                return {
                    score: gameState.score,
                    lives: gameState.lives,
                    speed: gameState.speed,
                    isPlaying: gameState.isPlaying,
                    playerAction: gameState.playerAction,
                    activePowerUp: gameState.activePowerUp,
                    collectibles: {
                        kiwis: gameState.collectedKiwis,
                        broccolis: gameState.collectedBroccolis
                    }
                };
            }
            
            // Get current performance metrics
            static getCurrentPerformance() {
                return {
                    fps: this.metrics.performance.avgFps,
                    frameDrops: this.metrics.performance.frameDrops,
                    lagSpikes: this.metrics.performance.lagSpikes,
                    memory: performance.memory ? {
                        used: (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + 'MB',
                        total: (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2) + 'MB',
                        limit: (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2) + 'MB'
                    } : null
                };
            }
            
            // Get active features
            static getActiveFeatures() {
                return Object.keys(FeatureFlags).filter(key => 
                    typeof FeatureFlags[key] === 'boolean' && FeatureFlags[key]
                );
            }
            
            // Performance profiling
            static profile(name, fn) {
                const start = performance.now();
                const result = fn();
                const duration = performance.now() - start;
                
                if (!this.metrics.loadTimes[name]) {
                    this.metrics.loadTimes[name] = [];
                }
                
                this.metrics.loadTimes[name].push(duration);
                
                // Keep only last 100 samples
                if (this.metrics.loadTimes[name].length > 100) {
                    this.metrics.loadTimes[name].shift();
                }
                
                if (duration > 16.67) { // Longer than one frame
                    console.warn(`⚠️ Performance warning: ${name} took ${duration.toFixed(2)}ms`);
                }
                
                return result;
            }
            
            // Get monitoring dashboard data
            static getDashboardData() {
                return {
                    session: {
                        id: this.sessionId,
                        duration: Math.floor((Date.now() - parseInt(this.sessionId.split('_')[1])) / 1000),
                        safeMode: this.isInSafeMode
                    },
                    performance: this.metrics.performance,
                    errors: this.metrics.errorCounts,
                    features: {
                        active: this.getActiveFeatures(),
                        usage: this.metrics.featureUsage
                    },
                    memory: this.metrics.memoryUsage.slice(-1)[0] || null,
                    analytics: {
                        bufferSize: this.analyticsBuffer.length,
                        totalEvents: JSON.parse(localStorage.getItem('devops_analytics') || '[]').length
                    }
                };
            }
        }
        
        // Initialize DevOps monitoring
        DevOpsMonitor.init();
        
        // Expose to global scope for debugging
        window.FeatureFlags = FeatureFlags;
        window.DevOpsMonitor = DevOpsMonitor;
        
        // Update DevOps monitoring panel
        setInterval(() => {
            const panel = document.getElementById('devopsPanel');
            if (!panel) return;
            
            const data = DevOpsMonitor.getDashboardData();
            
            // Update FPS
            document.getElementById('devopsFPS').textContent = 
                `FPS: ${data.performance.avgFps} (${data.performance.minFps}-${data.performance.maxFps})`;
            
            // Update Memory
            if (data.memory) {
                const memPercent = ((data.memory.usedJSHeapSize / data.memory.jsHeapSizeLimit) * 100).toFixed(1);
                document.getElementById('devopsMemory').textContent = 
                    `Memory: ${memPercent}% (${(data.memory.usedJSHeapSize / 1024 / 1024).toFixed(1)}MB)`;
            }
            
            // Update Errors
            const totalErrors = Object.values(data.errors).reduce((a, b) => a + b, 0);
            document.getElementById('devopsErrors').textContent = 
                `Errors: ${totalErrors} ${totalErrors > 0 ? '⚠️' : '✅'}`;
            
            // Update Features
            document.getElementById('devopsFeatures').textContent = 
                `Features: ${data.features.active.length}/13`;
            
            // Update Mode
            document.getElementById('devopsMode').textContent = 
                `Mode: ${data.session.safeMode ? '🛡️ SAFE MODE' : '✅ Normal'}`;
            
            // Show/hide panel based on debug mode or errors
            if (window.debugMode || totalErrors > 0 || data.session.safeMode) {
                panel.style.display = 'block';
            }
        }, 1000);
        
        // Admin console for feature management
        window.DevOpsAdmin = {
            // Toggle feature
            toggleFeature(name, enabled) {
                FeatureFlags.toggle(name, enabled);
                console.log(`Feature ${name} is now ${enabled ? 'enabled' : 'disabled'}`);
            },
            
            // Set feature rollout percentage
            setRollout(name, percentage) {
                FeatureFlags.setRollout(name, percentage);
                console.log(`Feature ${name} rollout set to ${percentage}%`);
            },
            
            // Get monitoring dashboard
            getDashboard() {
                return DevOpsMonitor.getDashboardData();
            },
            
            // Force safe mode
            enterSafeMode() {
                DevOpsMonitor.enterSafeMode();
            },
            
            // Exit safe mode
            exitSafeMode() {
                DevOpsMonitor.isInSafeMode = false;
                console.log('Safe mode deactivated - features must be re-enabled manually');
            },
            
            // Get error log
            getErrors() {
                return DevOpsMonitor.errorQueue;
            },
            
            // Clear error log
            clearErrors() {
                DevOpsMonitor.errorQueue = [];
                DevOpsMonitor.metrics.errorCounts = {};
                console.log('Error log cleared');
            },
            
            // Get analytics
            getAnalytics() {
                return JSON.parse(localStorage.getItem('devops_analytics') || '[]');
            },
            
            // Clear analytics
            clearAnalytics() {
                localStorage.removeItem('devops_analytics');
                DevOpsMonitor.analyticsBuffer = [];
                console.log('Analytics cleared');
            },
            
            // Performance report
            getPerformanceReport() {
                const perf = DevOpsMonitor.metrics.performance;
                const memory = DevOpsMonitor.metrics.memoryUsage.slice(-1)[0];
                
                return {
                    fps: {
                        current: DevOpsMonitor.metrics.fps.slice(-1)[0],
                        average: perf.avgFps,
                        min: perf.minFps,
                        max: perf.maxFps
                    },
                    issues: {
                        frameDrops: perf.frameDrops,
                        lagSpikes: perf.lagSpikes
                    },
                    memory: memory ? {
                        used: (memory.usedJSHeapSize / 1024 / 1024).toFixed(2) + 'MB',
                        total: (memory.totalJSHeapSize / 1024 / 1024).toFixed(2) + 'MB',
                        percentage: ((memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100).toFixed(2) + '%'
                    } : 'N/A'
                };
            }
        };

        // Supabase Configuration - Using working credentials
        const SUPABASE_URL = 'https://umvrurelsxpxmyzcvrcd.supabase.co'
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVtdnJ1cmVsc3hweG15emN2cmNkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzUzMzQ5OTYsImV4cCI6MjA1MDkxMDk5Nn0.xpBgJ0BQN86JqhNtKzKNl1kchO1IU_oXI7SYpgfLBJU'
        
        // Initialize Supabase client
        let supabase = null;
        let highscores = [];
        let currentScore = 0;
        let currentSurvivalTime = 0;

        // Initialize Supabase connection
        try {
            if (window.supabase) {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('✅ Supabase initialized successfully');
                console.log('🔗 Database URL:', SUPABASE_URL);
                console.log('🔑 Using API Key:', SUPABASE_ANON_KEY.substring(0, 20) + '...');
            } else {
                throw new Error('Supabase library not loaded');
            }
        } catch (error) {
            console.log('⚠️ Supabase initialization failed, using offline mode:', error);
            supabase = null;
        }

        // Highscore Management System
        class HighscoreManager {
            constructor() {
                this.localStorageKey = 'subwayRunner_highscores';
                this.loadHighscores();
            }

            async loadHighscores() {
                console.log('📊 Loading highscores...');
                try {
                    if (supabase) {
                        console.log('🔄 Fetching from Supabase...');
                        
                        // BUGFIX: Add timeout and better error handling for DNS issues
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Request timeout - possible DNS/network issue')), 5000)
                        );
                        
                        const supabasePromise = supabase
                            .from('subway_runner_scores')
                            .select('*')
                            .order('score', { ascending: false })
                            .limit(10);
                            
                        const { data, error } = await Promise.race([supabasePromise, timeoutPromise]);
                        
                        if (!error && data) {
                            console.log(`✅ Loaded ${data.length} scores from Supabase:`, data);
                            highscores = data;
                        } else {
                            console.log('❌ Supabase error:', error);
                            throw new Error('Supabase error: ' + (error?.message || 'Unknown'));
                        }
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    console.log('⚠️ Network/DNS error, falling back to localStorage:', error.message);
                    // Fallback to localStorage
                    const localScores = localStorage.getItem(this.localStorageKey);
                    highscores = localScores ? JSON.parse(localScores) : [];
                    console.log(`📱 Loaded ${highscores.length} local scores:`, highscores);
                }
                this.displayHighscores();
            }

            async submitScore(playerName, score, survivalTime, isVictory) {
                const scoreEntry = {
                    player_name: playerName,
                    score: score,
                    survival_time: survivalTime,
                    is_victory: isVictory,
                    created_at: new Date().toISOString()
                };

                console.log('💾 Submitting score:', scoreEntry);

                try {
                    if (supabase) {
                        console.log('🔄 Inserting to Supabase...');
                        const { data, error } = await supabase
                            .from('subway_runner_scores')
                            .insert([scoreEntry])
                            .select();
                        
                        if (error) {
                            console.log('❌ Supabase insert error:', error);
                            throw error;
                        }
                        
                        console.log('✅ Score submitted to Supabase:', data);
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    console.log('⚠️ Supabase submit failed, using localStorage:', error.message);
                    // Fallback to localStorage
                    highscores.push(scoreEntry);
                    highscores.sort((a, b) => b.score - a.score);
                    highscores = highscores.slice(0, 10); // Keep only top 10
                    localStorage.setItem(this.localStorageKey, JSON.stringify(highscores));
                    console.log('📱 Score saved locally');
                }

                await this.loadHighscores();
            }

            isHighscore(score) {
                if (highscores.length < 10) return true;
                return score > highscores[9].score;
            }

            displayHighscores() {
                const list = document.getElementById('highscoreList');
                if (highscores.length === 0) {
                    list.innerHTML = 'Keine Scores vorhanden';
                    return;
                }

                let html = '';
                highscores.forEach((score, index) => {
                    const rank = index + 1;
                    const victoryIcon = score.is_victory ? '🏆' : '';
                    const timeText = score.is_victory ? '60s' : `${score.survival_time}s`;
                    
                    html += `<div class="highscore-entry">
                        ${rank}. ${score.player_name} ${victoryIcon}<br>
                        <small>${score.score} pts - ${timeText}</small>
                    </div>`;
                });
                list.innerHTML = html;
            }
        }

        const highscoreManager = new HighscoreManager();

        // Make functions globally available for onclick handlers
        window.startGame = function() {
            console.log('startGame called');
            try {
                startGameInternal();
            } catch (error) {
                console.error('Error in startGame:', error);
            }
        };

        window.submitHighscore = function() {
            console.log('submitHighscore called');
            try {
                submitHighscoreInternal();
            } catch (error) {
                console.error('Failed to submit highscore:', error);
                window.SecurityManager.handleError(error, 'highscore_submit');
            }
        };

        window.skipHighscore = function() {
            console.log('skipHighscore called');
            skipHighscoreInternal();
        };

        // Game state
        let gameState = {
            isPlaying: false,
            isGameOver: false,
            isVictory: false,
            score: 0,
            speed: 0.08, // Langsamerer Start
            baseSpeed: 0.08,
            maxSpeed: 0.45, // Sehr schnell am Ende!
            lives: 3,
            gameTime: 60, // 60 Sekunden
            timeRemaining: 60,
            gameStartTime: 0,
            playerLane: 1, // 0=left, 1=center, 2=right
            playerAction: 'running', // running, jumping, ducking
            playerY: 0,
            jumpVelocity: 0,
            jumpStartTime: 0,  // BUGFIX: Track jump start time for safety
            maxJumpDuration: 2000, // Maximum 2 seconds jump duration
            obstacles: [],
            invulnerable: false,
            invulnerabilityTime: 0,
            timeScale: 1.0,
            cameraShakeIntensity: 0,
            cameraZoom: 1.0,
            slowMotionActive: false,
            
            // NEW: Power-Up & Collectibles System
            powerUps: [],              // Spawned power-ups in world
            kiwis: [],                 // Spawned kiwis in world
            broccolis: [],             // Spawned broccolis in world  
            collectedKiwis: 0,         // Current session kiwis
            collectedBroccolis: 0,     // Current session broccolis
            totalKiwis: 0,             // Lifetime kiwis
            totalBroccolis: 0,         // Lifetime broccolis
            totalCollectibles: 0,      // Total spawned this session
            collectionGoal: 10,        // Target collectibles for bonus (80% of max ~12-15)
            collectionBonusAwarded: {      // Track tiered collection bonuses
                fiveOfOne: false,               // 5+ of one type
                allOfOne: false,                // All 30 kiwis OR all 7 broccolis  
                allThirtySeven: false,          // All 37 collectibles (30 kiwis + 7 broccolis)
                broccoliMaster: false,          // 5 broccolis (+200 points)
                veggieChampion: false           // 7 broccolis (+500 points)
            },
            activePowerUp: null,       // Currently active power-up
            powerUpTimeRemaining: 0,   // Time left for active power-up
            magnetActive: false,       // Magnet power-up state
            magnetCount: 0,           // Track spawned magnets (max 2)
            shieldActive: false,       // Shield power-up state
            speedBoostActive: false,   // Speed boost power-up state
            // Fusion system
            fusionSlots: [null, null], // Two slots for fusion
            activeFusion: null,        // Active fusion type
            fusionTimeRemaining: 0,    // Time left for fusion
            // Perfect streak tracking
            perfectStreak: 0,          // Current perfect streak count
            adrenalineActive: false,   // Adrenaline mode state
            adrenalineTimeRemaining: 0,// Time left in adrenaline mode
            lastObstacleDistance: 0,  // Track last obstacle for perfect moves
            timeScaleFactor: 1.0,      // Time scale for slow-motion effects
            kiwiCombo: 0,              // Current kiwi collection combo
            comboMultiplier: 1,        // Score multiplier from combos
            lastKiwiTime: 0,           // For combo timeout
            
            // NEW: Advanced Skill & Combo System
            skillCombo: 0,             // Current skill move combo (dodge sequences)
            lastSkillTime: 0,          // Time of last skill move
            moveSequence: [],          // Track recent moves for combo detection
            consecutiveAvoidances: 0,  // Count of consecutive obstacle avoidances
            lastAvoidanceTime: 0,      // Time of last successful avoidance
            lastAction: 'running',     // Track last player action for sequences
            rapidMoveBonus: 0,         // Bonus for rapid direction changes
            perfectTimingCount: 0,     // Count of perfect timing moves
            skillMultiplier: 1,        // Score multiplier for skill moves
            comboActive: false,        // Visual indicator for active combo
            
            // NEW: Enhanced Gameplay Features
            nearMissStreak: 0,         // Consecutive near misses
            lastNearMissTime: 0,       // Time of last near miss
            nearMissMultiplier: 1,     // Bonus multiplier for near misses
            milestoneReached: 0,       // Track distance milestones
            lastMilestone: 0,          // Last milestone distance
            scoreMultiplier: 1,        // Combined score multiplier
            maxCombo: 0,               // Highest combo achieved
            perfectRun: true,          // No hits taken
            totalDistance: 0,          // Total distance travelled
            
            // Touch Controls
            touchStartX: 0,
            touchStartY: 0,
            touchThreshold: 50,        // Swipe distance threshold
            isTouchDevice: false,      // Auto-detect touch support
            
            // Environment state
            currentEnvironment: 'street', // 'street', 'tunnel', 'tunnel_entrance', 'tunnel_exit'
            environmentTransition: false,
            tunnelProgress: 0,
            tunnelStartTime: 0,
            tunnelDuration: 15000, // 15 seconds in tunnel
            nextTunnelTime: 20000, // First tunnel after 20 seconds
            tunnelCooldown: 30000, // 30 seconds between tunnels
            lastTunnelExit: 0,
            tunnelSegments: [], // Tunnel wall/ceiling segments
            tunnelLights: [], // Tunnel lighting
            ambientLightIntensity: 1.0, // For tunnel dimming effect
            
            // Visual Effects State
            speedLineIntensity: 0,
            currentFogDensity: 0.002,
            targetFogDensity: 0.002,
            motionBlurActive: false,
            vignetteIntensity: 0,
            particleEffects: [],
            
            // Score update throttling (FIX: Prevent 60FPS score updates)
            lastScoreUpdate: 0,
            scoreUpdateInterval: 100, // Update score every 100ms (10 times per second)
            
            // Centralized score queue for throttling ALL score additions
            scoreQueue: 0,
            maxScorePerUpdate: 100, // Maximum score increase per throttled update
            
            // Trick System
            trickMoveHistory: [],
            lastTrickTime: 0,
            trickCombo: 0,
            trickMultiplier: 1,
            announcerLevel: 0, // 0-4 for escalating announcements
            
            // Mystery Box System
            mysteryBoxes: [],
            mysteryBoxesSpawned: 0, // Track spawned mystery boxes (max 2)
            gamblingActive: false,
            gamblingStats: {
                wins: 0,
                losses: 0,
                totalBoxes: 0,
                netPoints: 0
            },
            pausedForGambling: false,
            savedGameSpeed: 0,
            
            // FEATURE 7: Obstacle Destruction & Rampage Mode
            destructionStreak: 0,          // Current destruction streak
            lastDestructionTime: 0,        // Time of last destruction
            rampageActive: false,          // Rampage mode state
            rampageTimeRemaining: 0,       // Time left in rampage mode
            rampageStartTime: 0,           // When rampage started
            totalDestroyed: 0,             // Total obstacles destroyed
            breakableObstacles: ['lowbarrier', 'jumpblock', 'spikes'], // Destructible types
            
            // FEATURE 8: Rocket Boost Pads & Flight Mode
            flightMode: false,             // Flight mode state
            flightTimeRemaining: 0,        // Time left in flight mode
            flightAltitude: 0,             // Current flight altitude (0-5 units)
            targetAltitude: 3,             // Target altitude for smooth movement
            rocketBoostPads: [],           // Active boost pads
            aerialCollectibles: [],        // Floating collectibles
            
            // FEATURE 9: Daily Challenge & Achievement System
            dailyChallenge: null,          // Current daily challenge
            dailyChallengeProgress: 0,     // Progress towards challenge
            dailyChallengeCompleted: false,// Challenge completion status
            lastChallengeDate: null,       // Last challenge date
            achievements: {},              // Unlocked achievements
            challengeStats: {              // Stats for challenge tracking
                jumpsCount: 0,
                perfectMoves: 0,
                obstaclesDestroyed: 0,
                maxSpeedReached: 0
            },
            
            // FEATURE 10: Multiplier Roulette & Score Surge
            scoreTokens: [],               // Active score tokens in world
            collectedTokens: 0,            // Tokens collected (max 3)
            rouletteActive: false,         // Roulette UI active
            currentMultiplier: 1.0,        // Current score multiplier
            scoreSurgeActive: false,       // Score surge mode active
            scoreSurgeTimeRemaining: 0,    // Time left in surge mode
            scoreSurgeMultiplier: 1.0,     // Additional surge multiplier
            rouletteHistory: []            // History of roulette results
        };

        // Three.js setup
        let scene, camera, renderer, player, track, obstacles = [];
        const LANE_POSITIONS = [-2, 0, 2];
        
        // Power-Up and Collectible arrays for tracking
        let powerUps = [];
        let kiwis = [];
        let broccolis = [];  // NEW: Brokkoli tracking
        
        // Power-Up configuration
        const POWER_UP_TYPES = {
            magnet: {
                name: 'Magnet',
                icon: '🧲',
                color: 0xFFD700, // Keep golden color for UI/effects
                duration: 15000, // 15 seconds
                effect: 'magnetActive'
            },
            largeMagnet: {
                name: 'Large Magnet',
                icon: '🧲',
                color: 0xFFD700, // Same golden color
                duration: 15000, // Same duration as regular magnet
                effect: 'magnetActive', // Same effect
                isLarge: true, // Special flag to identify large magnet
                spawnRate: 0.3 // 30% chance when spawning magnets
            },
            shield: {
                name: 'Shield', 
                icon: '🛡️',
                color: 0x4ECDC4,
                duration: 10000, // 10 seconds
                effect: 'shieldActive'
            },
            speedboost: {
                name: 'Speed Boost',
                icon: '⚡',
                color: 0xFF6B35,
                duration: 8000, // 8 seconds
                effect: 'speedBoostActive'
            }
        };
        
        // Fusion combinations
        const FUSION_COMBINATIONS = {
            'magnet_speedboost': {
                name: 'Rainbow Vacuum',
                icon: '🌈',
                duration: 10000,
                color: 0xFF00FF,
                effects: ['magnetActive', 'speedBoostActive'],
                speedMultiplier: 3.0,
                attractAll: true,
                description: 'Attracts ALL collectibles + 300% speed!'
            },
            'shield_speedboost': {
                name: 'Rocket Mode',
                icon: '🚀',
                duration: 8000,
                color: 0xFFD700,
                effects: ['shieldActive'],
                unlimitedJump: true,
                invincible: true,
                description: 'Unlimited jumps + invincible!'
            },
            'magnet_shield': {
                name: 'Golden God',
                icon: '👑',
                duration: 12000,
                color: 0xFFD700,
                effects: ['magnetActive', 'shieldActive'],
                glowEffect: true,
                absorbHits: true,
                description: 'Attract + absorb hits + glow!'
            }
        };
        
        // Environment object tracking for parallax movement
        let environmentObjects = {
            buildings: [],
            streetLamps: [],
            trafficSigns: [],
            streetLines: [],
            sidewalks: []
        };
        
        // Smooth speed system
        let visualSpeed = 0.08;
        let lastFrameTime = 0;
        let lastUIUpdateTime = 0;
        const SPEED_LERP_FACTOR = 0.05;

        function init() {
            console.log('Initializing Three.js scene...');
            try {
                // Scene with enhanced fog
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x87CEEB, gameState.currentFogDensity);

            // Camera (Subway Surfers perspective)
            camera = new THREE.PerspectiveCamera(60, 4/3, 0.1, 1000);
            camera.position.set(0, 3, 8);

            // Renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Modern lighting system
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);

            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFE4B5, 1.2);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);

            // Atmospheric hemisphere light for sky gradient
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.6);
            scene.add(hemisphereLight);

            // Rim lighting for urban atmosphere
            const rimLight = new THREE.DirectionalLight(0x4A90E2, 0.3);
            rimLight.position.set(-5, 8, -10);
            scene.add(rimLight);

            // Enhance renderer for better visuals
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            // Create player
            createPlayer();
            
            // Create track
            createTrack();
            
            // Create environment
            createEnvironment();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
                // Start render loop
                animate();
                console.log('Three.js initialization complete');
            } catch (error) {
                console.error('Error initializing Three.js:', error);
            }
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            // Player body (torso)
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A90E2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.7;
            body.castShadow = true;
            playerGroup.add(body);

            // Player head
            const headGeometry = new THREE.SphereGeometry(0.25);
            const headMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF5B041
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.35;
            head.castShadow = true;
            playerGroup.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.4, 0.2);
            playerGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.4, 0.2);
            playerGroup.add(rightEye);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xF5B041 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            playerGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2C3E50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.0, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.0, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            // Shoes
            const shoeGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.15, -0.35, 0.1);
            leftShoe.castShadow = true;
            playerGroup.add(leftShoe);
            
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.15, -0.35, 0.1);
            rightShoe.castShadow = true;
            playerGroup.add(rightShoe);

            // Backpack
            const backpackGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
            const backpackMaterial = new THREE.MeshLambertMaterial({ color: 0xE74C3C });
            const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.7, -0.25);
            backpack.castShadow = true;
            playerGroup.add(backpack);

            // Cap
            const capGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1);
            const capMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.55;
            cap.castShadow = true;
            playerGroup.add(cap);

            // Cap visor
            const visorGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.02);
            const visorMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 1.48, 0.2);
            visor.rotation.x = -0.3;
            visor.castShadow = true;
            playerGroup.add(visor);

            playerGroup.position.set(LANE_POSITIONS[gameState.playerLane], 0, 0);
            
            // FIX: Player should look forward (negative Z direction)
            playerGroup.rotation.y = Math.PI;
            
            scene.add(playerGroup);
            player = playerGroup;
        }

        function createTrack() {
            const trackGroup = new THREE.Group();
            
            // Create track segments
            for (let i = 0; i < 10; i++) {
                const segmentGroup = new THREE.Group();
                segmentGroup.position.z = -i * 10;
                
                // Main track
                const trackGeometry = new THREE.BoxGeometry(8, 0.1, 10);
                const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.receiveShadow = true;
                segmentGroup.add(trackMesh);
                
                // Lane dividers
                const dividerGeometry = new THREE.BoxGeometry(0.1, 0.05, 10);
                const dividerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
                
                const leftDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                leftDivider.position.x = -1;
                segmentGroup.add(leftDivider);
                
                const rightDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                rightDivider.position.x = 1;
                segmentGroup.add(rightDivider);
                
                trackGroup.add(segmentGroup);
            }
            
            scene.add(trackGroup);
            track = trackGroup;
        }

        function createEnvironment() {
            // Urban ground with asphalt texture
            const groundGeometry = new THREE.PlaneGeometry(80, 120);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(0, -1, -30);
            ground.receiveShadow = true;
            scene.add(ground);

            // Sidewalks
            const sidewalkGeometry = new THREE.PlaneGeometry(8, 120);
            const sidewalkMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x999999
            });
            
            const leftSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            leftSidewalk.rotation.x = -Math.PI / 2;
            leftSidewalk.position.set(-10, -0.98, -30);
            leftSidewalk.receiveShadow = true;
            leftSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(leftSidewalk);
            environmentObjects.sidewalks.push(leftSidewalk);
            
            const rightSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            rightSidewalk.rotation.x = -Math.PI / 2;
            rightSidewalk.position.set(10, -0.98, -30);
            rightSidewalk.receiveShadow = true;
            rightSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(rightSidewalk);
            environmentObjects.sidewalks.push(rightSidewalk);

            // Street lines
            for (let i = 0; i < 20; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.3, 2);
                const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const streetLine = new THREE.Mesh(lineGeometry, lineMaterial);
                streetLine.rotation.x = -Math.PI / 2;
                streetLine.position.set(0, -0.95, -i * 6);
                streetLine.userData = { 
                    type: 'streetLine', 
                    initialZ: -i * 6,
                    parallaxSpeed: 0.95 // 95% of game speed (close to track)
                };
                scene.add(streetLine);
                environmentObjects.streetLines.push(streetLine);
            }

            // Realistic city buildings
            for (let i = 0; i < 15; i++) {
                createRealisticBuilding(-15 - Math.random() * 8, -i * 8 - Math.random() * 4, 'left');
                createRealisticBuilding(15 + Math.random() * 8, -i * 8 - Math.random() * 4, 'right');
            }

            // Street lamps
            for (let i = 0; i < 12; i++) {
                createStreetLamp(-6, -i * 10);
                createStreetLamp(6, -i * 10);
            }

            // Traffic signs and urban details
            for (let i = 0; i < 8; i++) {
                if (Math.random() > 0.5) {
                    createTrafficSign(-7, -i * 12 - 5);
                    createTrafficSign(7, -i * 12 - 5);
                }
            }
        }

        function createRealisticBuilding(x, z, side) {
            const buildingGroup = new THREE.Group();
            
            // Building dimensions
            const width = 4 + Math.random() * 3;
            const depth = 4 + Math.random() * 3;
            const height = 8 + Math.random() * 12;
            
            // Main building structure
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create building materials with windows
            const buildingMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.2, 0.3 + Math.random() * 0.4)
            });
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2 - 1; // Ground level
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows
            const windowsPerFloor = Math.floor(width / 1.5);
            const floors = Math.floor(height / 3);
            
            for (let floor = 0; floor < floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    // Window facing the street
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const isLit = Math.random() > 0.4;
                    const windowMaterial = new THREE.MeshLambertMaterial({ 
                        color: isLit ? 0xFFFF88 : 0x222244,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    const windowX = -width/2 + 0.7 + w * 1.5;
                    const windowY = floor * 3 + 1.5;
                    const windowZ = side === 'left' ? depth/2 + 0.01 : -depth/2 - 0.01;
                    
                    window.position.set(windowX, windowY, windowZ);
                    if (side === 'right') window.rotation.y = Math.PI;
                    
                    buildingGroup.add(window);
                }
            }

            // Rooftop details
            if (Math.random() > 0.6) {
                // Air conditioning units
                const acGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const acMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const ac = new THREE.Mesh(acGeometry, acMaterial);
                ac.position.set(0, height/2 + 0.25, 0);
                ac.castShadow = true;
                buildingGroup.add(ac);
            }

            if (Math.random() > 0.7) {
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0, height/2 + 1, 0);
                buildingGroup.add(antenna);
            }

            buildingGroup.position.set(x, 0, z);
            buildingGroup.userData = { 
                type: 'building', 
                initialZ: z,
                parallaxSpeed: 0.7 + Math.random() * 0.2 // 70-90% of game speed
            };
            scene.add(buildingGroup);
            environmentObjects.buildings.push(buildingGroup);
        }

        function createStreetLamp(x, z) {
            const lampGroup = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1;
            pole.castShadow = true;
            lampGroup.add(pole);
            
            // Light fixture
            const lightGeometry = new THREE.SphereGeometry(0.3);
            const lightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFF88,
                emissive: 0x444400
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = 3;
            lampGroup.add(light);
            
            // Add point light
            const pointLight = new THREE.PointLight(0xFFFF88, 0.5, 10);
            pointLight.position.y = 3;
            lampGroup.add(pointLight);
            
            lampGroup.position.set(x, 0, z);
            lampGroup.userData = { 
                type: 'streetLamp', 
                initialZ: z,
                parallaxSpeed: 0.85 // 85% of game speed
            };
            scene.add(lampGroup);
            environmentObjects.streetLamps.push(lampGroup);
        }

        function createTrafficSign(x, z) {
            const signGroup = new THREE.Group();
            
            // Sign post
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.25;
            signGroup.add(post);
            
            // Sign board
            const signGeometry = new THREE.PlaneGeometry(1, 1);
            const signMaterial = new THREE.MeshLambertMaterial({ 
                color: Math.random() > 0.5 ? 0xFF4444 : 0x4444FF
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.y = 2;
            sign.rotation.y = x < 0 ? Math.PI/4 : -Math.PI/4;
            signGroup.add(sign);
            
            signGroup.position.set(x, 0, z);
            signGroup.userData = { 
                type: 'trafficSign', 
                initialZ: z,
                parallaxSpeed: 0.8 // 80% of game speed
            };
            scene.add(signGroup);
            environmentObjects.trafficSigns.push(signGroup);
        }

        function createObstacle(type, lane, z) {
            const obstacleGroup = new THREE.Group();
            obstacleGroup.position.set(LANE_POSITIONS[lane], 0, z);
            
            let obstacleGeometry, obstacleMaterial, height;
            
            switch (type) {
                case 'lowbarrier':
                    // Niedrige Barriere - muss übersprungen werden
                    obstacleGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35
                    });
                    height = 0.8;
                    break;
                case 'highbarrier':
                    // Hohe Barriere - muss unterduckt werden
                    obstacleGeometry = new THREE.BoxGeometry(1.8, 0.4, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B0000
                    });
                    height = 0.4;
                    break;
                case 'spikes':
                    // Stacheln - überspringen oder ducken
                    obstacleGeometry = new THREE.ConeGeometry(0.25, 0.6, 6);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF4500,
                        emissive: 0x221100
                    });
                    height = 0.6;
                    break;
                case 'jumpblock':
                    // Block zum Überspringen - Concrete texture
                    obstacleGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B8B8B
                    });
                    height = 1.2;
                    // Add concrete details
                    const detailGeom = new THREE.BoxGeometry(0.1, 0.1, 1.3);
                    const detailMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    for (let i = 0; i < 4; i++) {
                        const detail = new THREE.Mesh(detailGeom, detailMat);
                        detail.position.set(
                            (i % 2 - 0.5) * 1.2, 
                            (Math.floor(i / 2) - 0.5) * 1.2, 
                            0
                        );
                        detail.castShadow = true;
                        obstacleGroup.add(detail);
                    }
                    break;
                case 'duckbeam':
                    // Balken zum Unterducken - Metal beam
                    obstacleGeometry = new THREE.BoxGeometry(2.2, 0.3, 0.8);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x4682B4
                    });
                    height = 0.3;
                    // Add support struts
                    const strutGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.8);
                    const strutMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
                    for (let i = 0; i < 2; i++) {
                        const strut = new THREE.Mesh(strutGeom, strutMat);
                        strut.position.set((i - 0.5) * 1.5, -0.75, 0);
                        strut.castShadow = true;
                        obstacleGroup.add(strut);
                    }
                    break;
                case 'hurdleset':
                    // Hürden-Set - mehrere niedrige Hürden
                    for (let i = 0; i < 3; i++) {
                        const hurdleGeometry = new THREE.BoxGeometry(1.4, 0.7, 0.2);
                        const hurdleMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22
                        });
                        const hurdle = new THREE.Mesh(hurdleGeometry, hurdleMaterial);
                        hurdle.position.set(0, 0.35, -0.5 + i * 0.5);
                        hurdle.castShadow = true;
                        hurdle.receiveShadow = true;
                        obstacleGroup.add(hurdle);
                        
                        // Add warning stripes
                        const stripeGeom = new THREE.PlaneGeometry(1.5, 0.1);
                        const stripeMat = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00,
                            transparent: true,
                            opacity: 0.8
                        });
                        const stripe = new THREE.Mesh(stripeGeom, stripeMat);
                        stripe.position.set(0, 0.6, -0.5 + i * 0.5 + 0.11);
                        obstacleGroup.add(stripe);
                    }
                    height = 0.7;
                    break;
                case 'wallgap':
                    // Wand mit Lücke zum Ducken - Industrial wall
                    const wallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090
                    });
                    
                    const wallLeft = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallLeft.position.set(-0.5, 1.25, 0);
                    wallLeft.castShadow = true;
                    wallLeft.receiveShadow = true;
                    obstacleGroup.add(wallLeft);
                    
                    const wallRight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallRight.position.set(0.5, 1.25, 0);
                    wallRight.castShadow = true;
                    wallRight.receiveShadow = true;
                    obstacleGroup.add(wallRight);
                    
                    const wallTop = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.8, 0.4),
                        wallMaterial
                    );
                    wallTop.position.set(0, 2.1, 0);
                    wallTop.castShadow = true;
                    wallTop.receiveShadow = true;
                    obstacleGroup.add(wallTop);
                    
                    // Add hazard warning lights
                    const lightGeom = new THREE.SphereGeometry(0.08);
                    const lightMat = new THREE.MeshLambertMaterial({ 
                        color: 0xFF0000,
                        emissive: 0x440000
                    });
                    const warningLight = new THREE.Mesh(lightGeom, lightMat);
                    warningLight.position.set(0, 1.3, 0.25);
                    obstacleGroup.add(warningLight);
                    
                    height = 1.3; // Höhe der Lücke
                    break;
                    
                case 'rotatingblade':
                    // NEW: Rotating blade obstacle
                    const bladeGroup = new THREE.Group();
                    
                    // Central hub
                    const hubGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4);
                    const hubMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                    hub.position.y = 1;
                    bladeGroup.add(hub);
                    
                    // Rotating blades
                    for (let i = 0; i < 3; i++) {
                        const bladeGeometry = new THREE.BoxGeometry(2, 0.1, 0.2);
                        const bladeMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B0000,
                            emissive: 0x220000
                        });
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.y = 1;
                        blade.rotation.y = (i * Math.PI * 2) / 3;
                        blade.castShadow = true;
                        bladeGroup.add(blade);
                    }
                    
                    // Add warning lights
                    for (let j = 0; j < 2; j++) {
                        const warnLight = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06),
                            new THREE.MeshLambertMaterial({ 
                                color: 0xFF0000,
                                emissive: 0x330000
                            })
                        );
                        warnLight.position.set(j === 0 ? -1.2 : 1.2, 1.5, 0);
                        bladeGroup.add(warnLight);
                    }
                    
                    obstacleGroup.add(bladeGroup);
                    height = 2;
                    break;
                    
                case 'swinginghammer':
                    // NEW: Swinging hammer obstacle
                    const hammerGroup = new THREE.Group();
                    
                    // Support structure
                    const supportGeometry = new THREE.BoxGeometry(0.2, 3, 0.2);
                    const supportMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const support = new THREE.Mesh(supportGeometry, supportMaterial);
                    support.position.y = 1.5;
                    support.castShadow = true;
                    hammerGroup.add(support);
                    
                    // Swinging arm
                    const armGroup = new THREE.Group();
                    const armGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.y = -0.75;
                    arm.castShadow = true;
                    armGroup.add(arm);
                    
                    // Hammer head
                    const hammerGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
                    const hammerMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hammerHead = new THREE.Mesh(hammerGeometry, hammerMaterial);
                    hammerHead.position.y = -1.4;
                    hammerHead.castShadow = true;
                    armGroup.add(hammerHead);
                    
                    armGroup.position.y = 3;
                    hammerGroup.add(armGroup);
                    obstacleGroup.add(hammerGroup);
                    height = 1.8;
                    break;
                    
                case 'movingwall':
                    // NEW: Side-to-side moving wall
                    const movingWallGeometry = new THREE.BoxGeometry(0.3, 2, 1);
                    const movingWallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090,
                        transparent: true,
                        opacity: 0.9
                    });
                    const movingWall = new THREE.Mesh(movingWallGeometry, movingWallMaterial);
                    movingWall.position.y = 1;
                    movingWall.castShadow = true;
                    
                    // Add warning stripes
                    for (let k = 0; k < 4; k++) {
                        const stripeGeometry = new THREE.PlaneGeometry(0.35, 0.2);
                        const stripeMaterial = new THREE.MeshLambertMaterial({ 
                            color: k % 2 === 0 ? 0xFFFF00 : 0xFF0000
                        });
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.set(0.16, 0.5 + k * 0.4, 0);
                        movingWall.add(stripe);
                    }
                    
                    obstacleGroup.add(movingWall);
                    height = 2;
                    break;
                    
                case 'bouncingball':
                    // NEW: Bouncing ball obstacle - bounces up and down
                    const ballGroup = new THREE.Group();
                    
                    // Main bouncing ball
                    const ballGeometry = new THREE.SphereGeometry(0.6);
                    const ballMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35,
                        emissive: 0x331100
                    });
                    const bouncingBall = new THREE.Mesh(ballGeometry, ballMaterial);
                    bouncingBall.position.y = 1.5; // Starting height
                    bouncingBall.castShadow = true;
                    ballGroup.add(bouncingBall);
                    
                    // Shadow indicator on ground
                    const shadowGeometry = new THREE.CircleGeometry(0.4);
                    const shadowMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.3
                    });
                    const ballShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
                    ballShadow.rotation.x = -Math.PI / 2;
                    ballShadow.position.y = 0.01; // Just above ground
                    ballGroup.add(ballShadow);
                    
                    // Warning ring around bounce area
                    const ringGeometry = new THREE.RingGeometry(0.8, 1.0);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 0.6
                    });
                    const warningRing = new THREE.Mesh(ringGeometry, ringMaterial);
                    warningRing.rotation.x = -Math.PI / 2;
                    warningRing.position.y = 0.02;
                    ballGroup.add(warningRing);
                    
                    obstacleGroup.add(ballGroup);
                    height = 3; // Max bounce height
                    break;
                    
                case 'spinninglaser':
                    // NEW: Spinning laser beam obstacle
                    const laserGroup = new THREE.Group();
                    
                    // Central hub
                    const laserHubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6);
                    const laserHubMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x333333,
                        emissive: 0x110011
                    });
                    const laserHub = new THREE.Mesh(laserHubGeometry, laserHubMaterial);
                    laserHub.position.y = 1.2;
                    laserHub.castShadow = true;
                    laserGroup.add(laserHub);
                    
                    // Spinning laser beam (multiple segments for effect)
                    const laserBeamGroup = new THREE.Group();
                    for (let i = 0; i < 2; i++) {
                        const beamGeometry = new THREE.BoxGeometry(3, 0.1, 0.1);
                        const beamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0044,
                            emissive: 0x660022,
                            transparent: true,
                            opacity: 0.8
                        });
                        const laserBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                        laserBeam.position.y = 1.2;
                        laserBeam.rotation.y = i * Math.PI; // 180 degrees apart
                        laserBeam.castShadow = true;
                        laserBeamGroup.add(laserBeam);
                        
                        // Add glowing effect with smaller inner beam
                        const innerBeamGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
                        const innerBeamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFFFF,
                            emissive: 0xFF0044
                        });
                        const innerBeam = new THREE.Mesh(innerBeamGeometry, innerBeamMaterial);
                        innerBeam.position.copy(laserBeam.position);
                        innerBeam.rotation.copy(laserBeam.rotation);
                        laserBeamGroup.add(innerBeam);
                    }
                    
                    laserGroup.add(laserBeamGroup);
                    
                    // Warning lights at corners
                    for (let j = 0; j < 4; j++) {
                        const angle = (j * Math.PI) / 2;
                        const lightGeometry = new THREE.SphereGeometry(0.08);
                        const lightMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0000,
                            emissive: 0x440000
                        });
                        const warningLight = new THREE.Mesh(lightGeometry, lightMaterial);
                        warningLight.position.set(
                            Math.cos(angle) * 1.8,
                            0.2,
                            Math.sin(angle) * 1.8
                        );
                        laserGroup.add(warningLight);
                    }
                    
                    obstacleGroup.add(laserGroup);
                    height = 1.4; // Laser height
                    break;
            }
            
            // Für einfache Hindernisse (nicht die komplexen oder neuen Typen)
            if (type !== 'hurdleset' && type !== 'wallgap' && 
                type !== 'rotatingblade' && type !== 'swinginghammer' && type !== 'movingwall' &&
                type !== 'bouncingball' && type !== 'spinninglaser') {
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.castShadow = true;
                
                if (type === 'spikes') {
                    obstacle.position.y = height / 2;
                } else if (type === 'duckbeam') {
                    obstacle.position.y = 1.4; // FIXED: Niedriger positioniert für echtes Ducken
                } else if (type === 'highbarrier') {
                    obstacle.position.y = 1.4; // FIXED: Niedriger positioniert für echtes Ducken
                } else {
                    obstacle.position.y = height / 2;
                }
                
                obstacleGroup.add(obstacle);
            }
            
            scene.add(obstacleGroup);
            
            // Enhanced obstacle data with animation properties
            const obstacleData = {
                mesh: obstacleGroup,
                type: type,
                lane: lane,
                z: z,
                height: height,
                animationTime: 0,
                rotationSpeed: 0,
                swingAmplitude: 0,
                swingSpeed: 0,
                movementRange: 0,
                movementSpeed: 0,
                initialX: LANE_POSITIONS[lane]
            };
            
            // Set animation properties for moving obstacles
            switch (type) {
                case 'rotatingblade':
                    obstacleData.rotationSpeed = 3 + Math.random() * 2; // Random rotation speed
                    break;
                case 'swinginghammer':
                    obstacleData.swingAmplitude = Math.PI / 3; // 60 degree swing
                    obstacleData.swingSpeed = 2 + Math.random(); // Random swing speed
                    break;
                case 'movingwall':
                    obstacleData.movementRange = 3; // Movement range across lanes
                    obstacleData.movementSpeed = 1.5 + Math.random() * 0.5;
                    break;
                case 'bouncingball':
                    obstacleData.bounceHeight = 2.5; // Max bounce height
                    obstacleData.bounceSpeed = 3 + Math.random() * 1.5; // Bounce frequency
                    break;
                case 'spinninglaser':
                    obstacleData.rotationSpeed = 2 + Math.random() * 1.5; // Laser spin speed
                    obstacleData.pulseSpeed = 4; // Warning light pulse
                    break;
            }
            
            obstacles.push(obstacleData);
        }
        
        // FEATURE 8: Create Rocket Boost Pad
        function createRocketBoostPad(lane, z) {
            const padGroup = new THREE.Group();
            
            // Main boost pad platform
            const padGeometry = new THREE.BoxGeometry(2, 0.3, 2);
            const padMaterial = new THREE.MeshLambertMaterial({
                color: 0x00CCFF,
                emissive: 0x0066FF,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            });
            const pad = new THREE.Mesh(padGeometry, padMaterial);
            pad.position.y = 0.15;
            pad.castShadow = true;
            padGroup.add(pad);
            
            // Glowing ring effect
            const ringGeometry = new THREE.RingGeometry(1.2, 1.5);
            const ringMaterial = new THREE.MeshLambertMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.7,
                emissive: 0x00CCFF,
                emissiveIntensity: 0.8
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.31;
            padGroup.add(ring);
            
            // Rocket symbol on pad
            const rocketGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const rocketMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.3
            });
            const rocket = new THREE.Mesh(rocketGeometry, rocketMaterial);
            rocket.position.y = 0.7;
            padGroup.add(rocket);
            
            // Energy particles
            for (let i = 0; i < 6; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1);
                const particleMaterial = new THREE.MeshLambertMaterial({
                    color: 0x00FFFF,
                    emissive: 0x00CCFF,
                    emissiveIntensity: 0.9,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const angle = (i / 6) * Math.PI * 2;
                particle.position.set(
                    Math.cos(angle) * 1.0,
                    0.5 + Math.sin(i * 2) * 0.3,
                    Math.sin(angle) * 1.0
                );
                padGroup.add(particle);
            }
            
            // Pulsing light columns
            for (let j = 0; j < 4; j++) {
                const columnGeometry = new THREE.CylinderGeometry(0.1, 0.2, 2);
                const columnMaterial = new THREE.MeshLambertMaterial({
                    color: 0x00CCFF,
                    transparent: true,
                    opacity: 0.4,
                    emissive: 0x0099FF,
                    emissiveIntensity: 0.6
                });
                const column = new THREE.Mesh(columnGeometry, columnMaterial);
                column.position.set(
                    Math.cos(j * Math.PI / 2) * 0.8,
                    1,
                    Math.sin(j * Math.PI / 2) * 0.8
                );
                padGroup.add(column);
            }
            
            padGroup.position.set(LANE_POSITIONS[lane], 0, z);
            scene.add(padGroup);
            
            const boostPadData = {
                mesh: padGroup,
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0
            };
            
            gameState.rocketBoostPads.push(boostPadData);
            return boostPadData;
        }
        
        // FEATURE 8: Create Aerial Collectible
        function createAerialCollectible(type, lane, z, altitude) {
            const collectibleGroup = new THREE.Group();
            
            if (type === 'kiwi') {
                // Floating golden kiwi with enhanced glow
                const kiwiGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const kiwiMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFAA00,
                    emissiveIntensity: 0.6
                });
                const kiwi = new THREE.Mesh(kiwiGeometry, kiwiMaterial);
                collectibleGroup.add(kiwi);
                
                // Glowing aura
                const auraGeometry = new THREE.SphereGeometry(0.6, 8, 8);
                const auraMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFF00,
                    transparent: true,
                    opacity: 0.3,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.8
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                collectibleGroup.add(aura);
            } else {
                // Floating rainbow broccoli
                const broccoliGeometry = new THREE.ConeGeometry(0.4, 0.6, 8);
                const broccoliMaterial = new THREE.MeshLambertMaterial({
                    color: 0x00FF00,
                    emissive: 0x00FF88,
                    emissiveIntensity: 0.5
                });
                const broccoli = new THREE.Mesh(broccoliGeometry, broccoliMaterial);
                broccoli.rotation.z = Math.PI;
                collectibleGroup.add(broccoli);
                
                // Rainbow effect ring
                const rainbowGeometry = new THREE.RingGeometry(0.5, 0.7);
                const rainbowMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFF00FF,
                    transparent: true,
                    opacity: 0.5,
                    emissive: 0xFF00FF,
                    emissiveIntensity: 0.4
                });
                const rainbow = new THREE.Mesh(rainbowGeometry, rainbowMaterial);
                rainbow.rotation.x = -Math.PI / 2;
                collectibleGroup.add(rainbow);
            }
            
            // Floating sparkles
            for (let i = 0; i < 4; i++) {
                const sparkleGeometry = new THREE.SphereGeometry(0.05);
                const sparkleMaterial = new THREE.MeshLambertMaterial({
                    color: 0xFFFFFF,
                    emissive: 0xFFFFFF,
                    emissiveIntensity: 0.9
                });
                const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                sparkle.position.set(
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1
                );
                collectibleGroup.add(sparkle);
            }
            
            collectibleGroup.position.set(LANE_POSITIONS[lane], altitude, z);
            scene.add(collectibleGroup);
            
            const aerialData = {
                mesh: collectibleGroup,
                type: type,
                lane: lane,
                z: z,
                altitude: altitude,
                collected: false,
                animationTime: 0,
                value: type === 'kiwi' ? 100 : 200 // Double points for aerial collectibles
            };
            
            gameState.aerialCollectibles.push(aerialData);
            return aerialData;
        }

        function startGameInternal() {
            // Resume audio context
            audioManager.resume();
            
            // Start background music
            audioManager.startBackgroundMusic();
            
            // Start ambient city sounds
            if (!ambientStarted) {
                audioManager.play('ambient');
                ambientStarted = true;
            }
            
            gameState.isPlaying = true;
            gameState.isGameOver = false;
            gameState.isVictory = false;
            gameState.score = 0;
            gameState.speed = gameState.baseSpeed;
            gameState.lives = 3;
            gameState.timeRemaining = gameState.gameTime;
            gameState.gameStartTime = Date.now();
            gameState.playerLane = 1;
            gameState.playerAction = 'running';
            gameState.playerY = 0;
            gameState.jumpVelocity = 0;
            gameState.invulnerable = false;
            gameState.invulnerabilityTime = 0;
            gameState.timeScale = 1.0;
            gameState.cameraShakeIntensity = 0;
            gameState.slowMotionActive = false;
            
            // BUGFIX: Reset milestone tracking to prevent constant confetti
            gameState.lastMilestone = 0;
            gameState.milestoneReached = 0;
            gameState.totalDistance = 0;
            
            // BUGFIX: Initialize centralized score system
            gameState.lastScoreUpdate = performance.now();
            gameState.scoreQueue = 0;
            gameState.lastDistanceScore = performance.now();
            
            // Reset all multipliers and combos
            gameState.comboMultiplier = 1;
            gameState.nearMissMultiplier = 1;
            gameState.skillMultiplier = 1;
            gameState.scoreMultiplier = 1;
            gameState.nearMissStreak = 0;
            gameState.kiwiCombo = 0;
            
            // Reset collectible system with debug logging
            console.log('🔄 RESETTING COLLECTIBLE COUNTERS');
            console.log(`   Before reset - Kiwis: ${gameState.collectedKiwis}, Broccolis: ${gameState.collectedBroccolis}`);
            
            gameState.collectedKiwis = 0;
            gameState.collectedBroccolis = 0;
            gameState.totalCollectibles = 0;
            gameState.collectionBonusAwarded = {
                fiveOfOne: false,
                allOfOne: false, 
                allThirtySeven: false,
                broccoliMaster: false,
                veggieChampion: false
            };
            
            console.log(`   After reset - Kiwis: ${gameState.collectedKiwis}, Broccolis: ${gameState.collectedBroccolis}`);
            
            // Force immediate UI update
            updateKiwiUI();
            
            // Clear obstacles and collectibles
            obstacles.forEach(obs => scene.remove(obs.mesh));
            obstacles = [];
            
            // Clear existing collectibles
            gameState.kiwis.forEach(kiwi => scene.remove(kiwi.mesh));
            gameState.kiwis = [];
            gameState.broccolis.forEach(broccoli => scene.remove(broccoli.mesh));
            gameState.broccolis = [];
            
            // Reset FEATURE 7: Rampage mode
            gameState.destructionStreak = 0;
            gameState.lastDestructionTime = 0;
            gameState.rampageActive = false;
            gameState.rampageTimeRemaining = 0;
            gameState.rampageStartTime = 0;
            gameState.totalDestroyed = 0;
            
            // Reset FEATURE 8: Flight mode
            gameState.flightMode = false;
            gameState.flightTimeRemaining = 0;
            gameState.flightAltitude = 0;
            gameState.targetAltitude = 3;
            
            // Clear rocket boost pads and aerial collectibles
            gameState.rocketBoostPads.forEach(pad => scene.remove(pad.mesh));
            gameState.rocketBoostPads = [];
            gameState.aerialCollectibles.forEach(aerial => scene.remove(aerial.mesh));
            gameState.aerialCollectibles = [];
            
            // FEATURE 9: Reset challenge stats for new game
            gameState.challengeStats = {
                jumpsCount: 0,
                perfectMoves: 0,
                obstaclesDestroyed: 0,
                maxSpeedReached: 0
            };
            
            // FEATURE 10: Reset roulette/token state
            gameState.scoreTokens = [];
            gameState.collectedTokens = 0;
            gameState.currentMultiplier = 1.0;
            gameState.scoreSurgeActive = false;
            gameState.scoreSurgeTimeRemaining = 0;
            
            // Reset spawn counters for new game
            gameState.mysteryBoxesSpawned = 0;
            gameState.magnetCount = 0;
            gameState.scoreSurgeMultiplier = 1.0;
            
            // Initialize daily challenge system
            initializeDailyChallenge();
            
            // Start sound
            audioManager.play('powerup');
            
            document.getElementById('menu').style.display = 'none';
            updateUI();
            
            // Extra check to ensure UI is properly updated at game start
            setTimeout(() => {
                updateKiwiUI();
                console.log('✅ Game started - UI updated after delay');
            }, 100);
        }

        function endGame() {
            gameState.isPlaying = false;
            gameState.isGameOver = true;
            
            // Stop background music and ambient sounds
            audioManager.stopBackgroundMusic();
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = Math.max(0, gameState.gameTime - Math.ceil(gameState.timeRemaining));
            
            // FEATURE 9: Check achievements at game end
            checkAchievements();
            checkDailyChallengeProgress();
            
            // Check for highscore
            console.log('Game ended. Checking highscore:', currentScore, 'isHighscore:', highscoreManager.isHighscore(currentScore));
            if (highscoreManager.isHighscore(currentScore)) {
                console.log('New highscore achieved! Showing name input dialog.');
                showNameInputDialog(false);
            } else {
                showGameOverMenu(false);
            }
        }

        function victoryGame() {
            gameState.isPlaying = false;
            gameState.isVictory = true;
            
            // Stop ambient sounds
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = 60; // Full 60 seconds survived!
            
            // Victory celebration!
            audioManager.play('powerup');
            
            // Fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createParticleEffect(
                        new THREE.Vector3((Math.random() - 0.5) * 10, 5, -5),
                        [0xFF6B35, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFEDE57][i],
                        'success'
                    );
                }, i * 300);
            }
            
            // Always show name input for victory (it's always a highscore achievement!)
            showNameInputDialog(true);
        }

        function updateUI() {
            // Animate score changes
            const scoreElement = document.getElementById('score');
            const currentDisplayScore = parseInt(scoreElement.textContent) || 0;
            const targetScore = Math.floor(gameState.score);
            
            if (targetScore > currentDisplayScore) {
                scoreElement.classList.add('ui-bounce');
                setTimeout(() => scoreElement.classList.remove('ui-bounce'), 500);
            }
            scoreElement.textContent = targetScore;
            
            // Speed display with color coding
            const speedElement = document.getElementById('speed');
            speedElement.textContent = Math.floor(gameState.speed * 1000);
            const speedRatio = gameState.speed / gameState.maxSpeed;
            if (speedRatio > 0.8) {
                speedElement.style.color = '#FF4444';
            } else if (speedRatio > 0.6) {
                speedElement.style.color = '#FFA500';
            } else if (speedRatio > 0.4) {
                speedElement.style.color = '#FFD700';
            } else {
                speedElement.style.color = 'white';
            }
            
            // Lives with pulse animation on change
            const livesElement = document.getElementById('lives');
            const currentLives = parseInt(livesElement.textContent) || 3;
            if (gameState.lives < currentLives) {
                livesElement.classList.add('ui-bounce');
                livesElement.style.color = '#FF4444';
                setTimeout(() => {
                    livesElement.classList.remove('ui-bounce');
                    livesElement.style.color = 'white';
                }, 1000);
            }
            livesElement.textContent = gameState.lives;
            
            // Update timer with visual warnings
            const timeElement = document.getElementById('timeRemaining');
            const timerElement = document.getElementById('timer');
            timeElement.textContent = Math.max(0, Math.ceil(gameState.timeRemaining));
            
            // Timer visual states with audio warnings
            const timeLeft = Math.ceil(gameState.timeRemaining);
            if (timeLeft <= 10) {
                timerElement.className = 'timer-critical';
                // Final countdown beeps
                if (timeLeft <= 5 && timeLeft > 0 && Math.ceil(gameState.timeRemaining) !== Math.ceil(gameState.timeRemaining + 0.016)) {
                    audioManager.play('coin'); // High pitched beep
                }
            } else if (timeLeft <= 20) {
                timerElement.className = 'timer-warning';
                // Warning at 20 seconds
                if (timeLeft === 20 && Math.abs(gameState.timeRemaining - 20) < 0.1) {
                    audioManager.play('duck'); // Warning sound
                }
            } else {
                timerElement.className = '';
            }
            
            // Update multiplier display with glow effect
            const multiplierElement = document.getElementById('currentMultiplier');
            if (multiplierElement) {
                const newMultiplier = gameState.scoreMultiplier.toFixed(1);
                if (parseFloat(newMultiplier) > 1.0) {
                    multiplierElement.parentElement.classList.add('ui-glow');
                } else {
                    multiplierElement.parentElement.classList.remove('ui-glow');
                }
                multiplierElement.textContent = newMultiplier;
            }
            
            // Update difficulty progress display
            updateDifficultyUI();
            
            // Update collectible counters
            updateKiwiUI();
        }

        function showNameInputDialog(isVictory) {
            const dialog = document.getElementById('nameInputDialog');
            const title = dialog.querySelector('h2');
            
            if (isVictory) {
                title.innerHTML = '🎉 VICTORY + HIGHSCORE! 🎉';
            } else {
                title.innerHTML = '🎉 Neuer Highscore! 🎉';
            }
            
            dialog.style.display = 'block';
            document.getElementById('playerNameInput').focus();
        }

        function showGameOverMenu(isVictory) {
            const menu = document.getElementById('menu');
            
            if (isVictory) {
                menu.innerHTML = `
                    <h1>🎉 VICTORY! 🎉</h1>
                    <h2>Du hast 60 Sekunden überlebt!</h2>
                    <p>Final Score: ${currentScore}</p>
                    <p>Du bist ein Subway Runner Champion! 🏆</p>
                    <button onclick="startGame()">🎮 Nochmal versuchen</button>
                `;
            } else {
                menu.innerHTML = `
                    <h1>Game Over!</h1>
                    <p>Final Score: ${currentScore}</p>
                    <p>Zeit überlebt: ${currentSurvivalTime}s</p>
                    <button onclick="startGame()">🎮 Nochmal spielen</button>
                `;
            }
            
            menu.style.display = 'block';
        }

        async function submitHighscoreInternal() {
            const nameInput = document.getElementById('playerNameInput');
            let playerName = nameInput.value.trim();
            
            if (!playerName) {
                playerName = 'Anonymous';
            }
            
            // Disable button while submitting
            const submitBtn = document.querySelector('#nameInputDialog button');
            submitBtn.disabled = true;
            submitBtn.textContent = '💾 Speichere...';
            
            try {
                await highscoreManager.submitScore(
                    playerName, 
                    currentScore, 
                    currentSurvivalTime, 
                    gameState.isVictory
                );
                
                // Hide dialog and show game over menu
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
                
                // Clear input for next time
                nameInput.value = '';
                
            } catch (error) {
                console.error('Error submitting highscore:', error);
                // Still hide dialog and continue
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
            }
            
            // Re-enable button
            submitBtn.disabled = false;
            submitBtn.textContent = '💾 Speichern';
        }

        function skipHighscoreInternal() {
            document.getElementById('nameInputDialog').style.display = 'none';
            showGameOverMenu(gameState.isVictory);
            document.getElementById('playerNameInput').value = '';
        }

        // Handle Enter key in name input
        document.addEventListener('DOMContentLoaded', () => {
            const nameInput = document.getElementById('playerNameInput');
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitHighscoreInternal();
                }
            });
            
            // Set version info
            const versionInfo = document.getElementById('versionInfo');
            if (versionInfo) {
                versionInfo.innerHTML = `
                    Version: 4.0.5-BALANCED<br>
                    🎯 Perfect Balance Mode<br>
                    🥝 Realistic Kiwis + Limited Spawns
                `;
            }
        });
        
        // Initialize UI counters on page load
        setTimeout(() => {
            updateKiwiUI();
            console.log('✅ Initial UI update completed');
        }, 100);
        
        // Debug functions for testing collectible counters
        window.debugCollectibles = function() {
            console.log('=== COLLECTIBLE DEBUG INFO ===');
            console.log(`Game State:`, {
                collectedKiwis: gameState.collectedKiwis,
                collectedBroccolis: gameState.collectedBroccolis,
                totalKiwis: gameState.totalKiwis,
                totalBroccolis: gameState.totalBroccolis,
                totalCollectibles: gameState.totalCollectibles,
                activeKiwis: gameState.kiwis.length,
                activeBroccolis: gameState.broccolis.length,
                isPlaying: gameState.isPlaying
            });
            
            console.log('UI Elements:', {
                kiwiCount: document.getElementById('kiwiCount')?.textContent,
                broccoliCount: document.getElementById('broccoliCount')?.textContent,
                kiwiElement: document.getElementById('kiwiCount'),
                broccoliElement: document.getElementById('broccoliCount')
            });
            
            // Force UI update
            updateKiwiUI();
            console.log('Force updated UI - check values now');
        };
        
        // Function to manually reset and test counters
        window.testCollectibles = function() {
            console.log('Testing collectible system...');
            
            // Reset counters
            gameState.collectedKiwis = 0;
            gameState.collectedBroccolis = 0;
            updateKiwiUI();
            
            console.log('Reset counters to 0');
            
            // Simulate collecting
            setTimeout(() => {
                gameState.collectedKiwis = 5;
                gameState.collectedBroccolis = 3;
                updateKiwiUI();
                console.log('Set test values: Kiwis=5, Broccolis=3');
            }, 1000);
        };

        function handleKeyDown(event) {
            // DevOps keyboard shortcuts (work even when not playing)
            if (event.ctrlKey && event.shiftKey) {
                switch (event.code) {
                    case 'KeyD': // Ctrl+Shift+D - Toggle DevOps panel
                        event.preventDefault();
                        const panel = document.getElementById('devopsPanel');
                        if (panel) {
                            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                        }
                        console.log('DevOps panel toggled');
                        break;
                    case 'KeyS': // Ctrl+Shift+S - Enter safe mode
                        event.preventDefault();
                        DevOpsMonitor.enterSafeMode();
                        console.log('Safe mode activated');
                        break;
                    case 'KeyR': // Ctrl+Shift+R - Show performance report
                        event.preventDefault();
                        console.log('Performance Report:', DevOpsAdmin.getPerformanceReport());
                        break;
                    case 'KeyF': // Ctrl+Shift+F - Show feature flags
                        event.preventDefault();
                        console.log('Active Features:', FeatureFlags);
                        break;
                }
                return;
            }
            
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    event.preventDefault();
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        
                        // Track lane movement for skill combos
                        trackPlayerMove('left', gameState.playerLane);
                    }
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    event.preventDefault();
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        
                        // Track lane movement for skill combos
                        trackPlayerMove('right', gameState.playerLane);
                    }
                    break;
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    event.preventDefault();
                    // FEATURE 8: Flight altitude control
                    if (gameState.flightMode) {
                        // Increase altitude during flight
                        gameState.targetAltitude = Math.min(5, gameState.targetAltitude + 0.5);
                    } else {
                        // Check for Rocket Mode fusion (unlimited jumps)
                        const hasRocketMode = gameState.activeFusion === 'shield_speedboost';
                        if (gameState.playerAction === 'running' || hasRocketMode) {
                            gameState.playerAction = 'jumping';
                            gameState.jumpVelocity = 10;
                            gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time // Höherer Sprung
                            gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                            
                            // Audio & Visual Feedback with speed dynamics
                            const speedMultiplier = gameState.speed / gameState.maxSpeed;
                            audioManager.playSpeedDependentSound('jump', speedMultiplier);
                            audioManager.resume(); // Resume audio context if needed
                            
                            // Sprung-Partikel (nur bei erfolgreichem Obstacle-Avoidance)
                            // Removed automatic jump particles - only success particles when avoiding obstacles
                            
                            // Track jump for skill combos
                            trackPlayerMove('jumping');
                            
                            // FEATURE 9: Track jumps for daily challenge
                            gameState.challengeStats.jumpsCount++;
                        }
                    }
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    // FEATURE 8: Flight altitude control
                    if (gameState.flightMode) {
                        // Decrease altitude during flight
                        gameState.targetAltitude = Math.max(2, gameState.targetAltitude - 0.5);
                    } else if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                        
                        // Track duck for skill combos
                        trackPlayerMove('ducking');
                    }
                    break;
            }
        }

        function handleKeyUp(event) {
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    gameState.playerAction = 'running';
                    break;
            }
        }

        function createParticleEffect(position, color, type) {
            // Security check for particle availability
            if (!window.SecurityManager.isFeatureAvailable('particles')) return;
            
            // Performance check
            const quality = window.PerformanceMonitor.getQualityLevel();
            if (quality === 'low' && type !== 'collision' && type !== 'success') {
                // Only show critical particles on low-end devices
                return;
            }
            
            // Limit total particles in scene
            const currentParticles = scene.children.filter(child => child.userData && child.userData.isParticle).length;
            if (currentParticles > 100) {
                // Remove oldest particles
                const toRemove = scene.children
                    .filter(child => child.userData && child.userData.isParticle)
                    .sort((a, b) => (a.userData.createdAt || 0) - (b.userData.createdAt || 0))
                    .slice(0, 50);
                toRemove.forEach(particle => scene.remove(particle));
            }
            
            let particleCount, spreadRange, speed, size;
            
            // Reduce particle count based on performance
            const particleMultiplier = quality === 'high' ? 1.0 : (quality === 'medium' ? 0.6 : 0.3);
            
            switch (type) {
                case 'success':
                    particleCount = 25;
                    spreadRange = 3;
                    speed = 4;
                    size = 0.06;
                    break;
                case 'explosion':
                    particleCount = 40;
                    spreadRange = 5;
                    speed = 6;
                    size = 0.08;
                    break;
                case 'jump':
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.04;
                    break;
                case 'landing':
                    particleCount = 20;
                    spreadRange = 3;
                    speed = 2;
                    size = 0.05;
                    break;
                case 'nearMiss':
                    particleCount = 10;
                    spreadRange = 1.5;
                    speed = 2;
                    size = 0.03;
                    break;
                case 'collision':
                    particleCount = 30;
                    spreadRange = 4;
                    speed = 5;
                    size = 0.06;
                    break;
                case 'spark':
                    particleCount = 8;
                    spreadRange = 1;
                    speed = 6;
                    size = 0.02;
                    break;
                case 'dust':
                    particleCount = 12;
                    spreadRange = 2.5;
                    speed = 1;
                    size = 0.04;
                    break;
                case 'duckConfetti':
                    particleCount = 20;
                    spreadRange = 3;
                    speed = 4;
                    size = 0.07;
                    break;
                default:
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.05;
            }
            
            // Apply performance multiplier
            particleCount = Math.max(1, Math.floor(particleCount * particleMultiplier));
            
            // PERFORMANCE FIX: Use shared geometry and materials for particles
            const sharedGeometry = new THREE.SphereGeometry(size, 6, 6);
            const sharedMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true
            });
            
            const particles = new THREE.Group();
            particles.userData.isParticle = true;
            particles.userData.createdAt = Date.now();
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(sharedGeometry, sharedMaterial);
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spreadRange,
                    Math.random() * speed + 0.5,
                    (Math.random() - 0.5) * spreadRange
                );
                particle.life = 1.0;
                particle.originalSize = size;
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Enhanced particle animation
            const animateParticles = () => {
                particles.children.forEach((particle, index) => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(gameState.timeScale));
                    particle.velocity.y -= 0.15 * gameState.timeScale; // Gravity
                    particle.life -= 0.015 * gameState.timeScale;
                    
                    // Fancy effects based on type
                    if (type === 'explosion') {
                        particle.material.opacity = particle.life * 0.8;
                        particle.scale.setScalar(1 + (1 - particle.life) * 2);
                        particle.rotation.x += 0.1 * gameState.timeScale;
                        particle.rotation.y += 0.1 * gameState.timeScale;
                    } else if (type === 'success') {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(1 + Math.sin(Date.now() * 0.01 + index) * 0.3);
                    } else if (type === 'duckConfetti') {
                        // Special duck confetti: sparkly falling effect with rotation
                        particle.material.opacity = particle.life * 0.9;
                        particle.scale.setScalar(1 + Math.sin(Date.now() * 0.02 + index) * 0.4);
                        particle.rotation.x += 0.15 * gameState.timeScale;
                        particle.rotation.y += 0.2 * gameState.timeScale;
                        particle.rotation.z += 0.1 * gameState.timeScale;
                        // Floating effect: less gravity for confetti
                        particle.velocity.y += 0.05 * gameState.timeScale; // Counter some gravity
                    } else {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(particle.life);
                    }
                    
                    if (particle.life <= 0) {
                        particles.remove(particle);
                    }
                });
                
                if (particles.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }

        function startSlowMotion(duration = 800) {
            gameState.slowMotionActive = true;
            gameState.timeScale = 0.3;
            
            // Camera zoom effect
            const originalFov = camera.fov;
            camera.fov = originalFov * 0.8;
            camera.updateProjectionMatrix();
            
            setTimeout(() => {
                gameState.slowMotionActive = false;
                gameState.timeScale = 1.0;
                camera.fov = originalFov;
                camera.updateProjectionMatrix();
            }, duration);
        }

        function screenShake(intensity = 0.1, duration = 300) {
            gameState.cameraShakeIntensity = intensity;
            
            setTimeout(() => {
                gameState.cameraShakeIntensity = 0;
            }, duration);
        }

        function cameraZoomEffect(targetZoom = 1.2, duration = 500) {
            const originalFov = camera.fov;
            const targetFov = originalFov / targetZoom;
            
            const startTime = Date.now();
            const zoomAnimation = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.5) {
                    // Zoom in
                    const zoomProgress = progress * 2;
                    camera.fov = originalFov - (originalFov - targetFov) * zoomProgress;
                } else {
                    // Zoom out
                    const zoomProgress = (progress - 0.5) * 2;
                    camera.fov = targetFov + (originalFov - targetFov) * zoomProgress;
                }
                
                camera.updateProjectionMatrix();
                
                if (progress < 1) {
                    requestAnimationFrame(zoomAnimation);
                }
            };
            zoomAnimation();
        }

        function createExplosionRing(position, color = 0xFF6644) {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            ring.position.copy(position);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            // Animate ring expansion
            const animateRing = () => {
                ring.scale.x += 0.3;
                ring.scale.y += 0.3;
                ring.material.opacity -= 0.02;
                
                if (ring.material.opacity > 0) {
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ring);
                }
            };
            animateRing();
        }

        // Enhanced collision detection with precise bounding boxes and near-miss system
        function checkCollisions() {
            if (gameState.invulnerable) return;
            
            // Player bounding box calculation
            const playerBBox = calculatePlayerBoundingBox();
            
            obstacles.forEach((obstacle, index) => {
                // PERFORMANCE FIX: Early distance check before expensive collision calculations
                const distanceZ = Math.abs(obstacle.mesh.position.z - player.position.z);
                if (distanceZ > 3) return; // Skip distant obstacles
                
                // Calculate obstacle bounding box
                const obstacleBBox = calculateObstacleBoundingBox(obstacle);
                
                // Check for actual collision using 3D bounding box intersection
                const isColliding = boundingBoxIntersection(playerBBox, obstacleBBox);
                
                // ENHANCED DUCK COLLISION DETECTION
                if (obstacle.type === 'duckbeam' || obstacle.type === 'highbarrier' || obstacle.type === 'wallgap') {
                    console.log(`🔍 DUCK OBSTACLE CHECK:
                        Type: ${obstacle.type}
                        Action: ${gameState.playerAction}
                        Player Y: ${gameState.playerY}
                        Player BBox: min(${playerBBox.min.x.toFixed(2)}, ${playerBBox.min.y.toFixed(2)}, ${playerBBox.min.z.toFixed(2)}) max(${playerBBox.max.x.toFixed(2)}, ${playerBBox.max.y.toFixed(2)}, ${playerBBox.max.z.toFixed(2)})
                        Obstacle BBox: min(${obstacleBBox.min.x.toFixed(2)}, ${obstacleBBox.min.y.toFixed(2)}, ${obstacleBBox.min.z.toFixed(2)}) max(${obstacleBBox.max.x.toFixed(2)}, ${obstacleBBox.max.y.toFixed(2)}, ${obstacleBBox.max.z.toFixed(2)})
                        isColliding: ${isColliding}`);
                    
                    // FORCE collision detection for duck obstacles using simplified logic
                    const playerX = LANE_POSITIONS[gameState.playerLane];
                    const obstacleX = obstacle.mesh.position.x;
                    const obstacleZ = obstacle.mesh.position.z;
                    
                    // Check if player is in same lane (X axis)
                    const inSameLane = Math.abs(playerX - obstacleX) < 1.0;
                    
                    // Check if obstacle is close enough in Z direction (approaching or passing)
                    const inCollisionZone = obstacleZ > -2 && obstacleZ < 2;
                    
                    // Check if player is too high (not ducking properly)
                    // BUGFIX: Reduced duck height from 0.6 to 0.4 for better collision avoidance
                    const playerHeight = gameState.playerAction === 'ducking' ? 0.4 : 1.5;
                    let obstacleHeight = 1.4; // Default duck obstacles height
                    
                    // Adjust for wallgap (gap bottom is at 1.3)
                    // FIXED: For wallgap, the obstacleHeight should be the bottom of the gap (1.3), not the gap size
                    // Player must be below this height to pass through
                    if (obstacle.type === 'wallgap') {
                        obstacleHeight = 1.3;
                    }
                    
                    // FIXED: Player needs to duck if their height exceeds the obstacle clearance height
                    const needsToDuck = playerHeight > obstacleHeight; // Must duck to fit under obstacle
                    
                    console.log(`🎯 Duck Logic: type=${obstacle.type}, inSameLane=${inSameLane}, inCollisionZone=${inCollisionZone}, needsToDuck=${needsToDuck}, playerHeight=${playerHeight}, obstacleHeight=${obstacleHeight}`);
                    
                    if (inSameLane && inCollisionZone && needsToDuck) {
                        console.log(`💥 DUCK COLLISION TRIGGERED! Player failed to duck.`);
                        handleCollision(obstacle, obstacleBBox);
                        return; // Exit after collision
                    } else if (inSameLane && inCollisionZone && !needsToDuck) {
                        console.log(`✅ DUCK SUCCESS! Player ducked properly.`);
                        // Give bonus points for successful ducking (handled in avoidance logic)
                    }
                }
                
                // Near-miss detection (close but not colliding)
                const nearMissDistance = 0.3; // Units for near-miss threshold
                const isNearMiss = !isColliding && boundingBoxDistance(playerBBox, obstacleBBox) < nearMissDistance;
                
                if (isColliding) {
                    // FEATURE 7: Check for high-speed destruction
                    const currentSpeed = gameState.speed * 1000; // Convert to display speed
                    const isBreakable = gameState.breakableObstacles.includes(obstacle.type);
                    const canDestroy = FeatureFlags.isEnabled('OBSTACLE_DESTRUCTION') && 
                                     currentSpeed > 200 && isBreakable && !gameState.flightMode;
                    
                    if (canDestroy || gameState.rampageActive) {
                        // Track feature usage
                        DevOpsMonitor.trackFeatureUsage('OBSTACLE_DESTRUCTION', 'destroyed');
                        // DESTRUCTION! 💥
                        handleObstacleDestruction(obstacle);
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        return; // Exit early - no collision damage
                    }
                    
                    // Check if player can avoid this collision
                    let canAvoid = false;
                    let avoidanceType = '';
                    
                    // Enhanced avoidance logic with precise hitbox checking
                    switch (obstacle.type) {
                        case 'lowbarrier':
                        case 'jumpblock':
                        case 'hurdleset':
                            // Must be jumped - check if player is high enough to clear
                            if (gameState.playerAction === 'jumping' && 
                                playerBBox.min.y > obstacleBBox.max.y - 0.2) {
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'highbarrier':
                        case 'duckbeam':
                        case 'wallgap':
                            // CRITICAL FIX: Overhead obstacles require ducking to avoid collision
                            // Player can ONLY avoid collision if they are ducking AND low enough
                            if (gameState.playerAction === 'ducking' && 
                                playerBBox.max.y < obstacleBBox.min.y + 0.2) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else {
                                // FORCE collision if not ducking or not low enough
                                canAvoid = false;
                                console.log(`🚨 OVERHEAD COLLISION: Player must duck! action=${gameState.playerAction}, playerMaxY=${playerBBox.max.y}, obstacleMinY=${obstacleBBox.min.y}`);
                            }
                            console.log(`🎯 Overhead obstacle: action=${gameState.playerAction}, playerMaxY=${playerBBox.max.y}, obstacleMinY=${obstacleBBox.min.y}, canAvoid=${canAvoid}`);
                            break;
                            
                        case 'spikes':
                            // Flexible - can jump over or duck under
                            if ((gameState.playerAction === 'jumping' && playerBBox.min.y > obstacleBBox.max.y - 0.2) ||
                                (gameState.playerAction === 'ducking' && playerBBox.max.y < obstacleBBox.min.y + 0.2)) {
                                canAvoid = true;
                                avoidanceType = gameState.playerAction === 'jumping' ? 'jump' : 'duck';
                            }
                            break;
                            
                        case 'rotatingblade':
                            // Rotating blades - can only be ducked under
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 0.8) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'swinginghammer':
                            // Swinging hammer - timing-based avoidance
                            // Check if hammer is in safe position
                            const hammerAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                            const isSafePosition = Math.abs(hammerAngle) < obstacle.swingAmplitude * 0.3; // Safe zone
                            
                            if (isSafePosition) {
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && Math.abs(hammerAngle) > obstacle.swingAmplitude * 0.7) {
                                // Can duck under when hammer is at extreme positions
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'movingwall':
                            // Moving wall - must time movement or jump
                            const wallPosition = obstacle.mesh.position.x;
                            const playerPosition = LANE_POSITIONS[gameState.playerLane];
                            const wallDistance = Math.abs(wallPosition - playerPosition);
                            
                            if (wallDistance > 1.0) {
                                // Wall is far enough away
                                canAvoid = true;
                                avoidanceType = 'dodge';
                            } else if (gameState.playerAction === 'jumping' && playerBBox.min.y > 1.5) {
                                // Can jump over the wall
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'bouncingball':
                            // Bouncing ball - timing-based avoidance or ducking
                            const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                            
                            if (ballHeight < 0.8) {
                                // Ball is low - can run through
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && ballHeight > 1.5) {
                                // Ball is high, player is ducking
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else if (gameState.playerAction === 'jumping' && ballHeight < 1.2 && playerBBox.min.y > ballHeight + 0.3) {
                                // Ball is medium height, player jumps over
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'spinninglaser':
                            // Spinning laser - only ducking helps
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 1.1) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                    }
                    
                    if (canAvoid) {
                        // SUCCESSFUL AVOIDANCE! - ENHANCED SKILL SYSTEM
                        let bonusScore = 50;
                        
                        // Precision bonus - closer calls get more points
                        const precision = 1 - (boundingBoxDistance(playerBBox, obstacleBBox) / nearMissDistance);
                        bonusScore += Math.floor(precision * 25);
                        
                        if (avoidanceType === 'jump') bonusScore += 25; // Jump bonus
                        if (avoidanceType === 'duck') {
                            bonusScore += 30; // Duck bonus - slightly higher for skill
                            console.log(`🦆 DUCK BONUS AWARDED: +30 points for ${obstacle.type} obstacle avoidance!`);
                            // Show duck bonus feedback
                            showSkillCombo(30, `DUCK MASTER! 🦆`);
                            
                            // DUCK CONFETTI: Celebration particle effect for successful ducking
                            const duckConfettiPos = obstacle.mesh.position.clone();
                            duckConfettiPos.y += 2.0; // Above the obstacle
                            createParticleEffect(duckConfettiPos, 0x00FF88, 'duckConfetti'); // Green confetti
                        }
                        
                        // ==================== ADVANCED SKILL TRACKING ====================
                        
                        const currentTime = performance.now();
                        
                        // Track consecutive avoidances for combo system
                        if (currentTime - gameState.lastAvoidanceTime < 3000) { // 3 second window
                            gameState.consecutiveAvoidances++;
                        } else {
                            gameState.consecutiveAvoidances = 1;
                        }
                        gameState.lastAvoidanceTime = currentTime;
                        
                        // Record this move in sequence for combo detection
                        const currentMove = `${avoidanceType}_${gameState.playerLane}`;
                        gameState.moveSequence.push({
                            move: currentMove,
                            action: avoidanceType,
                            lane: gameState.playerLane,
                            time: currentTime,
                            precision: precision
                        });
                        
                        // Keep only last 5 moves for combo detection
                        if (gameState.moveSequence.length > 5) {
                            gameState.moveSequence.shift();
                        }
                        
                        // ==================== COMBO DETECTION & REWARDS ====================
                        
                        let skillBonus = 0;
                        let comboMessage = '';
                        
                        // RAPID SEQUENCE BONUS (quick consecutive moves)
                        if (gameState.consecutiveAvoidances >= 2) {
                            const timeSinceLastMove = currentTime - gameState.lastSkillTime;
                            if (timeSinceLastMove < 1500) { // Less than 1.5 seconds = rapid!
                                skillBonus += gameState.consecutiveAvoidances * 30;
                                comboMessage = `RAPID x${gameState.consecutiveAvoidances}!`;
                                
                                // Extra bonus for very fast sequences
                                if (timeSinceLastMove < 800) {
                                    skillBonus += 50;
                                    comboMessage = `LIGHTNING FAST x${gameState.consecutiveAvoidances}!`;
                                }
                            }
                        }
                        
                        // LANE SWITCHING COMBO (left-right-left sequences)
                        if (gameState.moveSequence.length >= 3) {
                            const lastThree = gameState.moveSequence.slice(-3);
                            const lanes = lastThree.map(m => m.lane);
                            const actions = lastThree.map(m => m.action);
                            
                            // Check for lane switching patterns
                            if (lanes[0] !== lanes[1] && lanes[1] !== lanes[2] && lanes[0] !== lanes[2]) {
                                // Perfect zigzag pattern!
                                skillBonus += 100;
                                comboMessage = 'ZIGZAG MASTER!';
                                
                                // Check if it includes different actions (jump + duck + lane switch)
                                const uniqueActions = [...new Set(actions)];
                                if (uniqueActions.length >= 2) {
                                    skillBonus += 75;
                                    comboMessage = 'MIXED STYLE COMBO!';
                                }
                            }
                        }
                        
                        // PERFECT TIMING BONUS (high precision sequences)
                        if (precision > 0.85) {
                            gameState.perfectTimingCount++;
                            
                            // FEATURE 9: Track perfect moves for daily challenge
                            gameState.challengeStats.perfectMoves++;
                            
                            if (gameState.perfectTimingCount >= 3) {
                                skillBonus += 150;
                                comboMessage = 'PERFECT TIMING STREAK!';
                                gameState.perfectTimingCount = 0; // Reset for next streak
                            }
                        } else {
                            gameState.perfectTimingCount = 0; // Reset on imperfect timing
                        }
                        
                        // HIGH DIFFICULTY OBSTACLE BONUS
                        const difficultyBonus = {
                            'rotatingblade': 40,
                            'swinginghammer': 50,
                            'movingwall': 45,
                            'bouncingball': 35,
                            'spinninglaser': 60
                        };
                        
                        if (difficultyBonus[obstacle.type]) {
                            skillBonus += difficultyBonus[obstacle.type];
                            if (!comboMessage) comboMessage = 'SKILL MOVE!';
                        }
                        
                        // SPEED-BASED DIFFICULTY MULTIPLIER
                        const speedRatio = gameState.speed / gameState.maxSpeed;
                        if (speedRatio > 0.7) { // High speed bonus
                            const speedMultiplier = 1 + speedRatio;
                            skillBonus = Math.floor(skillBonus * speedMultiplier);
                            bonusScore = Math.floor(bonusScore * speedMultiplier);
                            if (comboMessage) comboMessage += ' @HIGH SPEED!';
                        }
                        
                        // Apply skill combo multiplier
                        if (gameState.consecutiveAvoidances >= 3) {
                            gameState.skillMultiplier = Math.min(3, 1 + (gameState.consecutiveAvoidances - 2) * 0.5);
                            skillBonus = Math.floor(skillBonus * gameState.skillMultiplier);
                        }
                        
                        gameState.lastSkillTime = currentTime;
                        
                        // ==================== APPLY REWARDS ====================
                        
                        const totalBonus = bonusScore + skillBonus;
                        addScore(totalBonus, 'avoidance_bonus');
                        
                        // Show skill combo UI if we got a bonus
                        if (skillBonus > 0) {
                            showSkillCombo(skillBonus, comboMessage);
                        }
                        
                        // Enhanced audio feedback with precision
                        if (precision > 0.8) {
                            audioManager.play('success'); // Perfect avoidance
                        } else {
                            audioManager.playSpeedDependentSound('coin', gameState.speed / gameState.maxSpeed);
                        }
                        
                        // Spectacular success particle effects
                        const effectPos = obstacle.mesh.position.clone();
                        const effectColor = avoidanceType === 'jump' ? 0x00FF00 : 0x00FFFF;
                        
                        createParticleEffect(effectPos, effectColor, 'success');
                        
                        // Precision-based additional effects
                        if (precision > 0.8) {
                            // Perfect execution - extra sparkles
                            createParticleEffect(
                                effectPos.clone().add(new THREE.Vector3(0, 1, 0)),
                                0xFFD700,
                                'success'
                            );
                            // Mini camera zoom for perfect execution
                            cameraZoomEffect(1.1, 200);
                        }
                        
                        // Score popup with precision indicator
                        showScorePopup(bonusScore, effectPos, precision > 0.8 ? 'PERFECT!' : 'NICE!');
                        
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        
                    } else {
                        // COLLISION DETECTED!
                        handleCollision(obstacle, obstacleBBox);
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                    }
                    
                } else if (isNearMiss && obstacle.z > -1 && obstacle.z < 1) {
                    // NEAR MISS BONUS! (only when very close)
                    handleNearMiss(obstacle, playerBBox, obstacleBBox);
                }
            });
            
            // ==================== POWER-UP COLLISION DETECTION ====================
            
            gameState.powerUps.forEach((powerUp, index) => {
                // Larger collision box for large magnet
                const boxSize = powerUp.type === 'largeMagnet' ? 0.8 : 0.4;
                const powerUpBBox = {
                    min: {
                        x: powerUp.mesh.position.x - boxSize,
                        y: powerUp.mesh.position.y - boxSize,
                        z: powerUp.mesh.position.z - boxSize
                    },
                    max: {
                        x: powerUp.mesh.position.x + boxSize,
                        y: powerUp.mesh.position.y + boxSize,
                        z: powerUp.mesh.position.z + boxSize
                    }
                };
                
                const isCollecting = boundingBoxIntersection(playerBBox, powerUpBBox);
                
                if (isCollecting && !powerUp.collected) {
                    powerUp.collected = true;
                    scene.remove(powerUp.mesh);
                    gameState.powerUps.splice(index, 1);
                    
                    // Try to add to fusion slot first
                    if (!gameState.activePowerUp && !gameState.activeFusion) {
                        if (addToFusionSlot(powerUp.type)) {
                            // Added to fusion slot
                            showScorePopup(0, player.position, 'FUSION SLOT!');
                        } else {
                            // Fusion slots full or duplicate, activate immediately
                            activatePowerUp(powerUp.type);
                        }
                    } else {
                        // Already have active power-up, activate immediately
                        activatePowerUp(powerUp.type);
                    }
                }
            });
            
            // ==================== KIWI COLLISION DETECTION ====================
            
            gameState.kiwis.forEach((kiwi, index) => {
                const kiwiBBox = {
                    min: {
                        x: kiwi.mesh.position.x - 0.35,
                        y: kiwi.mesh.position.y - 0.35,
                        z: kiwi.mesh.position.z - 0.35
                    },
                    max: {
                        x: kiwi.mesh.position.x + 0.35,
                        y: kiwi.mesh.position.y + 0.35,
                        z: kiwi.mesh.position.z + 0.35
                    }
                };
                
                // Magnet Power-Up Effect
                if (gameState.magnetActive || gameState.adrenalineActive) {
                    // Check for Rainbow Vacuum fusion
                    const isRainbowVacuum = gameState.activeFusion === 'magnet_speedboost';
                    const magnetRange = isRainbowVacuum ? 20.0 : (gameState.adrenalineActive ? 10.0 : 2.5);
                    const distance = Math.sqrt(
                        Math.pow(kiwi.mesh.position.x - player.position.x, 2) +
                        Math.pow(kiwi.mesh.position.y - player.position.y, 2) +
                        Math.pow(kiwi.mesh.position.z - player.position.z, 2)
                    );
                    
                    if ((distance < magnetRange || isRainbowVacuum) && !kiwi.collected) {
                        // Attract kiwi towards player
                        const attractionSpeed = isRainbowVacuum ? 0.5 : 0.15;
                        const direction = new THREE.Vector3()
                            .subVectors(player.position, kiwi.mesh.position)
                            .normalize()
                            .multiplyScalar(attractionSpeed);
                        
                        kiwi.mesh.position.add(direction);
                        
                        // Visual effect for magnet attraction
                        if (Math.random() > 0.8) {
                            createParticleEffect(
                                kiwi.mesh.position.clone(),
                                0x00FFFF,
                                'magnet'
                            );
                        }
                    }
                }
                
                const isCollecting = boundingBoxIntersection(playerBBox, kiwiBBox);
                
                if (isCollecting && !kiwi.collected) {
                    collectKiwi(kiwi);
                    gameState.kiwis.splice(index, 1);
                }
            });
            
            // ==================== BROCCOLI COLLISION DETECTION ====================
            
            gameState.broccolis.forEach((broccoli, index) => {
                const broccoliBBox = {
                    min: {
                        x: broccoli.mesh.position.x - 0.4,
                        y: broccoli.mesh.position.y - 0.4,
                        z: broccoli.mesh.position.z - 0.4
                    },
                    max: {
                        x: broccoli.mesh.position.x + 0.4,
                        y: broccoli.mesh.position.y + 0.4,
                        z: broccoli.mesh.position.z + 0.4
                    }
                };
                
                // Magnet Power-Up Effect (same as kiwis)
                if (gameState.magnetActive || gameState.adrenalineActive) {
                    // Check for Rainbow Vacuum fusion
                    const isRainbowVacuum = gameState.activeFusion === 'magnet_speedboost';
                    const magnetRange = isRainbowVacuum ? 20.0 : (gameState.adrenalineActive ? 10.0 : 2.5);
                    const distance = Math.sqrt(
                        Math.pow(broccoli.mesh.position.x - player.position.x, 2) +
                        Math.pow(broccoli.mesh.position.y - player.position.y, 2) +
                        Math.pow(broccoli.mesh.position.z - player.position.z, 2)
                    );
                    
                    if ((distance < magnetRange || isRainbowVacuum) && !broccoli.collected) {
                        const attractionSpeed = isRainbowVacuum ? 0.5 : 0.15;
                        const direction = new THREE.Vector3()
                            .subVectors(player.position, broccoli.mesh.position)
                            .normalize()
                            .multiplyScalar(attractionSpeed);
                        
                        broccoli.mesh.position.add(direction);
                        broccoli.z = broccoli.mesh.position.z;
                    }
                }
                
                const isCollecting = boundingBoxIntersection(playerBBox, broccoliBBox);
                
                if (isCollecting && !broccoli.collected) {
                    collectBroccoli(broccoli);
                    gameState.broccolis.splice(index, 1);
                }
            });
            
            // ==================== FEATURE 10: SCORE TOKEN COLLISION ====================
            
            gameState.scoreTokens.forEach((token, index) => {
                const tokenBBox = {
                    min: {
                        x: token.mesh.position.x - 0.5,
                        y: token.mesh.position.y - 0.5,
                        z: token.mesh.position.z - 0.5
                    },
                    max: {
                        x: token.mesh.position.x + 0.5,
                        y: token.mesh.position.y + 0.5,
                        z: token.mesh.position.z + 0.5
                    }
                };
                
                const isCollecting = boundingBoxIntersection(playerBBox, tokenBBox);
                
                if (isCollecting && !token.collected) {
                    collectScoreToken(token);
                    gameState.scoreTokens.splice(index, 1);
                }
            });
            
            // ==================== FEATURE 8: ROCKET BOOST PAD COLLISION ====================
            
            gameState.rocketBoostPads.forEach((pad, index) => {
                const padBBox = {
                    min: {
                        x: pad.mesh.position.x - 1.0,
                        y: pad.mesh.position.y - 0.5,
                        z: pad.mesh.position.z - 1.0
                    },
                    max: {
                        x: pad.mesh.position.x + 1.0,
                        y: pad.mesh.position.y + 0.5,
                        z: pad.mesh.position.z + 1.0
                    }
                };
                
                const isCollecting = boundingBoxIntersection(playerBBox, padBBox);
                
                if (isCollecting && !pad.collected && !gameState.flightMode) {
                    pad.collected = true;
                    scene.remove(pad.mesh);
                    gameState.rocketBoostPads.splice(index, 1);
                    
                    // Activate flight mode!
                    activateFlightMode();
                }
            });
            
            // ==================== FEATURE 8: AERIAL COLLECTIBLE COLLISION (FLIGHT MODE ONLY) ====================
            
            if (gameState.flightMode) {
                gameState.aerialCollectibles.forEach((aerial, index) => {
                    const aerialBBox = {
                        min: {
                            x: aerial.mesh.position.x - 0.5,
                            y: aerial.mesh.position.y - 0.5,
                            z: aerial.mesh.position.z - 0.5
                        },
                        max: {
                            x: aerial.mesh.position.x + 0.5,
                            y: aerial.mesh.position.y + 0.5,
                            z: aerial.mesh.position.z + 0.5
                        }
                    };
                    
                    // Extend player bbox for flight altitude
                    const flightBBox = {
                        min: new THREE.Vector3(
                            playerBBox.min.x,
                            playerBBox.min.y + gameState.flightAltitude,
                            playerBBox.min.z
                        ),
                        max: new THREE.Vector3(
                            playerBBox.max.x,
                            playerBBox.max.y + gameState.flightAltitude,
                            playerBBox.max.z
                        )
                    };
                    
                    const isCollecting = boundingBoxIntersection(flightBBox, aerialBBox);
                    
                    if (isCollecting && !aerial.collected) {
                        aerial.collected = true;
                        scene.remove(aerial.mesh);
                        gameState.aerialCollectibles.splice(index, 1);
                        
                        // Double points for aerial collectibles
                        addScore(aerial.value, 'aerial_collectible');
                        
                        // Collect as normal kiwi/broccoli
                        if (aerial.type === 'kiwi') {
                            gameState.collectedKiwis++;
                            audioManager.play('coin');
                        } else {
                            gameState.collectedBroccolis++;
                            audioManager.play('powerup');
                        }
                        
                        // Update UI
                        updateKiwiUI();
                        
                        // Show bonus message
                        showScorePopup(aerial.value, aerial.mesh.position, 'AERIAL BONUS!');
                        
                        // Aerial collection particles
                        createParticleEffect(aerial.mesh.position, 0x00CCFF, 'success');
                    }
                });
            }
        }
        
        // Calculate precise player bounding box based on current action
        function calculatePlayerBoundingBox() {
            const playerX = LANE_POSITIONS[gameState.playerLane];
            const playerY = gameState.playerY;
            
            let width = 0.8;  // Player width
            let height = 1.5; // Player height
            let depth = 0.6;  // Player depth
            
            // Adjust hitbox based on action
            if (gameState.playerAction === 'ducking') {
                height = 0.4; // Reduced from 0.6 to 0.4 for better obstacle clearance
                depth = 0.8; // Slightly larger depth when ducking
            } else if (gameState.playerAction === 'jumping') {
                // Tighter hitbox when jumping for more precise collision
                width = 0.7;
                depth = 0.5;
            }
            
            return {
                min: new THREE.Vector3(
                    playerX - width/2,
                    playerY,
                    -depth/2
                ),
                max: new THREE.Vector3(
                    playerX + width/2,
                    playerY + height,
                    depth/2
                )
            };
        }
        
        // Calculate obstacle bounding box based on type and mesh
        function calculateObstacleBoundingBox(obstacle) {
            const pos = obstacle.mesh.position;
            let width, height, depth;
            
            // Obstacle-specific bounding box dimensions
            switch (obstacle.type) {
                case 'lowbarrier':
                    width = 1.5; height = 0.8; depth = 0.3;
                    break;
                case 'highbarrier':
                    width = 1.8; height = 0.4; depth = 0.3;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'jumpblock':
                    width = 1.2; height = 1.2; depth = 1.2;
                    break;
                case 'spikes':
                    width = 0.5; height = 0.6; depth = 0.5;
                    break;
                case 'duckbeam':
                    width = 2.2; height = 0.3; depth = 0.8;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'hurdleset':
                    width = 1.4; height = 0.7; depth = 1.5; // Covers multiple hurdles
                    break;
                case 'wallgap':
                    width = 1.8; height = 1.3; depth = 0.4;
                    // Gap height consideration
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.3, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 2.5, pos.z + depth/2)
                    };
                case 'rotatingblade':
                    // Dynamic hitbox based on rotation - always dangerous
                    width = 2.2; height = 2; depth = 0.4;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'swinginghammer':
                    // Dynamic hitbox for swinging hammer - wider danger zone
                    width = 2.5; height = 1.8; depth = 0.8;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'movingwall':
                    // Moving wall uses actual position
                    width = 0.4; height = 2; depth = 1;
                    break;
                case 'bouncingball':
                    // Dynamic hitbox based on ball position
                    const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                    width = 1.2; height = ballHeight + 0.6; depth = 1.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'spinninglaser':
                    // Laser beam danger zone - wider when spinning
                    width = 3.2; height = 1.4; depth = 3.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.1, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.3, pos.z + depth/2)
                    };
                default:
                    width = 1.0; height = 1.0; depth = 1.0;
            }
            
            return {
                min: new THREE.Vector3(
                    pos.x - width/2,
                    pos.y,
                    pos.z - depth/2
                ),
                max: new THREE.Vector3(
                    pos.x + width/2,
                    pos.y + height,
                    pos.z + depth/2
                )
            };
        }
        
        // Check if two 3D bounding boxes intersect
        function boundingBoxIntersection(bbox1, bbox2) {
            return (bbox1.min.x <= bbox2.max.x && bbox1.max.x >= bbox2.min.x) &&
                   (bbox1.min.y <= bbox2.max.y && bbox1.max.y >= bbox2.min.y) &&
                   (bbox1.min.z <= bbox2.max.z && bbox1.max.z >= bbox2.min.z);
        }
        
        // Calculate minimum distance between two bounding boxes
        function boundingBoxDistance(bbox1, bbox2) {
            const dx = Math.max(0, Math.max(bbox1.min.x - bbox2.max.x, bbox2.min.x - bbox1.max.x));
            const dy = Math.max(0, Math.max(bbox1.min.y - bbox2.max.y, bbox2.min.y - bbox1.max.y));
            const dz = Math.max(0, Math.max(bbox1.min.z - bbox2.max.z, bbox2.min.z - bbox1.max.z));
            
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // Enhanced collision handling with type-specific effects
        function handleCollision(obstacle, obstacleBBox) {
            // Check if shield is active (including adrenaline invincibility)
            if (gameState.shieldActive || gameState.adrenalineActive) {
                // Shield/Adrenaline absorbs the hit!
                if (!gameState.adrenalineActive) {
                    deactivatePowerUp(); // Remove shield after one hit (not during adrenaline)
                }
                
                // Shield absorption effects
                const shieldPos = player.position.clone();
                createParticleEffect(shieldPos, 0x00AAFF, 'shield');
                
                // Shield audio feedback
                audioManager.createTone(600, 0.2, 'square');
                audioManager.createTone(400, 0.3, 'square');
                
                // Mild screen flash for shield activation
                screenShake(0.1, 200);
                
                // Show protection message
                showScorePopup(0, shieldPos, 'PROTECTED!');
                
                console.log('Shield absorbed collision!');
                return; // Exit early - no damage taken
            }
            
            // Slow motion for dramatic effect
            startSlowMotion(1000);
            
            // Type-specific collision audio
            audioManager.play('collision');
            
            // Lose life
            loseLife();
            
            // Reset perfect streak
            updatePerfectStreak(false);
            
            // Enhanced collision effects based on obstacle material
            const collisionPos = obstacle.mesh.position.clone();
            let effectColor = 0xFF4444;
            
            switch (obstacle.type) {
                case 'jumpblock':
                case 'wallgap':
                    effectColor = 0x888888; // Concrete dust
                    break;
                case 'duckbeam':
                    effectColor = 0x4682B4; // Metal sparks
                    break;
                case 'spikes':
                    effectColor = 0xFF4500; // Fire/sparks
                    break;
            }
            
            // Use new enhanced collision particle system
            createCollisionParticles(collisionPos, obstacle.type);
            
            // Additional dust clouds at ground level
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const dustPos = new THREE.Vector3(
                        player.position.x + (Math.random() - 0.5) * 2,
                        0.1,
                        player.position.z + (Math.random() - 0.5)
                    );
                    createParticleEffect(dustPos, 0x8B7355, 'dust');
                }, i * 100);
            }
            
            // Screen shake intensity based on obstacle size
            const shakeIntensity = Math.min(0.5, (obstacleBBox.max.y - obstacleBBox.min.y) * 0.3);
            screenShake(shakeIntensity, 600);
            
            // Camera zoom for impact
            cameraZoomEffect(1.25, 400);
        }
        
        // ==================== POWER-UP SYSTEM ====================
        
        function createPowerUp(type, lane, z) {
            const powerUpConfig = POWER_UP_TYPES[type];
            const powerUpGroup = new THREE.Group();
            
            // Main power-up body - rotating cube
            const powerUpGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const powerUpMaterial = new THREE.MeshLambertMaterial({ 
                color: powerUpConfig.color,
                emissive: powerUpConfig.color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            const powerUpMesh = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUpMesh.position.y = 1.5; // Floating height
            powerUpMesh.castShadow = true;
            powerUpGroup.add(powerUpMesh);
            
            // Glowing ring around power-up
            const ringGeometry = new THREE.RingGeometry(0.6, 0.8);
            const ringMaterial = new THREE.MeshLambertMaterial({ 
                color: powerUpConfig.color,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            powerUpGroup.add(ring);
            
            // Particle effect (simulated with small spheres)
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05);
                const particleMaterial = new THREE.MeshLambertMaterial({ 
                    color: powerUpConfig.color,
                    emissive: powerUpConfig.color,
                    emissiveIntensity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                particle.position.set(
                    Math.cos(angle) * 1.2,
                    1.5 + Math.sin(i) * 0.3,
                    Math.sin(angle) * 1.2
                );
                powerUpGroup.add(particle);
            }
            
            powerUpGroup.position.set(LANE_POSITIONS[lane], 0, z);
            scene.add(powerUpGroup);
            
            // Store power-up data
            const powerUpData = {
                mesh: powerUpGroup,
                type: type,
                lane: lane,
                z: z,
                animationTime: 0,
                collected: false
            };
            
            powerUps.push(powerUpData);
            return powerUpData;
        }
        
        function createKiwi(lane, z, pattern = 'single') {
            const kiwiGroup = new THREE.Group();
            
            // REALISTIC KIWI: Much larger and more visible (like real kiwi fruit)
            const kiwiRadiusX = 0.6;   // Much wider for visibility
            const kiwiRadiusY = 0.8;   // Much taller - real kiwi proportions 
            const kiwiRadiusZ = 0.6;   // Much deeper for 3D effect
            
            // ENHANCED: Elongated ellipsoid shape for realistic kiwi appearance
            const kiwiGeometry = new THREE.SphereGeometry(1, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.8);
            kiwiGeometry.scale(kiwiRadiusX, kiwiRadiusY, kiwiRadiusZ);  // Create oval/ellipsoid
            
            // REALISTIC KIWI SKIN: Brown fuzzy exterior like real kiwi
            const skinMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,  // Realistic brown kiwi skin color
                emissive: 0x2F1B14,  // Subtle brown glow
                roughness: 0.9  // Very rough for fuzzy skin effect
            });
            const kiwiSkin = new THREE.Mesh(kiwiGeometry, skinMaterial);
            kiwiSkin.rotation.x = -Math.PI / 2;
            kiwiSkin.position.y = 1.2;
            kiwiSkin.castShadow = true;
            kiwiGroup.add(kiwiSkin);
            
            // ENHANCED: Zusätzliche braune Textur-Ringe für bessere Kiwi-Optik (angepasst für oval)
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.RingGeometry(kiwiRadiusX * 0.7 + i * 0.04, kiwiRadiusX * 0.75 + i * 0.04, 16);
                const ringMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,  // Dunklere braune Streifen
                    transparent: true,
                    opacity: 0.4
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 1.21 + i * 0.001;
                kiwiGroup.add(ring);
            }
            
            // Grünes Fruchtfleisch (elliptische Unterseite)
            const fleshGeometry = new THREE.EllipseGeometry ? 
                new THREE.EllipseGeometry(kiwiRadiusX * 0.95, kiwiRadiusZ * 0.95) :
                new THREE.CircleGeometry(kiwiRadiusX * 0.95, 32);
            const fleshMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8FBC8F,
                emissive: 0x2F5F2F,
                emissiveIntensity: 0.2
            });
            const kiwiFlesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
            kiwiFlesh.rotation.x = -Math.PI / 2;
            kiwiFlesh.position.y = 1.2;
            kiwiGroup.add(kiwiFlesh);
            
            // Weißer Kern in der Mitte (angepasst für oval)
            const coreGeometry = new THREE.CircleGeometry(kiwiRadiusX * 0.3, 16);
            const coreMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF5F5DC,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.1
            });
            const kiwiCore = new THREE.Mesh(coreGeometry, coreMaterial);
            kiwiCore.rotation.x = -Math.PI / 2;
            kiwiCore.position.y = 1.201;
            kiwiGroup.add(kiwiCore);
            
            // Schwarze Kerne/Samen (elliptisch verteilt)
            const seedCount = 12;
            for (let i = 0; i < seedCount; i++) {
                const angle = (i / seedCount) * Math.PI * 2;
                const distanceX = kiwiRadiusX * 0.5 + Math.random() * kiwiRadiusX * 0.2;
                const distanceZ = kiwiRadiusZ * 0.5 + Math.random() * kiwiRadiusZ * 0.2;
                
                const seedGeometry = new THREE.CircleGeometry(0.02, 4);
                const seedMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x000000
                });
                const seed = new THREE.Mesh(seedGeometry, seedMaterial);
                seed.rotation.x = -Math.PI / 2;
                seed.position.set(
                    Math.cos(angle) * distanceX,  // Use elliptical X coordinate
                    1.202,
                    Math.sin(angle) * distanceZ   // Use elliptical Z coordinate
                );
                kiwiGroup.add(seed);
            }
            
            // Glanz-Effekt für Frische
            const glintGeometry = new THREE.CircleGeometry(0.08, 8);
            const glintMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.6,
                transparent: true,
                opacity: 0.7
            });
            const glint = new THREE.Mesh(glintGeometry, glintMaterial);
            glint.rotation.x = -Math.PI / 2;
            glint.position.set(kiwiRadius * 0.4, 1.203, kiwiRadius * 0.3);
            kiwiGroup.add(glint);
            
            kiwiGroup.position.set(LANE_POSITIONS[lane], 0, z);
            scene.add(kiwiGroup);
            
            // Store kiwi data
            const kiwiData = {
                mesh: kiwiGroup,
                lane: lane,
                z: z,
                pattern: pattern,
                animationTime: 0,
                collected: false
            };
            
            kiwis.push(kiwiData);
            // REMOVED: totalCollectibles++ causes premature spawn stopping
            return kiwiData;
        }
        
        // NEW: Brokkoli creation function for variety
        function createBroccoli(lane, z, pattern = 'single') {
            const broccoliGroup = new THREE.Group();
            
            // Brokkoli Geometrie - Baum-ähnliche Form
            const stemRadius = 0.15;
            const stemHeight = 0.4;
            const headRadius = 0.4;
            
            // Stiel (Stamm)
            const stemGeometry = new THREE.CylinderGeometry(stemRadius, stemRadius * 1.2, stemHeight, 8);
            const stemMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A6741,  // Dunkles Grün für Stiel
                emissive: 0x1A241A
            });
            const broccoliStem = new THREE.Mesh(stemGeometry, stemMaterial);
            broccoliStem.position.y = 1.0;
            broccoliStem.castShadow = true;
            broccoliGroup.add(broccoliStem);
            
            // Kopf (florettes) - mehrere kleine Kugeln
            for (let i = 0; i < 8; i++) {
                const floretGeometry = new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 8, 6);
                const floretMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x228B22,  // Helleres Grün für Florettes
                    emissive: 0x0F3F0F,  // Grünes Glühen
                    roughness: 0.7
                });
                const floret = new THREE.Mesh(floretGeometry, floretMaterial);
                
                // Zufällige Position um den Kopf
                const angle = (i / 8) * Math.PI * 2;
                const radius = 0.2 + Math.random() * 0.15;
                floret.position.set(
                    Math.cos(angle) * radius,
                    1.25 + Math.random() * 0.2,
                    Math.sin(angle) * radius
                );
                floret.castShadow = true;
                broccoliGroup.add(floret);
            }
            
            // Position and add to scene
            broccoliGroup.position.set(LANE_POSITIONS[lane], 0, z);
            broccoliGroup.userData = { type: 'broccoli', lane: lane };
            scene.add(broccoliGroup);
            
            // Brokkoli data object
            const broccoliData = {
                mesh: broccoliGroup,
                lane: lane,
                z: z,
                pattern: pattern,
                animationTime: 0,
                collected: false
            };
            
            broccolis.push(broccoliData);
            // REMOVED: totalCollectibles++ causes premature spawn stopping  
            return broccoliData;
        }
        
        function createKiwiPattern(type, baseZ) {
            switch (type) {
                case 'line':
                    // 3 kiwis in a horizontal line
                    for (let i = 0; i < 3; i++) {
                        createKiwi(i, baseZ, 'line');
                    }
                    break;
                case 'arc':
                    // 5 kiwis in a vertical arc
                    for (let i = 0; i < 5; i++) {
                        const lane = Math.floor(Math.random() * 3);
                        createKiwi(lane, baseZ - i * 2, 'arc');
                    }
                    break;
                case 'single':
                default:
                    // Single kiwi
                    const lane = Math.floor(Math.random() * 3);
                    createKiwi(lane, baseZ, 'single');
                    break;
            }
        }
        
        function activatePowerUp(type) {
            const config = POWER_UP_TYPES[type];
            
            // Deactivate any existing power-up
            if (gameState.activePowerUp) {
                deactivatePowerUp();
            }
            
            // Activate new power-up
            gameState.activePowerUp = type;
            gameState.powerUpTimeRemaining = config.duration;
            gameState[config.effect] = true;
            
            // Visual feedback
            createParticleEffect(
                player.position.clone(),
                config.color,
                'powerup'
            );
            
            // Audio feedback
            audioManager.play('powerup');
            
            // Screen flash effect
            screenShake(0.15, 200);
            
            // Update UI
            updatePowerUpUI();
            
            console.log(`Activated ${config.name} for ${config.duration/1000} seconds`);
        }
        
        function deactivatePowerUp() {
            if (!gameState.activePowerUp) return;
            
            const config = POWER_UP_TYPES[gameState.activePowerUp];
            gameState[config.effect] = false;
            gameState.activePowerUp = null;
            gameState.powerUpTimeRemaining = 0;
            
            // Update UI
            updatePowerUpUI();
            
            console.log(`Deactivated ${config.name}`);
        }
        
        function updatePowerUpUI() {
            const powerUpDisplay = document.getElementById('powerUpDisplay');
            const powerUpIcon = document.getElementById('powerUpIcon');
            const powerUpName = document.getElementById('powerUpName');
            const powerUpTime = document.getElementById('powerUpTime');
            
            if (gameState.activePowerUp || gameState.activeFusion) {
                if (gameState.activeFusion) {
                    const fusion = FUSION_COMBINATIONS[gameState.activeFusion];
                    powerUpDisplay.style.display = 'block';
                    powerUpIcon.textContent = fusion.icon;
                    powerUpName.textContent = fusion.name;
                    powerUpTime.textContent = Math.ceil(gameState.fusionTimeRemaining / 1000);
                } else {
                    const config = POWER_UP_TYPES[gameState.activePowerUp];
                    powerUpDisplay.style.display = 'block';
                    powerUpIcon.textContent = config.icon;
                    powerUpName.textContent = config.name;
                    powerUpTime.textContent = Math.ceil(gameState.powerUpTimeRemaining / 1000);
                }
            } else {
                powerUpDisplay.style.display = 'none';
            }
        }
        
        // Fusion System Functions
        function initializeFusionSystem() {
            const slot1 = document.getElementById('fusionSlot1');
            const slot2 = document.getElementById('fusionSlot2');
            const combineBtn = document.getElementById('fusionCombineBtn');
            
            // Click handlers for slots
            slot1.addEventListener('click', () => clearFusionSlot(0));
            slot2.addEventListener('click', () => clearFusionSlot(1));
            
            // Combine button handler
            combineBtn.addEventListener('click', () => {
                if (gameState.fusionSlots[0] && gameState.fusionSlots[1]) {
                    executeFusion();
                }
            });
        }
        
        function addToFusionSlot(powerUpType) {
            // Check if power-up fusion feature is enabled
            if (!FeatureFlags.isEnabled('POWER_UP_FUSION')) {
                return false;
            }
            
            // Find empty slot
            const emptySlotIndex = gameState.fusionSlots.findIndex(slot => slot === null);
            if (emptySlotIndex === -1) return false; // No empty slots
            
            // Don't add largeMagnet - convert to regular magnet
            const typeToAdd = powerUpType === 'largeMagnet' ? 'magnet' : powerUpType;
            
            // Don't add duplicates
            if (gameState.fusionSlots.includes(typeToAdd)) return false;
            
            gameState.fusionSlots[emptySlotIndex] = typeToAdd;
            updateFusionUI();
            
            // Play slot fill sound
            audioManager.createTone(400 + emptySlotIndex * 200, 0.1, 'sine');
            
            return true;
        }
        
        function clearFusionSlot(index) {
            if (gameState.fusionSlots[index]) {
                gameState.fusionSlots[index] = null;
                updateFusionUI();
                audioManager.createTone(200, 0.1, 'sine');
            }
        }
        
        function updateFusionUI() {
            const slot1 = document.getElementById('fusionSlot1');
            const slot2 = document.getElementById('fusionSlot2');
            const combineBtn = document.getElementById('fusionCombineBtn');
            
            // Update slot 1
            if (gameState.fusionSlots[0]) {
                const config = POWER_UP_TYPES[gameState.fusionSlots[0]];
                slot1.textContent = config.icon;
                slot1.classList.add('filled');
            } else {
                slot1.textContent = '';
                slot1.classList.remove('filled', 'ready');
            }
            
            // Update slot 2
            if (gameState.fusionSlots[1]) {
                const config = POWER_UP_TYPES[gameState.fusionSlots[1]];
                slot2.textContent = config.icon;
                slot2.classList.add('filled');
            } else {
                slot2.textContent = '';
                slot2.classList.remove('filled', 'ready');
            }
            
            // Check if fusion is ready
            if (gameState.fusionSlots[0] && gameState.fusionSlots[1]) {
                const fusionKey = [gameState.fusionSlots[0], gameState.fusionSlots[1]].sort().join('_');
                if (FUSION_COMBINATIONS[fusionKey]) {
                    slot1.classList.add('ready');
                    slot2.classList.add('ready');
                    combineBtn.classList.add('active');
                } else {
                    combineBtn.classList.remove('active');
                }
            } else {
                combineBtn.classList.remove('active');
            }
        }
        
        function executeFusion() {
            const fusionKey = [gameState.fusionSlots[0], gameState.fusionSlots[1]].sort().join('_');
            const fusion = FUSION_COMBINATIONS[fusionKey];
            
            if (!fusion) {
                // Invalid combination
                screenShake(0.2, 300);
                audioManager.createNoise(0.3, 100);
                console.log('Invalid fusion combination!');
                return;
            }
            
            // Clear any active power-ups
            if (gameState.activePowerUp) {
                deactivatePowerUp();
            }
            if (gameState.activeFusion) {
                deactivateFusion();
            }
            
            // Activate fusion
            gameState.activeFusion = fusionKey;
            gameState.fusionTimeRemaining = fusion.duration;
            
            // Apply fusion effects
            fusion.effects.forEach(effect => {
                gameState[effect] = true;
            });
            
            // Apply special fusion properties
            if (fusion.speedMultiplier) {
                gameState.baseSpeed = gameState.baseSpeed * fusion.speedMultiplier;
            }
            
            // Clear fusion slots
            gameState.fusionSlots = [null, null];
            updateFusionUI();
            
            // Epic fusion effects
            createFusionAnimation(fusion);
            
            // Update UI
            updatePowerUpUI();
            
            console.log(`Activated fusion: ${fusion.name}!`);
        }
        
        function deactivateFusion() {
            if (!gameState.activeFusion) return;
            
            const fusion = FUSION_COMBINATIONS[gameState.activeFusion];
            
            // Remove fusion effects
            fusion.effects.forEach(effect => {
                gameState[effect] = false;
            });
            
            // Reset special properties
            if (fusion.speedMultiplier) {
                gameState.baseSpeed = 0.08; // Reset to default
            }
            
            gameState.activeFusion = null;
            gameState.fusionTimeRemaining = 0;
            
            updatePowerUpUI();
            console.log(`Deactivated fusion: ${fusion.name}`);
        }
        
        function createFusionAnimation(fusion) {
            // Create epic fusion particle explosion
            const fusionPos = player.position.clone();
            fusionPos.y += 2;
            
            // Multiple particle bursts
            for (let i = 0; i < 50; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1 + Math.random() * 0.2),
                    new THREE.MeshBasicMaterial({ color: fusion.color })
                );
                
                particle.position.copy(fusionPos);
                const angle = (i / 50) * Math.PI * 2;
                particle.velocity = new THREE.Vector3(
                    Math.cos(angle) * 5,
                    Math.random() * 5,
                    Math.sin(angle) * 5
                );
                particle.lifetime = 1000;
                
                scene.add(particle);
                particles.push(particle);
            }
            
            // Screen flash
            screenShake(0.3, 500);
            
            // Epic sound
            audioManager.createTone(200, 0.5, 'sawtooth');
            audioManager.createTone(400, 0.5, 'square');
            audioManager.createTone(800, 0.5, 'sine');
            
            // Add glow effect if specified
            if (fusion.glowEffect) {
                const glow = new THREE.PointLight(fusion.color, 2, 10);
                glow.position.copy(player.position);
                player.add(glow);
                
                // Fade out glow over time
                const fadeGlow = setInterval(() => {
                    glow.intensity *= 0.95;
                    if (glow.intensity < 0.1) {
                        player.remove(glow);
                        clearInterval(fadeGlow);
                    }
                }, 100);
            }
        }
        
        // Adrenaline Mode Functions
        function updatePerfectStreak(avoided) {
            if (avoided) {
                gameState.perfectStreak++;
                console.log(`Perfect streak: ${gameState.perfectStreak}`);
                
                // Update UI
                updatePerfectStreakUI();
                
                // Check for adrenaline mode activation
                if (gameState.perfectStreak >= 10 && !gameState.adrenalineActive) {
                    activateAdrenalineMode();
                }
            } else {
                // Reset streak on collision
                gameState.perfectStreak = 0;
                updatePerfectStreakUI();
            }
        }
        
        function activateAdrenalineMode() {
            // Check if adrenaline mode feature is enabled
            if (!FeatureFlags.isEnabled('ADRENALINE_MODE')) {
                return;
            }
            
            // Track feature usage
            DevOpsMonitor.trackFeatureUsage('ADRENALINE_MODE', 'activated');
            
            gameState.adrenalineActive = true;
            gameState.adrenalineTimeRemaining = 5000; // 5 seconds
            gameState.timeScaleFactor = 0.3; // Slow motion to 30% speed
            
            // Visual effects
            document.getElementById('adrenalineOverlay').classList.add('active');
            createMatrixEffect();
            
            // Audio effects
            audioManager.setPlaybackRate(0.7); // Slow down audio
            audioManager.createTone(100, 1.0, 'sine'); // Deep bass tone
            
            // Make all collectibles magnetic during adrenaline
            gameState.magnetActive = true;
            
            // Invincibility
            gameState.shieldActive = true;
            
            console.log('ADRENALINE MODE ACTIVATED!');
            showScorePopup(1000, player.position, 'ADRENALINE MODE!');
        }
        
        function deactivateAdrenalineMode() {
            gameState.adrenalineActive = false;
            gameState.adrenalineTimeRemaining = 0;
            gameState.timeScaleFactor = 1.0; // Normal speed
            
            // Remove visual effects
            document.getElementById('adrenalineOverlay').classList.remove('active');
            clearMatrixEffect();
            
            // Reset audio
            audioManager.setPlaybackRate(1.0);
            
            // Remove temporary effects
            if (!gameState.activePowerUp || POWER_UP_TYPES[gameState.activePowerUp].effect !== 'magnetActive') {
                gameState.magnetActive = false;
            }
            if (!gameState.activePowerUp || POWER_UP_TYPES[gameState.activePowerUp].effect !== 'shieldActive') {
                gameState.shieldActive = false;
            }
            
            // Reset perfect streak
            gameState.perfectStreak = 0;
            updatePerfectStreakUI();
            
            console.log('Adrenaline mode ended');
        }
        
        function updatePerfectStreakUI() {
            const display = document.getElementById('perfectStreakDisplay');
            const count = document.getElementById('streakCount');
            const status = document.getElementById('adrenalineStatus');
            
            if (gameState.perfectStreak > 0) {
                display.classList.add('active');
                count.textContent = gameState.perfectStreak;
                
                if (gameState.adrenalineActive) {
                    status.textContent = 'ADRENALINE ACTIVE!';
                    status.style.display = 'block';
                } else if (gameState.perfectStreak >= 7) {
                    status.textContent = `${10 - gameState.perfectStreak} more for ADRENALINE!`;
                    status.style.display = 'block';
                } else {
                    status.style.display = 'none';
                }
            } else {
                display.classList.remove('active');
            }
        }
        
        function createMatrixEffect() {
            const matrixContainer = document.getElementById('matrixLines');
            matrixContainer.classList.add('active');
            
            // Create falling matrix lines
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const line = document.createElement('div');
                    line.className = 'matrix-line';
                    line.style.left = Math.random() * 100 + '%';
                    line.style.animationDelay = Math.random() * 2 + 's';
                    line.style.animationDuration = (1 + Math.random()) + 's';
                    matrixContainer.appendChild(line);
                }, i * 100);
            }
        }
        
        function clearMatrixEffect() {
            const matrixContainer = document.getElementById('matrixLines');
            matrixContainer.classList.remove('active');
            matrixContainer.innerHTML = '';
        }
        
        // ==================== FEATURE 7: OBSTACLE DESTRUCTION & RAMPAGE MODE ====================
        
        function handleObstacleDestruction(obstacle) {
            const currentTime = Date.now();
            
            // Update destruction streak
            if (currentTime - gameState.lastDestructionTime < 10000) { // 10 second window
                gameState.destructionStreak++;
            } else {
                gameState.destructionStreak = 1;
            }
            gameState.lastDestructionTime = currentTime;
            gameState.totalDestroyed++;
            
            // Score bonus for destruction
            const destructionBonus = 100 + (gameState.destructionStreak * 50);
            addScore(destructionBonus, 'obstacle_destruction');
            
            // Show destruction feedback
            showScorePopup(destructionBonus, obstacle.mesh.position, `DESTROYED! x${gameState.destructionStreak}`);
            
            // Destruction effects
            createDestructionEffect(obstacle);
            
            // Check for rampage mode activation
            if (gameState.destructionStreak >= 5 && !gameState.rampageActive) {
                activateRampageMode();
            }
            
            // Update UI
            updateRampageUI();
            
            console.log(`💥 Destroyed ${obstacle.type}! Streak: ${gameState.destructionStreak}`);
        }
        
        function createDestructionEffect(obstacle) {
            const pos = obstacle.mesh.position.clone();
            
            // Screen shake based on obstacle size
            screenShake(0.3, 400);
            
            // Explosion particles
            createParticleEffect(pos, 0xFF4444, 'explosion');
            
            // Debris particles
            for (let i = 0; i < 20; i++) {
                const debris = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.2, 0.2),
                    new THREE.MeshLambertMaterial({ color: obstacle.mesh.children[0]?.material?.color || 0x888888 })
                );
                
                debris.position.copy(pos);
                debris.position.x += (Math.random() - 0.5) * 2;
                debris.position.y += Math.random() * 2;
                debris.position.z += (Math.random() - 0.5) * 2;
                
                debris.rotation.set(
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 2
                );
                
                debris.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    Math.random() * 8 + 2,
                    (Math.random() - 0.5) * 10
                );
                
                debris.angularVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                
                debris.lifetime = 2000;
                scene.add(debris);
                
                // Animate debris
                const animateDebris = () => {
                    if (debris.lifetime <= 0) {
                        scene.remove(debris);
                        return;
                    }
                    
                    debris.position.add(debris.velocity.clone().multiplyScalar(0.016));
                    debris.velocity.y -= 0.3; // Gravity
                    
                    debris.rotation.x += debris.angularVelocity.x * 0.016;
                    debris.rotation.y += debris.angularVelocity.y * 0.016;
                    debris.rotation.z += debris.angularVelocity.z * 0.016;
                    
                    debris.lifetime -= 16;
                    debris.material.opacity = debris.lifetime / 2000;
                    debris.material.transparent = true;
                    
                    requestAnimationFrame(animateDebris);
                };
                animateDebris();
            }
            
            // Dust cloud
            createParticleEffect(pos, 0x8B7355, 'dust');
            
            // Explosion ring
            createExplosionRing(pos, 0xFF6600);
            
            // Sound effects
            audioManager.play('collision');
            audioManager.createNoise(0.3, 500); // Crash sound
        }
        
        function activateRampageMode() {
            gameState.rampageActive = true;
            gameState.rampageTimeRemaining = 10000; // 10 seconds
            gameState.rampageStartTime = Date.now();
            
            // Make player invincible
            gameState.invulnerable = true;
            gameState.invulnerabilityTime = 10000;
            
            // Visual effects
            document.getElementById('rampageOverlay').classList.add('active');
            document.getElementById('rampageDisplay').style.display = 'block';
            
            // Player glow effect
            const rampageGlow = new THREE.PointLight(0xFF0000, 3, 10);
            rampageGlow.position.copy(player.position);
            player.add(rampageGlow);
            player.userData.rampageGlow = rampageGlow;
            
            // Sound effects
            audioManager.createTone(50, 1.0, 'sawtooth'); // Deep rumble
            
            console.log('💪 RAMPAGE MODE ACTIVATED!');
            showScorePopup(500, player.position, 'RAMPAGE MODE!');
        }
        
        function deactivateRampageMode() {
            gameState.rampageActive = false;
            gameState.rampageTimeRemaining = 0;
            gameState.destructionStreak = 0;
            
            // Remove invincibility (unless from another source)
            if (!gameState.shieldActive && !gameState.adrenalineActive) {
                gameState.invulnerable = false;
                gameState.invulnerabilityTime = 0;
            }
            
            // Remove visual effects
            document.getElementById('rampageOverlay').classList.remove('active');
            document.getElementById('rampageDisplay').style.display = 'none';
            
            // Remove player glow
            if (player.userData.rampageGlow) {
                player.remove(player.userData.rampageGlow);
                delete player.userData.rampageGlow;
            }
            
            console.log('Rampage mode deactivated');
        }
        
        function updateRampageUI() {
            const rampageDisplay = document.getElementById('rampageDisplay');
            const rampageTime = document.getElementById('rampageTime');
            const destructionStreak = document.getElementById('destructionStreak');
            
            if (gameState.rampageActive) {
                rampageTime.textContent = Math.ceil(gameState.rampageTimeRemaining / 1000);
                destructionStreak.textContent = gameState.destructionStreak;
            }
        }
        
        // ==================== FEATURE 8: ROCKET BOOST PADS & FLIGHT MODE ====================
        
        function activateFlightMode() {
            // Check if flight mode feature is enabled
            if (!FeatureFlags.isEnabled('FLIGHT_MODE')) {
                return;
            }
            
            // Track feature usage
            DevOpsMonitor.trackFeatureUsage('FLIGHT_MODE', 'activated');
            
            gameState.flightMode = true;
            gameState.flightTimeRemaining = 3000; // 3 seconds
            gameState.flightAltitude = 0;
            gameState.targetAltitude = 3; // Default altitude
            
            // Visual effects
            document.getElementById('flightOverlay').classList.add('active');
            document.getElementById('flightDisplay').style.display = 'block';
            document.getElementById('altitudeMeter').classList.add('active');
            
            // Player jet effects
            createJetStream();
            
            // Sound effects
            audioManager.createTone(300, 0.5, 'sine'); // Rocket boost sound
            audioManager.createNoise(0.5, 2000); // Jet engine
            
            // Spawn aerial collectibles
            spawnAerialCollectibles();
            
            console.log('🚀 FLIGHT MODE ACTIVATED!');
            showScorePopup(200, player.position, 'FLIGHT MODE!');
        }
        
        function deactivateFlightMode() {
            gameState.flightMode = false;
            gameState.flightTimeRemaining = 0;
            
            // Smooth landing
            gameState.targetAltitude = 0;
            
            // Remove visual effects
            document.getElementById('flightOverlay').classList.remove('active');
            document.getElementById('flightDisplay').style.display = 'none';
            document.getElementById('altitudeMeter').classList.remove('active');
            
            // Remove jet effects
            if (player.userData.jetStream) {
                scene.remove(player.userData.jetStream);
                delete player.userData.jetStream;
            }
            
            // Landing effects
            createLandingEffect();
            
            console.log('Flight mode deactivated');
        }
        
        function createJetStream() {
            const jetGroup = new THREE.Group();
            
            // Left jet
            const leftJet = createSingleJetStream();
            leftJet.position.set(-0.3, -0.5, 0.5);
            jetGroup.add(leftJet);
            
            // Right jet
            const rightJet = createSingleJetStream();
            rightJet.position.set(0.3, -0.5, 0.5);
            jetGroup.add(rightJet);
            
            player.add(jetGroup);
            player.userData.jetStream = jetGroup;
        }
        
        function createSingleJetStream() {
            const jetGroup = new THREE.Group();
            
            // Jet flame
            const flameGeometry = new THREE.ConeGeometry(0.2, 1.0, 8);
            const flameMaterial = new THREE.MeshLambertMaterial({
                color: 0x00CCFF,
                emissive: 0x0088FF,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.7
            });
            
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.rotation.x = Math.PI;
            jetGroup.add(flame);
            
            // Jet particles
            const particleCount = 10;
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05 + Math.random() * 0.05),
                    new THREE.MeshLambertMaterial({
                        color: 0x00FFFF,
                        emissive: 0x00CCFF,
                        emissiveIntensity: 0.9,
                        transparent: true,
                        opacity: 0.8 - i * 0.08
                    })
                );
                
                particle.position.y = -0.5 - i * 0.2;
                particle.scale.setScalar(1 - i * 0.08);
                jetGroup.add(particle);
            }
            
            return jetGroup;
        }
        
        function createLandingEffect() {
            const landingPos = player.position.clone();
            landingPos.y = 0;
            
            // Landing dust burst
            for (let i = 0; i < 30; i++) {
                const angle = (i / 30) * Math.PI * 2;
                const distance = 1 + Math.random() * 2;
                
                const dustPos = landingPos.clone();
                dustPos.x += Math.cos(angle) * distance;
                dustPos.z += Math.sin(angle) * distance;
                
                createParticleEffect(dustPos, 0x8B7355, 'dust');
            }
            
            // Landing ring
            createExplosionRing(landingPos, 0x00CCFF);
            
            // Sound
            audioManager.play('land');
            screenShake(0.2, 300);
        }
        
        function spawnAerialCollectibles() {
            // Spawn 3-5 aerial collectibles ahead
            const collectibleCount = 3 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < collectibleCount; i++) {
                const lane = Math.floor(Math.random() * 3);
                const z = -40 - i * 8;
                const altitude = 3 + Math.random() * 2; // 3-5 units high
                const type = Math.random() < 0.7 ? 'kiwi' : 'broccoli';
                
                createAerialCollectible(type, lane, z, altitude);
            }
        }
        
        function updateFlightUI() {
            if (gameState.flightMode) {
                const flightTime = document.getElementById('flightTime');
                const flightAltitude = document.getElementById('flightAltitude');
                const altitudeIndicator = document.getElementById('altitudeIndicator');
                
                flightTime.textContent = Math.ceil(gameState.flightTimeRemaining / 1000);
                flightAltitude.textContent = gameState.flightAltitude.toFixed(1);
                
                // Update altitude meter
                const altitudePercent = (gameState.flightAltitude / 5) * 100;
                altitudeIndicator.style.height = `${altitudePercent}%`;
            }
        }
        
        // ==================== FEATURE 9: DAILY CHALLENGE & ACHIEVEMENT SYSTEM ====================
        
        const DAILY_CHALLENGES = [
            {
                id: 'no_jump',
                name: 'No Jump Day',
                description: 'Complete run without jumping',
                target: 1,
                reward: 500,
                trackStat: 'jumpsCount',
                checkCondition: (stats) => stats.jumpsCount === 0 && gameState.timeRemaining === 0
            },
            {
                id: 'kiwi_master',
                name: 'Kiwi Master',
                description: 'Collect 20 kiwis',
                target: 20,
                reward: 300,
                trackStat: 'collectedKiwis',
                checkCondition: (stats) => gameState.collectedKiwis >= 20
            },
            {
                id: 'speed_demon',
                name: 'Speed Demon',
                description: 'Reach speed 250+',
                target: 250,
                reward: 400,
                trackStat: 'maxSpeedReached',
                checkCondition: (stats) => stats.maxSpeedReached >= 250
            },
            {
                id: 'perfect_runner',
                name: 'Perfect Runner',
                description: 'Get 15 perfect moves',
                target: 15,
                reward: 600,
                trackStat: 'perfectMoves',
                checkCondition: (stats) => stats.perfectMoves >= 15
            },
            {
                id: 'destroyer',
                name: 'Destroyer',
                description: 'Break 10 obstacles',
                target: 10,
                reward: 350,
                trackStat: 'obstaclesDestroyed',
                checkCondition: (stats) => stats.obstaclesDestroyed >= 10
            }
        ];
        
        const ACHIEVEMENTS = {
            first_kiwi: { name: 'First Taste', description: 'Collect your first kiwi', icon: '🥝', reward: 50 },
            kiwi_collector: { name: 'Kiwi Collector', description: 'Collect 100 kiwis total', icon: '🥝', reward: 200 },
            kiwi_master: { name: 'Kiwi Master', description: 'Collect 500 kiwis total', icon: '👑', reward: 500 },
            broccoli_fan: { name: 'Healthy Choice', description: 'Collect 50 broccolis total', icon: '🥦', reward: 150 },
            speed_freak: { name: 'Speed Freak', description: 'Reach maximum speed', icon: '⚡', reward: 300 },
            survivor: { name: 'Survivor', description: 'Survive full 60 seconds', icon: '🏆', reward: 400 },
            perfect_run: { name: 'Perfect Run', description: 'Complete run without losing lives', icon: '💎', reward: 600 },
            combo_king: { name: 'Combo King', description: 'Achieve 20x combo', icon: '🔥', reward: 350 },
            millionaire: { name: 'Millionaire', description: 'Score over 1,000,000 points', icon: '💰', reward: 1000 },
            destruction_expert: { name: 'Destruction Expert', description: 'Destroy 100 obstacles total', icon: '💥', reward: 400 },
            flight_master: { name: 'Flight Master', description: 'Fly for 30 seconds total', icon: '🚀', reward: 300 },
            gambler: { name: 'Lucky Gambler', description: 'Win 10 roulette spins', icon: '🎰', reward: 500 },
            surge_master: { name: 'Surge Master', description: 'Activate Score Surge 5 times', icon: '💎', reward: 450 },
            challenge_champion: { name: 'Challenge Champion', description: 'Complete 10 daily challenges', icon: '📅', reward: 800 },
            collection_perfectionist: { name: 'Perfectionist', description: 'Collect all items in one run', icon: '✨', reward: 700 },
            adrenaline_junkie: { name: 'Adrenaline Junkie', description: 'Activate Adrenaline Mode 10 times', icon: '💉', reward: 550 },
            rampage_lord: { name: 'Rampage Lord', description: 'Enter Rampage Mode 5 times', icon: '👹', reward: 600 },
            fusion_expert: { name: 'Fusion Expert', description: 'Create 20 power-up fusions', icon: '⚡', reward: 400 },
            near_miss_pro: { name: 'Close Call Pro', description: '100 near misses total', icon: '😅', reward: 350 },
            veteran: { name: 'Veteran Runner', description: 'Play 100 games', icon: '🎖️', reward: 1000 }
        };
        
        function initializeDailyChallenge() {
            const today = new Date().toDateString();
            const savedDate = localStorage.getItem('subwayRunner_lastChallengeDate');
            const savedChallenge = localStorage.getItem('subwayRunner_currentChallenge');
            
            // Check if we need a new challenge
            if (savedDate !== today || !savedChallenge) {
                // Select new challenge based on date hash
                const dateHash = today.split('').reduce((a, b) => a + b.charCodeAt(0), 0);
                const challengeIndex = dateHash % DAILY_CHALLENGES.length;
                gameState.dailyChallenge = DAILY_CHALLENGES[challengeIndex];
                gameState.dailyChallengeProgress = 0;
                gameState.dailyChallengeCompleted = false;
                
                // Save to localStorage
                localStorage.setItem('subwayRunner_lastChallengeDate', today);
                localStorage.setItem('subwayRunner_currentChallenge', JSON.stringify(gameState.dailyChallenge));
                localStorage.setItem('subwayRunner_challengeProgress', '0');
                localStorage.setItem('subwayRunner_challengeCompleted', 'false');
            } else {
                // Load existing challenge
                gameState.dailyChallenge = JSON.parse(savedChallenge);
                gameState.dailyChallengeProgress = parseInt(localStorage.getItem('subwayRunner_challengeProgress') || '0');
                gameState.dailyChallengeCompleted = localStorage.getItem('subwayRunner_challengeCompleted') === 'true';
            }
            
            // Load achievements
            const savedAchievements = localStorage.getItem('subwayRunner_achievements');
            if (savedAchievements) {
                gameState.achievements = JSON.parse(savedAchievements);
            } else {
                gameState.achievements = {};
            }
            
            updateDailyChallengeUI();
        }
        
        function updateDailyChallengeUI() {
            const display = document.getElementById('dailyChallengeDisplay');
            const challengeName = document.getElementById('challengeName');
            const challengeProgress = document.getElementById('challengeProgress');
            const challengeTarget = document.getElementById('challengeTarget');
            const completeStatus = document.getElementById('challengeCompleteStatus');
            const challengeReward = document.getElementById('challengeReward');
            
            if (gameState.dailyChallenge && display) {
                display.style.display = 'block';
                challengeName.textContent = gameState.dailyChallenge.name;
                challengeTarget.textContent = gameState.dailyChallenge.target;
                
                // Update progress based on challenge type
                let progress = 0;
                if (gameState.dailyChallenge.trackStat === 'collectedKiwis') {
                    progress = gameState.collectedKiwis;
                } else if (gameState.dailyChallenge.trackStat === 'maxSpeedReached') {
                    progress = Math.floor(gameState.speed * 1000);
                    gameState.challengeStats.maxSpeedReached = Math.max(gameState.challengeStats.maxSpeedReached, progress);
                } else {
                    progress = gameState.challengeStats[gameState.dailyChallenge.trackStat] || 0;
                }
                
                challengeProgress.textContent = Math.min(progress, gameState.dailyChallenge.target);
                
                if (gameState.dailyChallengeCompleted) {
                    completeStatus.style.display = 'block';
                    challengeReward.textContent = gameState.dailyChallenge.reward;
                } else {
                    completeStatus.style.display = 'none';
                }
            }
        }
        
        function checkDailyChallengeProgress() {
            if (!gameState.dailyChallenge || gameState.dailyChallengeCompleted) return;
            
            // Check if challenge is completed
            if (gameState.dailyChallenge.checkCondition(gameState.challengeStats)) {
                completeDailyChallenge();
            }
            
            updateDailyChallengeUI();
        }
        
        function completeDailyChallenge() {
            if (gameState.dailyChallengeCompleted) return;
            
            gameState.dailyChallengeCompleted = true;
            localStorage.setItem('subwayRunner_challengeCompleted', 'true');
            
            // Award reward
            addScore(gameState.dailyChallenge.reward, 'daily_challenge');
            
            // Show completion popup
            showAchievementPopup(
                '📅',
                'Daily Challenge Complete!',
                gameState.dailyChallenge.name,
                gameState.dailyChallenge.reward
            );
            
            // Update UI
            updateDailyChallengeUI();
            
            // Track for achievement
            const completedChallenges = parseInt(localStorage.getItem('subwayRunner_completedChallenges') || '0') + 1;
            localStorage.setItem('subwayRunner_completedChallenges', completedChallenges.toString());
            
            if (completedChallenges >= 10) {
                unlockAchievement('challenge_champion');
            }
        }
        
        function checkAchievements() {
            // Check various achievement conditions
            if (gameState.totalKiwis >= 1 && !gameState.achievements.first_kiwi) {
                unlockAchievement('first_kiwi');
            }
            if (gameState.totalKiwis >= 100 && !gameState.achievements.kiwi_collector) {
                unlockAchievement('kiwi_collector');
            }
            if (gameState.totalKiwis >= 500 && !gameState.achievements.kiwi_master) {
                unlockAchievement('kiwi_master');
            }
            if (gameState.totalBroccolis >= 50 && !gameState.achievements.broccoli_fan) {
                unlockAchievement('broccoli_fan');
            }
            if (gameState.speed >= gameState.maxSpeed * 0.95 && !gameState.achievements.speed_freak) {
                unlockAchievement('speed_freak');
            }
            if (gameState.timeRemaining === 0 && gameState.lives > 0 && !gameState.achievements.survivor) {
                unlockAchievement('survivor');
            }
            if (gameState.timeRemaining === 0 && gameState.lives === 3 && !gameState.achievements.perfect_run) {
                unlockAchievement('perfect_run');
            }
            if (gameState.score >= 1000000 && !gameState.achievements.millionaire) {
                unlockAchievement('millionaire');
            }
            // Add more achievement checks as needed
        }
        
        function unlockAchievement(achievementId) {
            if (gameState.achievements[achievementId]) return;
            
            const achievement = ACHIEVEMENTS[achievementId];
            if (!achievement) return;
            
            gameState.achievements[achievementId] = true;
            
            // Save to localStorage
            localStorage.setItem('subwayRunner_achievements', JSON.stringify(gameState.achievements));
            
            // Award points
            addScore(achievement.reward, `achievement_${achievementId}`);
            
            // Show popup
            showAchievementPopup(
                achievement.icon,
                'Achievement Unlocked!',
                achievement.name,
                achievement.reward
            );
            
            console.log(`🏆 Achievement Unlocked: ${achievement.name}`);
        }
        
        function showAchievementPopup(icon, title, description, reward) {
            const popup = document.getElementById('achievementPopup');
            const iconEl = document.getElementById('achievementIcon');
            const titleEl = document.getElementById('achievementTitle');
            const descEl = document.getElementById('achievementDescription');
            const rewardEl = document.getElementById('achievementReward');
            
            iconEl.textContent = icon;
            titleEl.textContent = title;
            descEl.textContent = description;
            rewardEl.textContent = reward;
            
            popup.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                popup.style.display = 'none';
            }, 3000);
            
            // Sound effect
            audioManager.play('success');
        }
        
        // ==================== FEATURE 10: MULTIPLIER ROULETTE & SCORE SURGE ====================
        
        const ROULETTE_MULTIPLIERS = [
            { value: 0.5, angle: 0, color: '#FF0000' },
            { value: 1, angle: 60, color: '#FFA500' },
            { value: 2, angle: 120, color: '#0000FF' },
            { value: 3, angle: 180, color: '#00FF00' },
            { value: 5, angle: 240, color: '#FF00FF' },
            { value: 10, angle: 300, color: '#FFD700' }
        ];
        
        function spawnScoreToken(lane, z) {
            const tokenGroup = new THREE.Group();
            
            // Golden spinning coin
            const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 16);
            const coinMaterial = new THREE.MeshLambertMaterial({
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.3
            });
            
            const coin = new THREE.Mesh(coinGeometry, coinMaterial);
            coin.rotation.x = Math.PI / 2;
            tokenGroup.add(coin);
            
            // Add inner design
            const innerGeometry = new THREE.RingGeometry(0.2, 0.3, 8);
            const innerMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFA500,
                side: THREE.DoubleSide
            });
            const inner = new THREE.Mesh(innerGeometry, innerMaterial);
            inner.position.z = 0.06;
            tokenGroup.add(inner);
            
            // Glow effect
            const glowGeometry = new THREE.SphereGeometry(0.7, 12, 12);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            tokenGroup.add(glow);
            
            // Position
            tokenGroup.position.set(LANE_POSITIONS[lane], 1.5, z);
            
            scene.add(tokenGroup);
            
            const tokenData = {
                mesh: tokenGroup,
                type: 'scoreToken',
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0,
                baseY: 1.5
            };
            
            gameState.scoreTokens.push(tokenData);
            
            return tokenData;
        }
        
        function collectScoreToken(tokenData) {
            if (tokenData.collected) return;
            
            tokenData.collected = true;
            scene.remove(tokenData.mesh);
            
            gameState.collectedTokens++;
            
            // Update UI
            updateScoreTokenUI();
            
            // Create collection effect
            createParticleEffect(tokenData.mesh.position, 0xFFD700, 'token');
            
            // Sound effect
            audioManager.createTone(1000, 0.2, 'sine');
            audioManager.createTone(1200, 0.15, 'sine');
            
            // Check if we have 3 tokens
            if (gameState.collectedTokens >= 3) {
                activateRoulette();
            }
            
            console.log(`🪙 Collected score token! (${gameState.collectedTokens}/3)`);
        }
        
        function updateScoreTokenUI() {
            const display = document.getElementById('scoreTokenDisplay');
            const count = document.getElementById('tokenCount');
            const ready = document.getElementById('rouletteReady');
            
            if (gameState.collectedTokens > 0) {
                display.style.display = 'block';
                count.textContent = gameState.collectedTokens;
                
                if (gameState.collectedTokens >= 3) {
                    ready.style.display = 'block';
                }
            }
        }
        
        function activateRoulette() {
            // Pause the game
            gameState.rouletteActive = true;
            gameState.savedGameSpeed = gameState.speed;
            gameState.speed = 0;
            
            // Show roulette modal
            document.getElementById('rouletteModal').style.display = 'block';
            document.getElementById('spinButton').disabled = false;
            document.getElementById('rouletteResult').textContent = '';
            
            // Reset tokens
            gameState.collectedTokens = 0;
            updateScoreTokenUI();
        }
        
        function spinRoulette() {
            const wheel = document.getElementById('rouletteWheel');
            const button = document.getElementById('spinButton');
            const result = document.getElementById('rouletteResult');
            const center = document.querySelector('.roulette-center');
            
            button.disabled = true;
            result.textContent = '';
            
            // Random spin amount (3-5 full rotations plus final position)
            const spins = 3 + Math.random() * 2;
            const finalAngle = Math.random() * 360;
            const totalRotation = spins * 360 + finalAngle;
            
            // Apply rotation
            wheel.style.transform = `rotate(${totalRotation}deg)`;
            
            // Determine result after spin completes
            setTimeout(() => {
                // Calculate which segment we landed on
                const normalizedAngle = (360 - (finalAngle % 360)) % 360;
                let selectedMultiplier = ROULETTE_MULTIPLIERS[0];
                
                for (let i = 0; i < ROULETTE_MULTIPLIERS.length; i++) {
                    const start = ROULETTE_MULTIPLIERS[i].angle;
                    const end = ROULETTE_MULTIPLIERS[(i + 1) % ROULETTE_MULTIPLIERS.length].angle;
                    
                    if (normalizedAngle >= start && normalizedAngle < end) {
                        selectedMultiplier = ROULETTE_MULTIPLIERS[i];
                        break;
                    }
                }
                
                // Apply multiplier
                gameState.currentMultiplier = selectedMultiplier.value;
                center.textContent = `${selectedMultiplier.value}x`;
                
                // Show result
                if (selectedMultiplier.value < 1) {
                    result.textContent = `😢 Bad Luck! ${selectedMultiplier.value}x multiplier!`;
                    result.style.color = '#FF4444';
                } else if (selectedMultiplier.value >= 5) {
                    result.textContent = `🎉 JACKPOT! ${selectedMultiplier.value}x multiplier!`;
                    result.style.color = '#00FF00';
                    activateScoreSurge();
                } else {
                    result.textContent = `✨ Nice! ${selectedMultiplier.value}x multiplier!`;
                    result.style.color = '#FFD700';
                }
                
                // Track for achievements
                gameState.rouletteHistory.push(selectedMultiplier.value);
                const wins = gameState.rouletteHistory.filter(x => x > 1).length;
                if (wins >= 10) {
                    unlockAchievement('gambler');
                }
                
                // Close modal after delay
                setTimeout(() => {
                    closeRoulette();
                }, 2000);
                
            }, 4000);
        }
        
        function closeRoulette() {
            document.getElementById('rouletteModal').style.display = 'none';
            gameState.rouletteActive = false;
            gameState.speed = gameState.savedGameSpeed;
        }
        
        function activateScoreSurge() {
            gameState.scoreSurgeActive = true;
            gameState.scoreSurgeTimeRemaining = 15000; // 15 seconds
            gameState.scoreSurgeMultiplier = 2.0; // Double all points
            
            // Update UI
            const display = document.getElementById('surgeModeDisplay');
            display.style.display = 'block';
            document.getElementById('surgeMultiplier').textContent = 
                (gameState.currentMultiplier * gameState.scoreSurgeMultiplier).toFixed(1);
            
            // Visual effects
            createSurgeEffect();
            
            // Sound effect
            audioManager.createTone(400, 0.5, 'sine');
            audioManager.createTone(800, 0.5, 'sine');
            audioManager.createTone(1200, 0.5, 'sine');
            
            // Track for achievements
            const surgeCount = parseInt(localStorage.getItem('subwayRunner_surgeCount') || '0') + 1;
            localStorage.setItem('subwayRunner_surgeCount', surgeCount.toString());
            if (surgeCount >= 5) {
                unlockAchievement('surge_master');
            }
        }
        
        function updateScoreSurge(deltaTime) {
            if (gameState.scoreSurgeActive) {
                gameState.scoreSurgeTimeRemaining -= deltaTime;
                
                const surgeTime = document.getElementById('surgeTime');
                if (surgeTime) {
                    surgeTime.textContent = Math.ceil(gameState.scoreSurgeTimeRemaining / 1000);
                }
                
                if (gameState.scoreSurgeTimeRemaining <= 0) {
                    deactivateScoreSurge();
                }
            }
        }
        
        function deactivateScoreSurge() {
            gameState.scoreSurgeActive = false;
            gameState.scoreSurgeTimeRemaining = 0;
            gameState.scoreSurgeMultiplier = 1.0;
            
            document.getElementById('surgeModeDisplay').style.display = 'none';
        }
        
        function createSurgeEffect() {
            // Create rainbow particles around player
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const angle = (i / 20) * Math.PI * 2;
                    const distance = 2;
                    const pos = player.position.clone();
                    pos.x += Math.cos(angle) * distance;
                    pos.z += Math.sin(angle) * distance;
                    pos.y += 1;
                    
                    const colors = [0xFF0000, 0xFFA500, 0xFFFF00, 0x00FF00, 0x0000FF, 0xFF00FF];
                    createParticleEffect(pos, colors[i % colors.length], 'surge');
                }, i * 50);
            }
        }
        
        // Override the addScore function to apply multipliers
        const originalAddScore = addScore;
        addScore = function(amount, source = 'unknown') {
            // Apply current multiplier
            let finalAmount = amount * gameState.currentMultiplier;
            
            // Apply score surge multiplier if active
            if (gameState.scoreSurgeActive) {
                finalAmount *= gameState.scoreSurgeMultiplier;
            }
            
            // Call original function with multiplied amount
            originalAddScore(Math.floor(finalAmount), source);
        };
        
        // Make roulette function global
        window.spinRoulette = spinRoulette;
        
        function collectKiwi(kiwiData) {
            if (kiwiData.collected) return;
            
            kiwiData.collected = true;
            scene.remove(kiwiData.mesh);
            
            // Update kiwi count with debug logging
            gameState.collectedKiwis++;
            gameState.totalKiwis++;
            
            console.log(`🥝 COLLECTED KIWI - Session: ${gameState.collectedKiwis}, Total Lifetime: ${gameState.totalKiwis}`);
            
            // Handle combo system
            const currentTime = performance.now();
            if (currentTime - gameState.lastKiwiTime < 2000) { // 2 second combo window
                gameState.kiwiCombo++;
            } else {
                gameState.kiwiCombo = 1;
            }
            gameState.lastKiwiTime = currentTime;
            
            // Calculate score with combo multiplier
            const baseScore = 10;
            const comboBonus = gameState.kiwiCombo > 1 ? (gameState.kiwiCombo - 1) * 5 : 0;
            const totalScore = baseScore + comboBonus;
            
            addScore(totalScore, 'kiwi_collection');
            
            // Show combo UI
            updateComboUI();
            
            // Audio feedback with pitch variation (squish sound)
            const pitchVariation = 1 + (gameState.kiwiCombo * 0.1);
            audioManager.createTone(600 * pitchVariation, 0.15, 'sine');
            
            // Kiwi-Saft-Splash-Effekt (Feature 1: Combo Explosions)
            if (FeatureFlags.isEnabled('COMBO_EXPLOSIONS')) {
                createKiwiSplashEffect(kiwiData.mesh.position.clone());
                
                // Extra explosion effect for combos
                if (gameState.kiwiCombo >= 3) {
                    DevOpsMonitor.trackFeatureUsage('COMBO_EXPLOSIONS', 'combo_' + gameState.kiwiCombo);
                }
            }
            
            // Update UI
            updateKiwiUI();
            
            console.log(`Collected kiwi! Combo: ${gameState.kiwiCombo}, Score: +${totalScore}`);
        }
        
        // NEW: Brokkoli collection function
        function collectBroccoli(broccoliData) {
            if (broccoliData.collected) return;
            
            broccoliData.collected = true;
            scene.remove(broccoliData.mesh);
            
            // Update broccoli count with debug logging
            gameState.collectedBroccolis++;
            gameState.totalBroccolis++;
            
            console.log(`🥦 COLLECTED BROCCOLI - Session: ${gameState.collectedBroccolis}, Total Lifetime: ${gameState.totalBroccolis}`);
            
            // Broccolis give slightly more points than kiwis (health food bonus!)
            const baseScore = 15;
            const totalScore = baseScore;
            
            addScore(totalScore, 'broccoli_collection');
            
            // Green healthy effects (Feature 1: Combo Explosions)
            if (FeatureFlags.isEnabled('COMBO_EXPLOSIONS')) {
                createBroccoliHealthEffect(broccoliData.mesh.position.clone());
                DevOpsMonitor.trackFeatureUsage('COMBO_EXPLOSIONS', 'broccoli_effect');
            }
            
            // Audio feedback with lower pitch (different from kiwi)
            audioManager.createTone(400, 0.2, 'sine');
            
            // Update UI
            updateCollectibleUI();
            
            console.log(`Collected broccoli! Health bonus: +${totalScore} points`);
        }
        
        // Kiwi-Saft-Splash-Effekt
        function createKiwiSplashEffect(position) {
            const splashParticles = [];
            const particleCount = 20;
            
            for (let i = 0; i < particleCount; i++) {
                // Safttropfen-Geometrie
                const dropSize = 0.05 + Math.random() * 0.1;
                const dropGeometry = new THREE.SphereGeometry(dropSize, 4, 4);
                
                // Grüne Farbe mit Variation
                const greenVariation = Math.random() * 0.3;
                const dropMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.5 + greenVariation, 0.8 + greenVariation * 0.5, 0.3),
                    transparent: true,
                    opacity: 0.8
                });
                
                const drop = new THREE.Mesh(dropGeometry, dropMaterial);
                drop.position.copy(position);
                
                // Zufällige Geschwindigkeit in alle Richtungen
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.4 + 0.2,
                    (Math.random() - 0.5) * 0.3
                );
                
                scene.add(drop);
                splashParticles.push({ mesh: drop, velocity: velocity, life: 1.0 });
            }
            
            // Animate splash particles
            const animateSplash = () => {
                splashParticles.forEach((particle, index) => {
                    if (particle.life > 0) {
                        // Update position
                        particle.mesh.position.add(particle.velocity);
                        
                        // Apply gravity
                        particle.velocity.y -= 0.02;
                        
                        // Fade out
                        particle.life -= 0.05;
                        particle.mesh.material.opacity = particle.life * 0.8;
                        
                        // Scale down
                        const scale = particle.life;
                        particle.mesh.scale.set(scale, scale, scale);
                        
                        if (particle.life <= 0) {
                            scene.remove(particle.mesh);
                            splashParticles.splice(index, 1);
                        }
                    }
                });
                
                if (splashParticles.length > 0) {
                    requestAnimationFrame(animateSplash);
                }
            };
            
            animateSplash();
        }
        
        function updateComboUI() {
            const comboDisplay = document.getElementById('comboDisplay');
            const comboMultiplier = document.getElementById('comboMultiplier');
            
            if (gameState.kiwiCombo > 1) {
                comboDisplay.style.display = 'block';
                comboMultiplier.textContent = gameState.kiwiCombo;
                
                // Hide after 2 seconds
                setTimeout(() => {
                    comboDisplay.style.display = 'none';
                }, 2000);
            } else {
                comboDisplay.style.display = 'none';
            }
        }
        
        function updateKiwiUI() {
            const kiwiCount = document.getElementById('kiwiCount');
            const broccoliCount = document.getElementById('broccoliCount');
            const kiwiProgress = document.getElementById('kiwiProgress');
            const broccoliProgress = document.getElementById('broccoliProgress');
            
            // Debug logging
            console.log(`🔍 updateKiwiUI called - Kiwis: ${gameState.collectedKiwis}, Broccolis: ${gameState.collectedBroccolis}`);
            
            if (kiwiCount) {
                kiwiCount.textContent = gameState.collectedKiwis || 0;
            } else {
                console.error('❌ kiwiCount element not found!');
            }
            
            if (broccoliCount) {
                broccoliCount.textContent = gameState.collectedBroccolis || 0;
            } else {
                console.error('❌ broccoliCount element not found!');
            }
            
            // Update progress bars for 30:7 goals
            if (kiwiProgress) {
                const kiwiPercent = Math.min((gameState.collectedKiwis / 30) * 100, 100);
                kiwiProgress.style.width = kiwiPercent + '%';
            }
            
            if (broccoliProgress) {
                const broccoliPercent = Math.min((gameState.collectedBroccolis / 7) * 100, 100);
                broccoliProgress.style.width = broccoliPercent + '%';
            }
            
            // Also update the total for percentage calculation
            const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
            console.log(`📊 Total collected: ${collectedTotal}/${gameState.totalCollectibles} (${gameState.totalCollectibles > 0 ? (collectedTotal/gameState.totalCollectibles*100).toFixed(0) : 0}%)`);
        }
        
        function updateEnvironmentUI() {
            const environmentDisplay = document.getElementById('currentEnvironment');
            if (environmentDisplay) {
                switch (gameState.currentEnvironment) {
                    case 'street':
                        environmentDisplay.innerHTML = '🏙️ Straße';
                        break;
                    case 'tunnel_entrance':
                        environmentDisplay.innerHTML = '🚇 Tunnel Eingang';
                        break;
                    case 'tunnel':
                        environmentDisplay.innerHTML = '🚇 Tunnel';
                        break;
                    case 'tunnel_exit':
                        environmentDisplay.innerHTML = '🌅 Tunnel Ausgang';
                        break;
                    default:
                        environmentDisplay.innerHTML = '🏙️ Straße';
                }
            }
        }
        
        function updateDifficultyUI() {
            const difficultyLevel = document.getElementById('difficultyLevel');
            if (difficultyLevel) {
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime);
                
                if (gameProgress < 0.2) {
                    difficultyLevel.textContent = 'Leicht';
                    difficultyLevel.style.color = '#90EE90';
                } else if (gameProgress < 0.4) {
                    difficultyLevel.textContent = 'Mittel';
                    difficultyLevel.style.color = '#FFD700';
                } else if (gameProgress < 0.6) {
                    difficultyLevel.textContent = 'Schwer';
                    difficultyLevel.style.color = '#FFA500';
                } else if (gameProgress < 0.8) {
                    difficultyLevel.textContent = 'Extrem';
                    difficultyLevel.style.color = '#FF4500';
                } else {
                    difficultyLevel.textContent = 'Wahnsinn!';
                    difficultyLevel.style.color = '#FF0000';
                }
            }
        }
        
        // ==================== SKILL COMBO SYSTEM ====================
        
        function showSkillCombo(bonusPoints, comboMessage) {
            const skillComboDisplay = document.getElementById('skillComboDisplay');
            const skillComboCount = document.getElementById('skillComboCount');
            const skillComboBonus = document.getElementById('skillComboBonus');
            const skillComboIcon = document.getElementById('skillComboIcon');
            
            if (skillComboDisplay) {
                skillComboDisplay.style.display = 'block';
                skillComboCount.textContent = gameState.consecutiveAvoidances;
                skillComboBonus.textContent = `+${bonusPoints}`;
                
                // Dynamic icon based on combo type
                if (comboMessage.includes('ZIGZAG')) {
                    skillComboIcon.textContent = '⚡';
                } else if (comboMessage.includes('LIGHTNING')) {
                    skillComboIcon.textContent = '⚡';
                } else if (comboMessage.includes('PERFECT')) {
                    skillComboIcon.textContent = '💎';
                } else if (comboMessage.includes('RAPID')) {
                    skillComboIcon.textContent = '🔥';
                } else {
                    skillComboIcon.textContent = '⭐';
                }
                
                // Update combo message in UI
                const comboTextElement = skillComboDisplay.querySelector('div');
                if (comboTextElement) {
                    comboTextElement.innerHTML = `<span style="color: #FFD700;">+${bonusPoints} ${comboMessage}</span>`;
                }
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    skillComboDisplay.style.display = 'none';
                }, 3000);
                
                // Enhanced audio for combos
                if (bonusPoints > 200) {
                    audioManager.createTone(880, 0.3, 'sine'); // High achievement sound
                    audioManager.createTone(660, 0.4, 'sine'); // Chord
                } else if (bonusPoints > 100) {
                    audioManager.createTone(660, 0.2, 'sine'); // Medium achievement
                } else {
                    audioManager.createTone(440, 0.15, 'sine'); // Basic skill sound
                }
                
                console.log(`SKILL COMBO: ${comboMessage} - +${bonusPoints} points`);
            }
        }
        
        function trackPlayerMove(moveType, lane = null) {
            const currentTime = performance.now();
            const actualLane = lane !== null ? lane : gameState.playerLane;
            
            // BUGFIX: Only track lane changes for rapid move bonuses, not jumping/ducking
            if (gameState.lastAction !== moveType && (moveType === 'left' || moveType === 'right')) {
                const timeSinceLastMove = currentTime - gameState.lastSkillTime;
                
                // Award rapid movement bonus only for actual lane changes (skill moves)
                if (timeSinceLastMove < 1000 && gameState.rapidMoveBonus < 5) { // Max 5 rapid moves
                    gameState.rapidMoveBonus++;
                    const rapidBonus = gameState.rapidMoveBonus * 10;
                    addScore(rapidBonus, 'rapid_lane_change');
                    
                    // Show rapid move feedback
                    if (gameState.rapidMoveBonus >= 3) {
                        showSkillCombo(rapidBonus, `RAPID LANE CHANGES x${gameState.rapidMoveBonus}!`);
                    }
                } else if (timeSinceLastMove > 2000) {
                    gameState.rapidMoveBonus = 0; // Reset if too slow
                }
                
                gameState.lastAction = moveType;
                gameState.lastSkillTime = currentTime;
            }
            
            // Track jumping and ducking without giving points (just for sequence tracking)
            if (moveType === 'jumping' || moveType === 'ducking') {
                gameState.lastAction = moveType;
            }
            
            // Record move for trick detection
            const move = {
                type: moveType,
                lane: actualLane,
                time: currentTime
            };
            
            gameState.trickMoveHistory.push(move);
            
            // Keep only last 10 moves
            if (gameState.trickMoveHistory.length > 10) {
                gameState.trickMoveHistory.shift();
            }
            
            // Check for trick combos
            checkForTricks();
        }
        
        // ==================== END SKILL COMBO SYSTEM ====================
        
        // ==================== SIMPLIFIED BRIDGE/UNDERPASS SYSTEM ====================
        
        function createBridgeSegment(z) {
            const bridgeGroup = new THREE.Group();
            
            // Bridge deck (road above)
            const bridgeGeometry = new THREE.BoxGeometry(12, 0.5, 10);
            const bridgeMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            bridge.position.set(0, 6.5, z);
            bridgeGroup.add(bridge);
            
            // Support pillars
            const pillarGeometry = new THREE.BoxGeometry(0.8, 6, 0.8);
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            for (let x of [-4, 4]) {
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(x, 3, z);
                bridgeGroup.add(pillar);
            }
            
            // Bridge railings
            const railingGeometry = new THREE.BoxGeometry(12, 0.3, 0.2);
            const railingMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            
            for (let side of [-4.5, 4.5]) {
                const railing = new THREE.Mesh(railingGeometry, railingMaterial);
                railing.position.set(0, 7.2, z + side);
                bridgeGroup.add(railing);
            }
            
            // Cars on bridge (decorative)
            if (Math.random() > 0.7) {
                const carGeometry = new THREE.BoxGeometry(1.5, 0.5, 3);
                const carMaterial = new THREE.MeshLambertMaterial({ 
                    color: Math.random() > 0.5 ? 0xFF0000 : 0x0000FF 
                });
                
                const car = new THREE.Mesh(carGeometry, carMaterial);
                car.position.set(
                    (Math.random() - 0.5) * 8, 
                    7, 
                    z + (Math.random() - 0.5) * 8
                );
                bridgeGroup.add(car);
            }
            
            return bridgeGroup;
        }
        
        function createSimpleKiwi(lane, z) {
            const kiwiGroup = new THREE.Group();
            
            // Simplified elongated kiwi for performance (less detailed than createKiwi)
            const kiwiRadiusX = 0.2;   // Smaller width
            const kiwiRadiusY = 0.35;  // Taller height 
            const kiwiRadiusZ = 0.2;   // Smaller depth
            
            // Half ellipsoid for kiwi body
            const kiwiGeometry = new THREE.SphereGeometry(1, 8, 4, 0, Math.PI * 2, 0, Math.PI / 2);
            kiwiGeometry.scale(kiwiRadiusX, kiwiRadiusY, kiwiRadiusZ);  // Create oval/ellipsoid
            const kiwiMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8B6914,
                transparent: true,
                opacity: 0.9
            });
            
            const kiwiBody = new THREE.Mesh(kiwiGeometry, kiwiMaterial);
            kiwiBody.rotation.x = -Math.PI / 2;
            kiwiGroup.add(kiwiBody);
            
            // Simple flesh ellipse
            const fleshGeometry = new THREE.CircleGeometry(kiwiRadiusX * 0.9, 8);
            const fleshMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.95
            });
            
            const flesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
            flesh.rotation.x = -Math.PI / 2;
            flesh.position.y = 0.01;
            kiwiGroup.add(flesh);
            
            // Simple white core
            const coreGeometry = new THREE.CircleGeometry(kiwiRadiusX * 0.3, 6);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xF5F5DC
            });
            
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.rotation.x = -Math.PI / 2;
            core.position.y = 0.02;
            kiwiGroup.add(core);
            
            // Position
            const LANE_POSITIONS = [-2, 0, 2];
            kiwiGroup.position.set(LANE_POSITIONS[lane], 1.2, z);
            
            scene.add(kiwiGroup);
            
            return {
                mesh: kiwiGroup,
                type: 'kiwi',
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0,
                baseY: 1.2
            };
        }
        
        function createSimplePowerUp(type, lane, z) {
            const powerUpGroup = new THREE.Group();
            
            // Special geometry for magnet and large magnet
            if (type === 'magnet' || type === 'largeMagnet') {
                // Create horseshoe magnet shape
                const magnetGroup = new THREE.Group();
                
                // Scale factor for large magnet
                const scale = type === 'largeMagnet' ? 2.0 : 1.0;
                
                // Red (north) pole
                const redPoleGeometry = new THREE.BoxGeometry(0.3 * scale, 0.8 * scale, 0.3 * scale);
                const redPoleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: type === 'largeMagnet' ? 0.5 : 0.3
                });
                const redPole = new THREE.Mesh(redPoleGeometry, redPoleMaterial);
                redPole.position.set(-0.25 * scale, 0, 0);
                magnetGroup.add(redPole);
                
                // Blue (south) pole
                const bluePoleGeometry = new THREE.BoxGeometry(0.3 * scale, 0.8 * scale, 0.3 * scale);
                const bluePoleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x0000FF,
                    emissive: 0x0000FF,
                    emissiveIntensity: type === 'largeMagnet' ? 0.5 : 0.3
                });
                const bluePole = new THREE.Mesh(bluePoleGeometry, bluePoleMaterial);
                bluePole.position.set(0.25 * scale, 0, 0);
                magnetGroup.add(bluePole);
                
                // Curved top connection (simplified with box)
                const topGeometry = new THREE.BoxGeometry(0.8 * scale, 0.3 * scale, 0.3 * scale);
                const topMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const topPart = new THREE.Mesh(topGeometry, topMaterial);
                topPart.position.set(0, 0.55 * scale, 0);
                magnetGroup.add(topPart);
                
                // Add magnet group to power-up
                magnetGroup.rotation.z = Math.PI / 6; // Slight tilt for visual interest
                powerUpGroup.add(magnetGroup);
                
                // Add golden glow around magnet (larger and brighter for large magnet)
                const glowSize = type === 'largeMagnet' ? 1.5 : 0.7;
                const glowOpacity = type === 'largeMagnet' ? 0.3 : 0.15;
                const glowGeometry = new THREE.SphereGeometry(glowSize, 12, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFD700,
                    transparent: true,
                    opacity: glowOpacity
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                powerUpGroup.add(glow);
                
                // Add pulsing outer ring for large magnet
                if (type === 'largeMagnet') {
                    const ringGeometry = new THREE.TorusGeometry(1.2, 0.1, 8, 16);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFFD700,
                        transparent: true,
                        opacity: 0.4
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    powerUpGroup.add(ring);
                    powerUpGroup.ring = ring; // Store reference for animation
                }
                
            } else {
                // Default crystal for other power-ups
                const crystalGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.4);
                const crystalMaterial = new THREE.MeshBasicMaterial({ 
                    color: POWER_UP_TYPES[type].color,
                    transparent: true,
                    opacity: 0.8
                });
                
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                powerUpGroup.add(crystal);
                
                // Power-up glow
                const glowGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: POWER_UP_TYPES[type].color,
                    transparent: true,
                    opacity: 0.2
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                powerUpGroup.add(glow);
            }
            
            // Position
            const LANE_POSITIONS = [-2, 0, 2];
            const baseY = type === 'largeMagnet' ? 2.2 : 1.5; // Higher position for large magnet
            powerUpGroup.position.set(LANE_POSITIONS[lane], baseY, z);
            
            scene.add(powerUpGroup);
            
            return {
                mesh: powerUpGroup,
                type: type,
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0,
                baseY: baseY
            };
        }
        
        function createTunnelSegment(z) {
            const tunnelGroup = new THREE.Group();
            
            // Tunnel walls (left and right)
            const wallGeometry = new THREE.BoxGeometry(0.3, 6, 8);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            
            // Left wall
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-4, 3, z);
            tunnelGroup.add(leftWall);
            
            // Right wall  
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(4, 3, z);
            tunnelGroup.add(rightWall);
            
            // Tunnel ceiling
            const ceilingGeometry = new THREE.BoxGeometry(8, 0.3, 8);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.set(0, 5.5, z);
            tunnelGroup.add(ceiling);
            
            // Tunnel floor stripes (more industrial look)
            const stripeGeometry = new THREE.BoxGeometry(8, 0.05, 0.2);
            const stripeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 0.05, z + (i * 2 - 2));
                tunnelGroup.add(stripe);
            }
            
            // Tunnel support beams
            const beamGeometry = new THREE.BoxGeometry(0.1, 5.5, 0.2);
            const beamMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            for (let side of [-3.8, 3.8]) {
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.set(side, 2.75, z);
                tunnelGroup.add(beam);
            }
            
            // Add tunnel lighting
            const lightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFAA,
                transparent: true,
                opacity: 0.8
            });
            
            const tunnelLight = new THREE.Mesh(lightGeometry, lightMaterial);
            tunnelLight.position.set(0, 5, z);
            tunnelGroup.add(tunnelLight);
            
            // Add light glow effect
            const glowGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFAA,
                transparent: true,
                opacity: 0.2
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(0, 5, z);
            tunnelGroup.add(glow);
            
            return tunnelGroup;
        }
        
        function createTunnelEntrance(z) {
            const entranceGroup = new THREE.Group();
            
            // Tunnel entrance arch
            const archGeometry = new THREE.CylinderGeometry(4.5, 4.5, 0.5, 16, 1, false, 0, Math.PI);
            const archMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            const arch = new THREE.Mesh(archGeometry, archMaterial);
            arch.position.set(0, 4.5, z);
            arch.rotation.z = Math.PI;
            entranceGroup.add(arch);
            
            // Entrance signs
            const signGeometry = new THREE.BoxGeometry(2, 0.5, 0.1);
            const signMaterial = new THREE.MeshLambertMaterial({ color: 0x2E86AB });
            
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 6, z);
            entranceGroup.add(sign);
            
            // Warning lights
            for (let x of [-1.5, 1.5]) {
                const warningLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFF4500 })
                );
                warningLight.position.set(x, 5.5, z);
                entranceGroup.add(warningLight);
            }
            
            return entranceGroup;
        }
        
        function checkBridgeSpawning() {
            const currentTime = performance.now();
            const gameTime = (currentTime - gameState.gameStartTime);
            
            // Progressive bridge spawning (longer intervals at start, shorter later)
            if (gameTime > gameState.nextTunnelTime) {
                const bridge = createBridgeSegment(-40);
                scene.add(bridge);
                gameState.tunnelSegments.push(bridge);
                
                // Audio effect for bridge
                audioManager.createTone(300, 0.2, 'sine');
                
                // Progressive bridge frequency
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime);
                const baseInterval = 25000; // 25 seconds at start
                const minInterval = 12000; // 12 seconds at end
                const currentInterval = baseInterval - (baseInterval - minInterval) * gameProgress;
                const randomVariation = Math.random() * 5000; // ±2.5 seconds
                
                gameState.nextTunnelTime = gameTime + currentInterval + randomVariation;
                
                console.log(`Bridge spawned! Next in ${(currentInterval + randomVariation)/1000}s`);
            }
        }
        
        function startTunnelTransition() {
            console.log('Entering tunnel...');
            gameState.currentEnvironment = 'tunnel_entrance';
            gameState.environmentTransition = true;
            gameState.tunnelStartTime = performance.now();
            
            // Update UI
            updateEnvironmentUI();
            
            // Create tunnel entrance
            const entrance = createTunnelEntrance(-25);
            scene.add(entrance);
            gameState.tunnelSegments.push(entrance);
            
            // Audio effect for tunnel entrance
            audioManager.createTone(200, 0.5, 'sine');
            
            // Dim ambient lighting
            gameState.ambientLightIntensity = 0.3;
            if (scene.children.find(child => child.type === 'AmbientLight')) {
                scene.children.find(child => child.type === 'AmbientLight').intensity = 0.3;
            }
            
            // Create initial tunnel segments
            for (let i = 0; i < 8; i++) {
                const segment = createTunnelSegment(-30 - (i * 8));
                scene.add(segment);
                gameState.tunnelSegments.push(segment);
            }
            
            // Transition to full tunnel after 2 seconds
            setTimeout(() => {
                gameState.currentEnvironment = 'tunnel';
                gameState.environmentTransition = false;
                updateEnvironmentUI();
                console.log('Now in tunnel!');
            }, 2000);
        }
        
        // NEW: Brokkoli health effect
        function createBroccoliHealthEffect(position) {
            const healthParticles = [];
            const particleCount = 15;
            
            for (let i = 0; i < particleCount; i++) {
                // Heart-shaped particles for health effect
                const heartSize = 0.08 + Math.random() * 0.05;
                const heartGeometry = new THREE.SphereGeometry(heartSize, 6, 4);
                const heartMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.2, 0.8 + Math.random() * 0.2, 0.3),
                    transparent: true,
                    opacity: 0.9
                });
                
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.position.copy(position);
                
                // Upward floating motion for health
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    3 + Math.random() * 2,  // Upward
                    (Math.random() - 0.5) * 3
                );
                
                heart.userData = { velocity: velocity, life: 1.0 };
                scene.add(heart);
                healthParticles.push(heart);
            }
            
            // Animate health particles
            function animateHealthParticles() {
                healthParticles.forEach((particle, index) => {
                    if (particle.userData.life > 0) {
                        particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.016));
                        particle.userData.velocity.y -= 0.3; // Gravity
                        particle.userData.life -= 0.02;
                        particle.material.opacity = particle.userData.life;
                        
                        if (particle.userData.life <= 0) {
                            scene.remove(particle);
                            healthParticles.splice(index, 1);
                        }
                    }
                });
                
                if (healthParticles.length > 0) {
                    requestAnimationFrame(animateHealthParticles);
                }
            }
            
            animateHealthParticles();
        }
        
        // NEW: Update collectible UI for both kiwis and broccolis
        function updateCollectibleUI() {
            const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
            const collectionPercentage = gameState.totalCollectibles > 0 ? 
                (collectedTotal / gameState.totalCollectibles * 100).toFixed(0) : 0;
            
            // Update display with enhanced debugging
            console.log(`📊 COLLECTIBLE UPDATE:`);
            console.log(`   🥝 Kiwis: ${gameState.collectedKiwis} (${gameState.kiwis.length} active)`);
            console.log(`   🥦 Broccolis: ${gameState.collectedBroccolis} (${gameState.broccolis.length} active)`);
            console.log(`   📈 Progress: ${collectedTotal}/${gameState.totalCollectibles} (${collectionPercentage}%)`);
            
            // Update the HTML display - force update
            updateKiwiUI();
            
            // Verify the update actually happened
            const kiwiElement = document.getElementById('kiwiCount');
            const broccoliElement = document.getElementById('broccoliCount');
            if (kiwiElement && broccoliElement) {
                console.log(`   ✅ UI Elements - Kiwi: ${kiwiElement.textContent}, Broccoli: ${broccoliElement.textContent}`);
            }
            
            // Check for tiered collection bonuses
            checkTieredCollectionBonuses();
        }
        
        // NEW: Tiered collection bonus system
        function checkTieredCollectionBonuses() {
            const kiwis = gameState.collectedKiwis;
            const broccolis = gameState.collectedBroccolis;
            const total = kiwis + broccolis;
            
            // Tier 1: 5+ of one type (250 points)
            if ((kiwis >= 5 || broccolis >= 5) && !gameState.collectionBonusAwarded.fiveOfOne) {
                awardTieredBonus('fiveOfOne', 250, `5+ ${kiwis >= 5 ? 'Kiwis' : 'Broccolis'}`);
            }
            
            // Tier 2: All 30 kiwis OR all 7 broccolis (500 points)
            if ((kiwis >= 30 || broccolis >= 7) && !gameState.collectionBonusAwarded.allOfOne) {
                awardTieredBonus('allOfOne', 500, `All ${kiwis >= 30 ? '30 Kiwis' : '7 Broccolis'}`);
            }
            
            // Tier 3: All 37 collectibles (1000 points)
            if (total >= 37 && !gameState.collectionBonusAwarded.allThirtySeven) {
                awardTieredBonus('allThirtySeven', 1000, 'Perfect Collection - All 37!');
            }
            
            // NEW: Broccoli specific bonuses
            // Tier B1: 5 broccolis (200 points)
            if (broccolis >= 5 && !gameState.collectionBonusAwarded.broccoliMaster) {
                awardTieredBonus('broccoliMaster', 200, 'BROCCOLI MASTER! 🥦');
            }
            
            // Tier B2: 7 broccolis (500 points)
            if (broccolis >= 7 && !gameState.collectionBonusAwarded.veggieChampion) {
                awardTieredBonus('veggieChampion', 500, 'VEGGIE CHAMPION! 🏆');
            }
        }
        
        function awardTieredBonus(tier, points, achievement) {
            gameState.collectionBonusAwarded[tier] = true;
            addScore(points, `collection_${tier}`);
            
            // Special celebration effects
            showCollectionAchievement(achievement, points);
            
            // Audio celebration - different tones for each tier
            if (tier === 'fiveOfOne') {
                audioManager.createTone(523, 0.3, 'sine'); // C5
            } else if (tier === 'allOfOne') {
                audioManager.createTone(659, 0.3, 'sine'); // E5
                setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 150); // G5
            } else if (tier === 'allThirtySeven') {
                audioManager.createTone(523, 0.3, 'sine'); // C5
                setTimeout(() => audioManager.createTone(659, 0.3, 'sine'), 150); // E5
                setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 300); // G5
                setTimeout(() => audioManager.createTone(1047, 0.4, 'sine'), 450); // C6
            }
            
            console.log(`🎉 ${achievement.toUpperCase()} BONUS! +${points} points`);
        }
        
        // NEW: Show collection achievement UI
        function showCollectionAchievement(achievement, points) {
            // Create achievement popup (you can enhance this with actual UI)
            const total = gameState.collectedKiwis + gameState.collectedBroccolis;
            
            // For now, show in console - can be enhanced with visual UI later
            console.log(`
🏆 ${achievement.toUpperCase()} ACHIEVED! 🏆
━━━━━━━━━━━━━━━━━━━━
🥝 Kiwis: ${gameState.collectedKiwis} | 🥦 Broccolis: ${gameState.collectedBroccolis}
📊 Total: ${total}/14
💎 Bonus Score: +${points} points
━━━━━━━━━━━━━━━━━━━━
            `);
            
            // Trigger confetti or other celebration effects
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createParticleEffect(
                        new THREE.Vector3(
                            player.position.x + (Math.random() - 0.5) * 4,
                            player.position.y + 3,
                            player.position.z
                        ),
                        [0xFFD700, 0x00FF00, 0xFF69B4][i % 3],
                        'celebration'
                    );
                }, i * 100);
            }
        }
        
        function exitTunnelTransition() {
            console.log('Exiting tunnel...');
            gameState.currentEnvironment = 'tunnel_exit';
            gameState.environmentTransition = true;
            gameState.lastTunnelExit = performance.now();
            
            // Update UI
            updateEnvironmentUI();
            
            // Schedule next tunnel
            const currentTime = performance.now();
            const gameTime = (currentTime - gameState.gameStartTime);
            gameState.nextTunnelTime = gameTime + gameState.tunnelCooldown;
            
            // Audio effect for tunnel exit
            audioManager.createTone(400, 0.3, 'sine');
            
            // Restore ambient lighting gradually
            gameState.ambientLightIntensity = 1.0;
            if (scene.children.find(child => child.type === 'AmbientLight')) {
                scene.children.find(child => child.type === 'AmbientLight').intensity = 1.0;
            }
            
            // Clean up tunnel segments gradually
            setTimeout(() => {
                cleanupTunnelSegments();
                gameState.currentEnvironment = 'street';
                gameState.environmentTransition = false;
                updateEnvironmentUI();
                console.log('Back to street!');
            }, 3000);
        }
        
        function updateBridgeEnvironment(deltaTime) {
            // Move bridge segments
            gameState.tunnelSegments.forEach((segment, index) => {
                segment.position.z += visualSpeed * gameState.timeScaleFactor;
                
                // Remove segments that have passed the player
                if (segment.position.z > 15) {
                    scene.remove(segment);
                    gameState.tunnelSegments.splice(index, 1);
                }
            });
            
            // Animate cars on bridges
            gameState.tunnelSegments.forEach(segment => {
                segment.children.forEach(child => {
                    if (child.material && child.material.color && 
                        (child.material.color.r > 0.8 || child.material.color.b > 0.8)) { // Car objects
                        child.position.x += (Math.random() - 0.5) * 0.01; // Slight car movement
                    }
                });
            });
        }
        
        function cleanupTunnelSegments() {
            gameState.tunnelSegments.forEach(segment => {
                scene.remove(segment);
            });
            gameState.tunnelSegments = [];
        }
        
        function getTunnelSpecificObstacles() {
            // Tunnel-specific obstacles that make sense in confined space
            return [
                'lowbarrier', 'duckbeam', 'wallgap', 'spikes',
                'rotatingblade', 'swinginghammer' // Moving obstacles work well in tunnels
            ];
        }
        
        // ==================== END TUNNEL ENVIRONMENT SYSTEM ====================
        
        // ==================== END POWER-UP SYSTEM ====================
        
        // Near-miss detection and bonus system
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            // Prevent multiple near-miss triggers for same obstacle
            if (obstacle.nearMissTriggered) return;
            obstacle.nearMissTriggered = true;
            
            // Calculate how close the call was
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const nearMissBonus = Math.floor((0.3 - distance) * 100); // Closer = more points
            
            addScore(nearMissBonus, 'near_miss_bonus');
            
            // Near-miss audio feedback
            audioManager.play('nearmiss');
            
            // Enhanced visual feedback for near miss
            const effectPos = obstacle.mesh.position.clone();
            
            // Create multiple spark effects
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const sparkPos = effectPos.clone();
                    sparkPos.x += (Math.random() - 0.5);
                    sparkPos.y += Math.random() * 0.5;
                    sparkPos.z += (Math.random() - 0.5) * 0.5;
                    createParticleEffect(sparkPos, 0xFFFF00, 'spark');
                }, i * 30);
            }
            
            // Main near miss effect
            createParticleEffect(effectPos, 0xFFD700, 'nearMiss');
            
            // Camera effect for close calls
            if (distance < 0.1) {
                cameraZoomEffect(1.05, 150);
            }
            
            // Show near-miss popup
            showScorePopup(nearMissBonus, effectPos, distance < 0.1 ? 'SUPER CLOSE!' : 'CLOSE!');
        }
        
        // Update animations for moving obstacles
        function updateMovingObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                obstacle.animationTime += deltaTime * 0.001; // Convert to seconds
                
                switch (obstacle.type) {
                    case 'rotatingblade':
                        // Rotate the blade group
                        const bladeGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (bladeGroup) {
                            bladeGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                            
                            // Add warning sound for fast rotating blades
                            if (obstacle.rotationSpeed > 4 && Math.random() > 0.98) {
                                audioManager.createNoise(0.02, 800 + Math.random() * 400);
                            }
                        }
                        break;
                        
                    case 'swinginghammer':
                        // Swing the hammer arm
                        const hammerGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (hammerGroup) {
                            const armGroup = hammerGroup.children.find(child => child.type === 'Group');
                            if (armGroup) {
                                const swingAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                                armGroup.rotation.z = swingAngle;
                                
                                // Add swoosh sound at swing extremes
                                if (Math.abs(swingAngle) > obstacle.swingAmplitude * 0.8 && Math.random() > 0.95) {
                                    audioManager.createNoise(0.03, 1200 + Math.abs(swingAngle) * 500);
                                }
                            }
                        }
                        break;
                        
                    case 'movingwall':
                        // Move the wall side to side
                        const movingWall = obstacle.mesh.children[0];
                        if (movingWall) {
                            const movement = Math.sin(obstacle.animationTime * obstacle.movementSpeed) * obstacle.movementRange;
                            obstacle.mesh.position.x = obstacle.initialX + movement;
                            
                            // Add mechanical sound when changing direction
                            const prevMovement = Math.sin((obstacle.animationTime - deltaTime * 0.001) * obstacle.movementSpeed) * obstacle.movementRange;
                            if (Math.sign(movement) !== Math.sign(prevMovement) && Math.random() > 0.9) {
                                audioManager.createTone(150, 0.1, 'square');
                            }
                        }
                        break;
                        
                    case 'bouncingball':
                        // Bounce the ball up and down with realistic physics
                        const ballGroup = obstacle.mesh.children[0];
                        if (ballGroup) {
                            const ball = ballGroup.children[0]; // The actual ball
                            const shadow = ballGroup.children[1]; // Ground shadow
                            const ring = ballGroup.children[2]; // Warning ring
                            
                            if (ball && shadow && ring) {
                                // Bouncing motion using sine wave with gravity simulation
                                const bouncePhase = obstacle.animationTime * obstacle.bounceSpeed;
                                const bounceHeight = Math.abs(Math.sin(bouncePhase)) * obstacle.bounceHeight;
                                ball.position.y = 0.6 + bounceHeight; // 0.6 is ball radius
                                
                                // Scale shadow based on height (higher = smaller shadow)
                                const shadowScale = 1 - (bounceHeight / obstacle.bounceHeight) * 0.3;
                                shadow.scale.set(shadowScale, 1, shadowScale);
                                
                                // Pulse warning ring
                                const ringPulse = 1 + Math.sin(obstacle.animationTime * 8) * 0.2;
                                ring.scale.set(ringPulse, 1, ringPulse);
                                
                                // Add bounce sound at impact
                                if (bounceHeight < 0.2 && Math.random() > 0.97) {
                                    audioManager.createTone(200 + Math.random() * 100, 0.1, 'square');
                                }
                            }
                        }
                        break;
                        
                    case 'spinninglaser':
                        // Spin the laser beams and pulse warning lights
                        const laserGroup = obstacle.mesh.children[0];
                        if (laserGroup) {
                            const laserBeamGroup = laserGroup.children.find(child => child.type === 'Group');
                            
                            if (laserBeamGroup) {
                                // Rotate laser beams
                                laserBeamGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                                
                                // Pulse warning lights
                                const pulseFactor = (Math.sin(obstacle.animationTime * obstacle.pulseSpeed) + 1) / 2;
                                laserGroup.children.forEach(child => {
                                    if (child.geometry && child.geometry.type === 'SphereGeometry') {
                                        child.material.emissive.setHex(pulseFactor > 0.5 ? 0x440000 : 0x220000);
                                    }
                                });
                                
                                // Add laser whir sound
                                if (obstacle.rotationSpeed > 2.5 && Math.random() > 0.98) {
                                    audioManager.createNoise(0.02, 1500 + Math.random() * 500);
                                }
                            }
                        }
                        break;
                }
            });
        }

        function showScorePopup(score, position) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#00FF00';
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.fillText(`+${score}`, 64, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            
            sprite.position.copy(position);
            sprite.position.y += 2;
            sprite.scale.set(2, 1, 1);
            scene.add(sprite);
            
            // Animate popup
            const startY = sprite.position.y;
            const animatePopup = () => {
                sprite.position.y += 0.05;
                sprite.material.opacity -= 0.02;
                
                if (sprite.material.opacity > 0) {
                    requestAnimationFrame(animatePopup);
                } else {
                    scene.remove(sprite);
                }
            };
            animatePopup();
        }

        function loseLife() {
            gameState.lives--;
            
            // Make player invulnerable for 2 seconds
            gameState.invulnerable = true;
            gameState.invulnerabilityTime = 2000;
            
            // Visual feedback - make player flash red
            player.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0xFF6B6B);
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            
            if (gameState.lives <= 0) {
                endGame();
            }
        }

        // Smooth linear interpolation function
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        // Enhanced environment movement with parallax and smooth speed
        function updateEnvironmentMovement(deltaTime) {
            // Smooth speed interpolation
            visualSpeed = lerp(visualSpeed, gameState.speed * gameState.timeScaleFactor, SPEED_LERP_FACTOR);
            
            // Move all environment objects with parallax effect
            Object.keys(environmentObjects).forEach(category => {
                environmentObjects[category].forEach((obj, index) => {
                    if (obj && obj.userData) {
                        const parallaxSpeed = visualSpeed * obj.userData.parallaxSpeed;
                        obj.position.z += parallaxSpeed;
                        
                        // Reset object position when it goes too far
                        if (obj.position.z > 50) {
                            // Calculate new spawn position based on object type
                            let resetDistance = -150;
                            if (obj.userData.type === 'building') {
                                resetDistance = -200 - Math.random() * 50;
                            } else if (obj.userData.type === 'streetLamp') {
                                resetDistance = -120;
                            } else if (obj.userData.type === 'streetLine') {
                                resetDistance = -120;
                            }
                            
                            obj.position.z = resetDistance;
                            
                            // Add some variation for buildings
                            if (obj.userData.type === 'building') {
                                // Randomize building properties
                                const side = obj.position.x < 0 ? 'left' : 'right';
                                const baseX = side === 'left' ? -15 : 15;
                                obj.position.x = baseX + (Math.random() - 0.5) * 8;
                                
                                // Update parallax speed slightly for variation
                                obj.userData.parallaxSpeed = 0.7 + Math.random() * 0.2;
                            }
                        }
                    }
                });
            });
        }
        
        // Dynamic audio system that responds to speed
        let lastEngineTime = 0;
        function updateDynamicAudio() {
            const currentTime = performance.now();
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Engine sound every 800ms, pitch increases with speed
            if (currentTime - lastEngineTime > 800) {
                audioManager.play('engine');
                lastEngineTime = currentTime;
            }
            
            // High-speed wind effects
            if (speedRatio > 0.7 && Math.random() > 0.95) {
                // Occasional high-speed wind whoosh
                audioManager.createNoise(0.08, 4000 + speedRatio * 2000);
            }
            
            // Master volume adjustment based on speed for intensity
            const baseVolume = 0.3;
            const speedVolume = baseVolume * (0.8 + speedRatio * 0.4);
            if (audioManager.audioContext && audioManager.masterGain) {
                audioManager.masterGain.gain.setValueAtTime(speedVolume, audioManager.audioContext.currentTime);
            }
        }
        
        // Enhanced motion blur effect at high speeds
        function updateVisualEffects() {
            const speedRatio = visualSpeed / gameState.maxSpeed;
            
            // Dynamic fog based on speed
            if (scene.fog) {
                scene.fog.near = 20 - speedRatio * 10; // Closer fog at high speed
                scene.fog.far = 60 + speedRatio * 20; // Extended range
            }
            
            // Camera FOV effect for speed sensation
            const baseFov = 60;
            const speedFov = baseFov + speedRatio * 15; // Wider FOV at high speed
            camera.fov = lerp(camera.fov, speedFov, 0.02);
            camera.updateProjectionMatrix();
            
            // Enhanced camera shake at high speeds
            if (speedRatio > 0.7) {
                const shakeIntensity = (speedRatio - 0.7) * 0.1;
                gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, shakeIntensity);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Calculate delta time for smooth movement
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            // Apply time scale for adrenaline mode
            const scaledDeltaTime = deltaTime * gameState.timeScaleFactor;
            
            if (gameState.isPlaying) {
                // Update player position
                const targetX = LANE_POSITIONS[gameState.playerLane];
                player.position.x += (targetX - player.position.x) * 0.1;
                
                // Handle jumping - FIXED: Use proper deltaTime for frame-independent physics
                if (gameState.playerAction === 'jumping') {
                    const deltaTimeSeconds = deltaTime / 1000; // Convert to seconds
                    gameState.playerY += gameState.jumpVelocity * deltaTimeSeconds;
                    gameState.jumpVelocity -= 30 * deltaTimeSeconds; // Gravity in units/second²
                    
                    // BUGFIX: Maximum jump duration safety check
                    const jumpDuration = Date.now() - gameState.jumpStartTime;
                    if (jumpDuration > gameState.maxJumpDuration) {
                        console.warn('Jump duration exceeded, forcing landing');
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                    }
                    
                    // Landing with safety check
                    if (gameState.playerY <= 0) {
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                    }
                    
                    // BUGFIX: Enhanced safety check - trigger earlier at Y < -2
                    if (gameState.playerY < -2) {
                        console.warn('Player stuck in air, resetting position');
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                        
                        // Landing Audio & Visual
                        audioManager.play('land');
                        
                        // Enhanced landing effects
                        const landingPos = new THREE.Vector3(player.position.x, 0.1, player.position.z);
                        
                        // Main landing dust
                        createParticleEffect(landingPos, 0xAAAAAA, 'landing');
                        
                        // Additional dust clouds
                        for (let i = 0; i < 4; i++) {
                            const angle = (i / 4) * Math.PI * 2;
                            const dustPos = landingPos.clone();
                            dustPos.x += Math.cos(angle) * 0.5;
                            dustPos.z += Math.sin(angle) * 0.5;
                            setTimeout(() => {
                                createParticleEffect(dustPos, 0x8B7355, 'dust');
                            }, i * 20);
                        }
                        
                        // Mini screen shake for landing
                        screenShake(0.05, 100);
                    }
                }
                
                // Handle ducking
                if (gameState.playerAction === 'ducking') {
                    player.scale.y = 0.5;
                } else {
                    player.scale.y = 1;
                }
                
                player.position.y = gameState.playerY;
                
                // Handle invulnerability
                if (gameState.invulnerable) {
                    gameState.invulnerabilityTime -= 16; // ~16ms per frame at 60fps
                    
                    // Flash effect
                    const flashRate = Math.sin(Date.now() * 0.02) > 0;
                    player.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = flashRate ? 0.3 : 0.7;
                        }
                    });
                    
                    if (gameState.invulnerabilityTime <= 0) {
                        gameState.invulnerable = false;
                        // Restore normal player appearance
                        player.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = 1.0;
                                child.material.transparent = false;
                            }
                        });
                        // Restore original colors
                        if (player.children[0]) player.children[0].material.color.setHex(0x4A90E2); // Body
                        if (player.children[1]) player.children[1].material.color.setHex(0xF5B041); // Head
                    }
                }
                
                // Move track with smooth speed
                track.children.forEach(segment => {
                    segment.position.z += visualSpeed * gameState.timeScaleFactor;
                    if (segment.position.z > 10) {
                        segment.position.z -= 100;
                    }
                });
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Move obstacles with smooth speed
                obstacles.forEach((obstacle, index) => {
                    obstacle.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    obstacle.z = obstacle.mesh.position.z;
                    
                    // Check if obstacle just passed the player (perfect avoidance)
                    if (obstacle.z > 2 && obstacle.z < 3 && !obstacle.passedPlayer) {
                        obstacle.passedPlayer = true;
                        
                        // Check if player was in same lane as obstacle
                        const obstacleX = obstacle.mesh.position.x;
                        const playerX = LANE_POSITIONS[gameState.playerLane];
                        const inSameLane = Math.abs(playerX - obstacleX) < 1.0;
                        
                        if (inSameLane) {
                            // Player successfully avoided obstacle in same lane!
                            updatePerfectStreak(true);
                            addScore(50, 'perfect_avoid');
                            showScorePopup(50, player.position, 'PERFECT!');
                        }
                    }
                    
                    if (obstacle.z > 10) {
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        addScore(10, 'shield_collision');
                    }
                });
                
                // ==================== BRIDGE SPAWNING CHECK ====================
                checkBridgeSpawning();
                
                // ==================== ENVIRONMENT-SPECIFIC OBSTACLE SPAWNING ====================
                
                // ==================== PROGRESSIVE DIFFICULTY SYSTEM ====================
                
                // Calculate game progress (0 to 1)
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 at start, 1 at end
                
                // Optimized obstacle spawning with better difficulty curve
                let baseSpawnRate, maxSpawnRate;
                
                if (gameProgress < 0.2) {
                    // Phase 1: Very gentle start (0-12s)
                    baseSpawnRate = 0.003;
                    maxSpawnRate = 0.008;
                } else if (gameProgress < 0.5) {
                    // Phase 2: Moderate challenge (12-30s)
                    baseSpawnRate = 0.008;
                    maxSpawnRate = 0.015;
                } else if (gameProgress < 0.8) {
                    // Phase 3: Challenging (30-48s)
                    baseSpawnRate = 0.012;
                    maxSpawnRate = 0.020;
                } else {
                    // Phase 4: Extreme finale (48-60s)
                    baseSpawnRate = 0.015;
                    maxSpawnRate = 0.025;
                }
                
                const phaseProgress = gameProgress < 0.2 ? gameProgress / 0.2 :
                                     gameProgress < 0.5 ? (gameProgress - 0.2) / 0.3 :
                                     gameProgress < 0.8 ? (gameProgress - 0.5) / 0.3 :
                                     (gameProgress - 0.8) / 0.2;
                
                const progressiveSpawnRate = baseSpawnRate + (maxSpawnRate - baseSpawnRate) * phaseProgress;
                
                // Speed multiplier adjusted for combo potential
                const speedRatio = gameState.speed / gameState.maxSpeed;
                const spawnSpeedMultiplier = 1 + speedRatio * 0.2; // Gentler speed scaling
                
                let spawnRate = progressiveSpawnRate * spawnSpeedMultiplier;
                
                // Dynamic adjustment based on player performance
                if (gameState.consecutiveAvoidances > 5) {
                    // Player is doing well, slightly increase challenge
                    spawnRate *= 1.1;
                } else if (gameState.lives === 1) {
                    // Player struggling, reduce difficulty slightly
                    spawnRate *= 0.85;
                }
                
                // Reduce spawn rate during bridge transitions
                if (gameState.environmentTransition) {
                    spawnRate *= 0.3;
                }
                
                if (Math.random() < spawnRate) {
                    // Simplified obstacle spawning
                    const jumpObstacles = ['lowbarrier', 'jumpblock', 'hurdleset'];
                    const duckObstacles = ['highbarrier', 'duckbeam', 'wallgap'];
                    const flexibleObstacles = ['spikes'];
                    const movingObstacles = ['rotatingblade', 'swinginghammer', 'movingwall', 'bouncingball', 'spinninglaser'];
                    
                    let type;
                    const rand = Math.random();
                    
                    // Progressive difficulty for obstacle types
                    // Early game: mostly simple obstacles
                    // Late game: more complex moving obstacles
                    let movingChance, complexChance;
                    
                    if (gameProgress < 0.3) {
                        // First 30% of game: mostly basic obstacles
                        movingChance = 0.02; // Very few moving obstacles
                        complexChance = 0.1; // Few complex obstacles
                    } else if (gameProgress < 0.6) {
                        // Middle 30%: gradually introduce moving obstacles
                        movingChance = 0.02 + (gameProgress - 0.3) * 0.3; // 2% to 11%
                        complexChance = 0.3;
                    } else {
                        // Final 40%: more challenging obstacles
                        movingChance = 0.11 + (gameProgress - 0.6) * 0.225; // 11% to 20%
                        complexChance = 0.5;
                    }
                    
                    if (rand < movingChance) {
                        // Moving obstacles (progressive introduction)
                        type = movingObstacles[Math.floor(Math.random() * movingObstacles.length)];
                    } else if (rand < movingChance + complexChance) {
                        // Complex static obstacles (hurdleset, highbarrier)
                        const complexObstacles = ['hurdleset', 'highbarrier'];
                        type = complexObstacles[Math.floor(Math.random() * complexObstacles.length)];
                    } else if (rand < movingChance + complexChance + 0.3) {
                        // Jump obstacles (basic)
                        type = jumpObstacles[Math.floor(Math.random() * jumpObstacles.length)];
                    } else if (rand < movingChance + complexChance + 0.6) {
                        // Duck obstacles (basic)
                        type = duckObstacles[Math.floor(Math.random() * duckObstacles.length)];
                    } else {
                        // Flexible obstacles (easiest)
                        type = flexibleObstacles[Math.floor(Math.random() * flexibleObstacles.length)];
                    }
                    
                    const lane = Math.floor(Math.random() * 3);
                    createObstacle(type, lane, -30);
                    
                    // Spawn mystery box with obstacle (1% chance)
                    spawnMysteryBox();
                }
                
                // ==================== PROGRESSIVE POWER-UP & COIN SPAWNING ====================
                
                // Progressive Power-Up spawning (rare at start, more frequent later)
                const basePowerUpRate = 0.001; // Very low at start
                const maxPowerUpRate = 0.006; // Higher at end
                const progressivePowerUpRate = basePowerUpRate + (maxPowerUpRate - basePowerUpRate) * Math.pow(gameProgress, 1.5);
                
                if (Math.random() < progressivePowerUpRate && !gameState.activePowerUp) {
                    // Filter out largeMagnet from regular spawning
                    let powerUpTypes = Object.keys(POWER_UP_TYPES).filter(type => type !== 'largeMagnet');
                    
                    // LIMIT: Remove magnets if we already have 2
                    if (gameState.magnetCount >= 2) {
                        powerUpTypes = powerUpTypes.filter(type => type !== 'magnet');
                    }
                    
                    // Don't spawn anything if no types available
                    if (powerUpTypes.length === 0) return;
                    
                    let selectedType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    
                    // Special handling for magnet - sometimes spawn large magnet instead
                    if (selectedType === 'magnet' && Math.random() < 0.3) { // 30% chance for large magnet
                        selectedType = 'largeMagnet';
                    }
                    
                    // Track magnet spawns
                    if (selectedType === 'magnet' || selectedType === 'largeMagnet') {
                        gameState.magnetCount++;
                    }
                    
                    const lane = Math.floor(Math.random() * 3);
                    
                    const powerUp = createSimplePowerUp(selectedType, lane, -35);
                    gameState.powerUps.push(powerUp);
                }
                
                // ENHANCED: Smart Collectible Spawning with Obstacle Avoidance
                // Helper function to check if lane is safe for collectible spawning
                const isLaneClearForCollectible = (lane, zPosition, safeDistance = 12) => {
                    return !obstacles.some(obs => 
                        Math.abs(obs.position.x - LANE_POSITIONS[lane]) < 1.5 && 
                        Math.abs(obs.position.z - zPosition) < safeDistance
                    );
                };
                
                // Dynamic spawn rate based on speed (reduce at high speeds)
                const baseCollectibleRate = 0.025; // MAJOR INCREASE: Much more collectibles
                const maxCollectibleRate = 0.060; // MAJOR INCREASE: Maximum collectible density
                const speedFactor = Math.max(0.4, 1 - (gameState.speed - 100) / 300); // Reduce spawn at high speeds
                const progressiveCollectibleRate = (baseCollectibleRate + (maxCollectibleRate - baseCollectibleRate) * Math.pow(gameProgress, 1.1)) * speedFactor;
                
                if (Math.random() < progressiveCollectibleRate) {
                    // Progressive kiwi pattern complexity
                    let pattern;
                    const patternRand = Math.random();
                    
                    if (gameProgress < 0.3) {
                        // Early game: mostly single kiwis
                        pattern = patternRand < 0.8 ? 'single' : 'line';
                    } else if (gameProgress < 0.6) {
                        // Mid game: introduce more patterns
                        if (patternRand < 0.5) {
                            pattern = 'single';
                        } else if (patternRand < 0.8) {
                            pattern = 'line';
                        } else {
                            pattern = 'arc';
                        }
                    } else {
                        // Late game: more complex patterns, more rewards
                        if (patternRand < 0.3) {
                            pattern = 'single';
                        } else if (patternRand < 0.6) {
                            pattern = 'line';
                        } else {
                            pattern = 'arc';
                        }
                    }
                    
                    // USER REQUEST: Minimum 20 Kiwis + 7 Broccolis guaranteed
                    // Allow up to 40 total for good gameplay
                    const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
                    if (collectedTotal >= 40) {
                        // Max collectibles collected, no more spawning
                        return;
                    }
                    
                    // CORRECTED: Use collected counts for spawn logic, not active counts
                    const kiwiCount = gameState.collectedKiwis;
                    const broccoliCount = gameState.collectedBroccolis;
                    
                    // Determine what to spawn based on 30:7 target ratio (minimum guaranteed)
                    let isKiwi;
                    if (kiwiCount >= 30) {
                        isKiwi = false; // Force broccoli if we have 30 kiwis
                    } else if (broccoliCount >= 7) {
                        isKiwi = true; // Force kiwi if we have 7 broccolis
                    } else {
                        // Weighted spawning for 30:7 ratio (81% kiwi, 19% broccoli)
                        const totalTarget = 37;
                        const currentRatio = kiwiCount / (kiwiCount + broccoliCount + 1);
                        const targetRatio = 30 / totalTarget; // ~0.81
                        
                        // Bias towards kiwis if we're below target ratio
                        if (currentRatio < targetRatio) {
                            isKiwi = Math.random() < 0.85; // Strong bias toward kiwis
                        } else {
                            isKiwi = Math.random() < 0.25; // Strong bias toward broccolis
                        }
                    }
                    
                    console.log(`🎯 Spawning ${isKiwi ? 'Kiwi' : 'Broccoli'} - Pattern: ${pattern} (K:${kiwiCount}, B:${broccoliCount})`);
                    
                    if (pattern === 'single') {
                        // ENHANCED: Find safe lanes for spawning
                        const safeLanes = [];
                        const baseSpawnZ = -35 - (gameState.speed - 100) * 0.05; // Further away at high speeds
                        
                        for (let lane = 0; lane < 3; lane++) {
                            if (isLaneClearForCollectible(lane, baseSpawnZ)) {
                                safeLanes.push(lane);
                            }
                        }
                        
                        if (safeLanes.length > 0) {
                            const lane = safeLanes[Math.floor(Math.random() * safeLanes.length)];
                            if (isKiwi) {
                                const kiwi = createSimpleKiwi(lane, baseSpawnZ);
                                gameState.kiwis.push(kiwi);
                            } else {
                                const broccoli = createBroccoli(lane, baseSpawnZ, 'single');
                                gameState.broccolis.push(broccoli);
                            }
                        }
                    } else if (pattern === 'line') {
                        // ENHANCED: Smart line spawning with obstacle avoidance
                        const baseSpawnZ = -35 - (gameState.speed - 100) * 0.05;
                        const safeLanes = [];
                        
                        for (let lane = 0; lane < 3; lane++) {
                            if (isLaneClearForCollectible(lane, baseSpawnZ)) {
                                safeLanes.push(lane);
                            }
                        }
                        
                        // FIXED: Maximum 2 collectibles per line, never all 3 simultaneously
                        if (safeLanes.length >= 2) {
                            // Randomly select max 2 lanes from safe lanes to prevent overwhelming patterns
                            const maxLanes = Math.min(2, safeLanes.length);
                            const selectedLanes = [];
                            
                            // Shuffle and select up to 2 lanes
                            const shuffledLanes = [...safeLanes].sort(() => Math.random() - 0.5);
                            for (let i = 0; i < maxLanes; i++) {
                                selectedLanes.push(shuffledLanes[i]);
                            }
                            
                            console.log(`🎯 LINE PATTERN: Spawning in ${selectedLanes.length} lanes (${selectedLanes.join(',')}) out of ${safeLanes.length} safe lanes`);
                            
                            for (const lane of selectedLanes) {
                                // BUGFIX: Check collected counts, not spawned total
                                const currentCollectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
                                if (currentCollectedTotal >= 40) break; // Updated limit
                                
                                // FIXED: Use collected counts for proper balance
                                const currentKiwiCount = gameState.collectedKiwis;
                                const currentBroccoliCount = gameState.collectedBroccolis;
                                
                                let spawnKiwi;
                                if (currentKiwiCount >= 30) {
                                    spawnKiwi = false; // Force broccoli if we have 30 kiwis
                                } else if (currentBroccoliCount >= 7) {
                                    spawnKiwi = true; // Force kiwi if we have 7 broccolis
                                } else {
                                    spawnKiwi = Math.random() < 0.85; // 85% kiwi, 15% broccoli
                                }
                                
                                console.log(`🎯 LINE BALANCE: K:${currentKiwiCount}, B:${currentBroccoliCount}, spawning ${spawnKiwi ? 'Kiwi' : 'Broccoli'}`);
                                
                                if (spawnKiwi) {
                                    const spacing = gameState.speed > 150 ? 4 : 3; // Increased spacing for better collection
                                    const kiwi = createSimpleKiwi(lane, baseSpawnZ - (lane * spacing));
                                    gameState.kiwis.push(kiwi);
                                } else {
                                    const spacing = gameState.speed > 150 ? 4 : 3; // Increased spacing for better collection
                                    const broccoli = createBroccoli(lane, baseSpawnZ - (lane * spacing), 'line');
                                    gameState.broccolis.push(broccoli);
                                }
                            }
                        }
                    } else if (pattern === 'arc') {
                        // FIXED: Smart arc spawning - maximum 2 collectibles, never all 3
                        const baseSpawnZ = -35 - (gameState.speed - 100) * 0.05;
                        const lanes = gameProgress > 0.5 ? [0, 1, 2] : [Math.floor(Math.random() * 2), Math.floor(Math.random() * 2) + 1];
                        const safeLanes = lanes.filter(lane => isLaneClearForCollectible(lane, baseSpawnZ));
                        
                        if (safeLanes.length >= 2) {  // Only spawn arc if at least 2 safe lanes
                            // FIXED: Limit to maximum 2 collectibles in arc pattern
                            const maxArcCollectibles = Math.min(2, safeLanes.length);
                            const selectedLanes = safeLanes.slice(0, maxArcCollectibles);
                            
                            console.log(`🌀 ARC PATTERN: Spawning in ${selectedLanes.length} lanes (${selectedLanes.join(',')}) out of ${safeLanes.length} safe lanes`);
                            
                            selectedLanes.forEach((lane, index) => {
                                // BUGFIX: Check collected counts, not spawned total
                                const currentCollectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
                                if (currentCollectedTotal >= 40) return; // Updated limit
                                
                                // FIXED: Use collected counts for proper balance
                                const currentKiwiCount = gameState.collectedKiwis;
                                const currentBroccoliCount = gameState.collectedBroccolis;
                                
                                let spawnKiwi;
                                if (currentKiwiCount >= 30) {
                                    spawnKiwi = false; // Force broccoli if we have 30 kiwis
                                } else if (currentBroccoliCount >= 7) {
                                    spawnKiwi = true; // Force kiwi if we have 7 broccolis
                                } else {
                                    spawnKiwi = Math.random() < 0.85; // 85% kiwi, 15% broccoli
                                }
                                
                                console.log(`🌀 ARC BALANCE: K:${currentKiwiCount}, B:${currentBroccoliCount}, spawning ${spawnKiwi ? 'Kiwi' : 'Broccoli'}`);
                                
                                const spacing = gameState.speed > 150 ? 3 : 2; // Increased spacing for better collection
                                if (spawnKiwi) {
                                    const kiwi = createSimpleKiwi(lane, baseSpawnZ - (index * spacing));
                                    gameState.kiwis.push(kiwi);
                                } else {
                                    const broccoli = createBroccoli(lane, baseSpawnZ - (index * spacing), 'arc');
                                    gameState.broccolis.push(broccoli);
                                }
                            });
                        }
                    }
                }
                
                // Update Power-Ups
                gameState.powerUps.forEach((powerUp, index) => {
                    powerUp.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    powerUp.z = powerUp.mesh.position.z;
                    
                    // Remove if passed player
                    if (powerUp.z > 10) {
                        scene.remove(powerUp.mesh);
                        gameState.powerUps.splice(index, 1);
                    }
                    
                    // Animate power-up rotation and floating
                    powerUp.animationTime += deltaTime * 0.001;
                    
                    // Special animation for magnets
                    if (powerUp.type === 'magnet' || powerUp.type === 'largeMagnet') {
                        // Wobble rotation for magnet
                        powerUp.mesh.rotation.y += 0.015;
                        powerUp.mesh.rotation.z = Math.PI / 6 + Math.sin(powerUp.animationTime * 2) * 0.1;
                        
                        // Different floating height for large magnet
                        if (powerUp.type === 'largeMagnet') {
                            powerUp.mesh.position.y = powerUp.baseY + Math.sin(powerUp.animationTime * 3) * 0.4;
                            
                            // Animate the pulsing ring
                            if (powerUp.mesh.ring) {
                                const pulseScale = 1 + Math.sin(powerUp.animationTime * 4) * 0.2;
                                powerUp.mesh.ring.scale.set(pulseScale, pulseScale, 1);
                                powerUp.mesh.ring.material.opacity = 0.3 + Math.sin(powerUp.animationTime * 3) * 0.2;
                            }
                        } else {
                            powerUp.mesh.position.y = powerUp.baseY + Math.sin(powerUp.animationTime * 3) * 0.2;
                        }
                    } else {
                        // Regular rotation for other power-ups
                        powerUp.mesh.rotation.y += 0.02;
                        powerUp.mesh.position.y = powerUp.baseY + Math.sin(powerUp.animationTime * 3) * 0.3;
                    }
                    
                    // Update particle effects
                    if (powerUp.particles) {
                        powerUp.particles.rotation.y += 0.01;
                    }
                });
                
                // Update Kiwis
                gameState.kiwis.forEach((kiwi, index) => {
                    kiwi.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    kiwi.z = kiwi.mesh.position.z;
                    
                    // Remove if passed player
                    if (kiwi.z > 10) {
                        scene.remove(kiwi.mesh);
                        gameState.kiwis.splice(index, 1);
                    }
                    
                    // Animate kiwi wobble and subtle floating
                    kiwi.animationTime += deltaTime * 0.001;
                    // Wobble rotation instead of spin
                    kiwi.mesh.rotation.z = Math.sin(kiwi.animationTime * 3) * 0.15;
                    kiwi.mesh.rotation.x = Math.cos(kiwi.animationTime * 2) * 0.1;
                    // Subtle bounce
                    const baseY = 1.2;
                    kiwi.mesh.position.y = baseY + Math.sin(kiwi.animationTime * 4) * 0.1;
                });
                
                // Update Broccolis (similar to kiwis)
                gameState.broccolis.forEach((broccoli, index) => {
                    broccoli.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    broccoli.z = broccoli.mesh.position.z;
                    
                    // Remove if passed player
                    if (broccoli.z > 10) {
                        scene.remove(broccoli.mesh);
                        gameState.broccolis.splice(index, 1);
                    }
                    
                    // Animate broccoli - different pattern than kiwis
                    broccoli.animationTime += deltaTime * 0.001;
                    // Gentle swaying motion for broccoli
                    broccoli.mesh.rotation.y = Math.sin(broccoli.animationTime * 2) * 0.1;
                    broccoli.mesh.rotation.z = Math.cos(broccoli.animationTime * 1.5) * 0.05;
                    // Slight vertical movement
                    const baseY = 1.0;
                    broccoli.mesh.position.y = baseY + Math.sin(broccoli.animationTime * 3) * 0.08;
                });
                
                // Handle Power-Up Time Remaining
                if (gameState.activePowerUp && gameState.powerUpTimeRemaining > 0) {
                    gameState.powerUpTimeRemaining -= deltaTime;
                    if (gameState.powerUpTimeRemaining <= 0) {
                        deactivatePowerUp();
                    }
                    updatePowerUpUI();
                }
                
                // Handle Fusion Time Remaining
                if (gameState.activeFusion && gameState.fusionTimeRemaining > 0) {
                    gameState.fusionTimeRemaining -= deltaTime;
                    if (gameState.fusionTimeRemaining <= 0) {
                        deactivateFusion();
                    }
                    updatePowerUpUI();
                }
                
                // Handle Adrenaline Mode Time
                if (gameState.adrenalineActive && gameState.adrenalineTimeRemaining > 0) {
                    gameState.adrenalineTimeRemaining -= deltaTime; // Use real time, not scaled
                    if (gameState.adrenalineTimeRemaining <= 0) {
                        deactivateAdrenalineMode();
                    }
                }
                
                // FEATURE 7: Handle Rampage Mode Time
                if (gameState.rampageActive && gameState.rampageTimeRemaining > 0) {
                    gameState.rampageTimeRemaining -= deltaTime;
                    if (gameState.rampageTimeRemaining <= 0) {
                        deactivateRampageMode();
                    }
                    updateRampageUI();
                }
                
                // FEATURE 8: Handle Flight Mode
                if (gameState.flightMode) {
                    // Update flight time
                    gameState.flightTimeRemaining -= deltaTime;
                    if (gameState.flightTimeRemaining <= 0) {
                        deactivateFlightMode();
                    }
                    
                    // Smooth altitude adjustment
                    const altitudeDiff = gameState.targetAltitude - gameState.flightAltitude;
                    gameState.flightAltitude += altitudeDiff * 0.1;
                    
                    // Update player Y position for flight
                    player.position.y = gameState.playerY + gameState.flightAltitude;
                    
                    // Animate jet stream
                    if (player.userData.jetStream) {
                        player.userData.jetStream.children.forEach((jet, i) => {
                            jet.children.forEach((part, j) => {
                                if (part.material && part.material.emissive) {
                                    // Pulsing effect
                                    part.material.emissiveIntensity = 0.7 + Math.sin(Date.now() * 0.01 + i + j) * 0.3;
                                }
                            });
                        });
                    }
                    
                    updateFlightUI();
                }
                
                // FEATURE 8: Update rocket boost pads
                gameState.rocketBoostPads.forEach((pad, index) => {
                    pad.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    pad.z = pad.mesh.position.z;
                    
                    // Remove if passed player
                    if (pad.z > 10) {
                        scene.remove(pad.mesh);
                        gameState.rocketBoostPads.splice(index, 1);
                    }
                    
                    // Animate boost pad
                    pad.animationTime += deltaTime * 0.001;
                    
                    // Rotating ring
                    pad.mesh.children[1].rotation.z += 0.02;
                    
                    // Pulsing rocket
                    pad.mesh.children[2].position.y = 0.7 + Math.sin(pad.animationTime * 3) * 0.1;
                    
                    // Floating particles
                    pad.mesh.children.forEach((child, i) => {
                        if (i > 2 && i < 9) { // Energy particles
                            const angle = pad.animationTime * 2 + ((i - 3) * Math.PI / 3);
                            child.position.x = Math.cos(angle) * 1.0;
                            child.position.y = 0.5 + Math.sin(angle * 2) * 0.3;
                            child.position.z = Math.sin(angle) * 1.0;
                        }
                    });
                });
                
                // FEATURE 8: Update aerial collectibles
                gameState.aerialCollectibles.forEach((aerial, index) => {
                    aerial.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    aerial.z = aerial.mesh.position.z;
                    
                    // Remove if passed player
                    if (aerial.z > 10) {
                        scene.remove(aerial.mesh);
                        gameState.aerialCollectibles.splice(index, 1);
                    }
                    
                    // Animate aerial collectibles
                    aerial.animationTime += deltaTime * 0.001;
                    aerial.mesh.rotation.y += 0.02;
                    
                    // Floating motion
                    aerial.mesh.position.y = aerial.altitude + Math.sin(aerial.animationTime * 2) * 0.2;
                });
                
                // FEATURE 8: Spawn rocket boost pads (2% chance)
                if (Math.random() < 0.002 && !gameState.flightMode) {
                    const lane = Math.floor(Math.random() * 3);
                    createRocketBoostPad(lane, -40);
                }
                
                // FEATURE 10: Score tokens DISABLED - User wants NO coins, only kiwis/broccolis
                // if (Math.random() < 0.03 && !gameState.rouletteActive) {
                //     const lane = Math.floor(Math.random() * 3);
                //     spawnScoreToken(lane, -35);
                // }
                
                // FEATURE 10: Update score tokens
                gameState.scoreTokens.forEach((token, index) => {
                    token.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    token.z = token.mesh.position.z;
                    
                    // Remove if passed player
                    if (token.z > 10) {
                        scene.remove(token.mesh);
                        gameState.scoreTokens.splice(index, 1);
                    }
                    
                    // Animate token
                    token.animationTime += deltaTime * 0.001;
                    token.mesh.rotation.y += 0.03;
                    token.mesh.position.y = token.baseY + Math.sin(token.animationTime * 4) * 0.15;
                    
                    // Pulse glow effect
                    const glow = token.mesh.children.find(child => child.geometry && child.geometry.type === 'SphereGeometry');
                    if (glow) {
                        glow.material.opacity = 0.3 + Math.sin(token.animationTime * 3) * 0.1;
                    }
                });
                
                // FEATURE 10: Update score surge
                updateScoreSurge(deltaTime);
                
                // FEATURE 9: Update daily challenge progress
                updateDailyChallengeUI();
                checkDailyChallengeProgress();
                
                // ==================== END POWER-UP & COIN SPAWNING ====================
                
                // ==================== BRIDGE ENVIRONMENT UPDATE ====================
                
                updateBridgeEnvironment(deltaTime);
                
                // ==================== END BRIDGE ENVIRONMENT UPDATE ====================
                
                // Update camera with shake effect
                const baseX = player.position.x * 0.3;
                const baseY = 3 + Math.sin(Date.now() * 0.002) * 0.05;
                const baseZ = 8;
                
                // Apply screen shake
                const shakeX = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeY = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeZ = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 0.5;
                
                camera.position.x += (baseX + shakeX - camera.position.x) * 0.05;
                camera.position.y = baseY + shakeY;
                camera.position.z = baseZ + shakeZ;
                
                camera.lookAt(player.position.x * 0.2, 1, -3);
                
                // Update game timer
                const currentTime = Date.now();
                const elapsedTime = (currentTime - gameState.gameStartTime) / 1000;
                gameState.timeRemaining = Math.max(0, gameState.gameTime - elapsedTime);
                
                // Check for victory (survived 60 seconds!)
                if (gameState.timeRemaining <= 0 && !gameState.isVictory) {
                    victoryGame();
                    return;
                }
                
                // Progressive speed increase - optimized curve for better gameplay
                const timeProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 to 1
                
                // Smoother difficulty curve with multiple phases
                let speedMultiplier;
                if (timeProgress < 0.2) {
                    // Phase 1: Gentle start (0-12s)
                    speedMultiplier = 1 + timeProgress * 2; // 1x to 1.4x
                } else if (timeProgress < 0.5) {
                    // Phase 2: Moderate increase (12-30s)
                    speedMultiplier = 1.4 + (timeProgress - 0.2) * 3; // 1.4x to 2.3x
                } else if (timeProgress < 0.8) {
                    // Phase 3: Challenging (30-48s)
                    speedMultiplier = 2.3 + (timeProgress - 0.5) * 4; // 2.3x to 3.5x
                } else {
                    // Phase 4: Extreme finale (48-60s)
                    speedMultiplier = 3.5 + Math.pow((timeProgress - 0.8) * 5, 1.5) * 2; // 3.5x to 5.5x
                }
                
                // Apply Speed Boost Power-Up multiplier
                if (gameState.speedBoostActive) {
                    speedMultiplier *= 1.5; // 50% speed increase
                }
                
                gameState.speed = gameState.baseSpeed * speedMultiplier;
                gameState.speed = Math.min(gameState.speed, gameState.maxSpeed);
                
                // Update total distance (for milestones)
                gameState.totalDistance += gameState.speed * deltaTime * 10;
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Update dynamic audio based on speed
                updateDynamicAudio();
                
                // Update moving obstacles animations
                updateMovingObstacles(deltaTime);
                
                // If game is paused for gambling, don't update speed or obstacles
                if (gameState.pausedForGambling) {
                    return;
                }
                
                // Check collisions
                checkCollisions();
                
                // Check for milestones
                checkMilestones();
                
                // Check mystery box collection
                checkMysteryBoxCollection();
                
                // Update mystery boxes
                gameState.mysteryBoxes.forEach((box, index) => {
                    if (!gameState.pausedForGambling) {
                        box.mesh.position.z += visualSpeed * gameState.timeScaleFactor;
                    }
                    
                    // Remove if passed player
                    if (box.mesh.position.z > 10) {
                        scene.remove(box.mesh);
                        gameState.mysteryBoxes.splice(index, 1);
                    }
                    
                    // Animate mystery box
                    if (!box.collected) {
                        box.animationTime += deltaTime * 0.001;
                        box.mesh.rotation.y += 0.02;
                        box.mesh.position.y = 1.5 + Math.sin(box.animationTime * 3) * 0.2;
                        
                        // Animate sparkles
                        box.mesh.children.forEach((child, i) => {
                            if (child.type === 'Mesh' && child.geometry.type === 'SphereGeometry' && child.material.color.getHex() === 0xFFFFFF) {
                                const angle = box.animationTime * 2 + (i * Math.PI / 4);
                                child.position.x = Math.cos(angle) * 0.8;
                                child.position.y = Math.sin(angle * 1.5) * 0.8;
                                child.position.z = Math.sin(angle * 0.7) * 0.8;
                            }
                        });
                    }
                });
                
                // CRITICAL FIX: Process centralized score queue instead of individual updates
                processScoreQueue();
                
                // Keep distance-based scoring (converted to use addScore)
                const timeSinceLastUpdate = (currentTime - (gameState.lastDistanceScore || 0)) / 1000;
                if (timeSinceLastUpdate >= 0.1) { // Every 100ms
                    const distanceScore = Math.floor(gameState.speed * timeSinceLastUpdate * 10);
                    addScore(distanceScore, 'distance');
                    gameState.lastDistanceScore = currentTime;
                }
                
                // Throttle UI updates to 30fps for better performance
                if (currentTime - lastUIUpdateTime > 33) { // 33ms = 30fps
                    updateUI();
                    lastUIUpdateTime = currentTime;
                }
            }
            
            renderer.render(scene, camera);
        }

        // Handle near miss detection
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            const currentTime = performance.now();
            
            // Prevent multiple near misses for the same obstacle
            if (obstacle.nearMissHandled) return;
            obstacle.nearMissHandled = true;
            
            // Update near miss streak
            if (currentTime - gameState.lastNearMissTime < 5000) { // 5 second window
                gameState.nearMissStreak++;
            } else {
                gameState.nearMissStreak = 1;
            }
            gameState.lastNearMissTime = currentTime;
            
            // Calculate near miss bonus based on distance and streak
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const precision = 1 - (distance / 0.3); // 0.3 is max near miss distance
            let nearMissBonus = Math.floor(50 + (precision * 50)); // 50-100 base points
            
            // Streak multiplier
            nearMissBonus *= Math.min(gameState.nearMissStreak, 5); // Max 5x multiplier
            
            // Add to score
            addScore(nearMissBonus, 'near_miss_bonus');
            
            // Update near miss multiplier
            gameState.nearMissMultiplier = Math.min(gameState.nearMissStreak * 0.2 + 1, 2); // Max 2x
            
            // Show near miss UI
            showNearMissUI(nearMissBonus, gameState.nearMissStreak);
            
            // Audio feedback
            audioManager.createTone(440 + (gameState.nearMissStreak * 110), 0.1, 'sine');
            
            // Visual effect
            createParticleEffect(
                player.position.clone(),
                0xFFD700,
                'nearMiss'
            );
            
            // Camera shake for dramatic effect
            gameState.cameraShakeIntensity = 0.05;
            setTimeout(() => { gameState.cameraShakeIntensity = 0; }, 200);
        }
        
        // Show near miss UI feedback
        function showNearMissUI(bonus, streak) {
            const nearMissDisplay = document.getElementById('nearMissDisplay');
            const nearMissCount = document.getElementById('nearMissCount');
            const nearMissBonus = document.getElementById('nearMissBonus');
            
            if (nearMissDisplay) {
                nearMissDisplay.style.display = 'block';
                nearMissCount.textContent = streak;
                nearMissBonus.textContent = bonus;
                
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    nearMissDisplay.style.display = 'none';
                }, 2000);
            }
        }
        
        // Check and award milestone rewards (FIXED: Based on time, not exploitable score)
        function checkMilestones() {
            const gameTimeElapsed = (performance.now() - gameState.gameStartTime) / 1000;
            const milestoneInterval = 10; // Every 10 seconds of actual gameplay
            const currentMilestone = Math.floor(gameTimeElapsed / milestoneInterval) * milestoneInterval;
            
            // Only award milestone if enough time has passed AND we haven't awarded this one yet
            if (currentMilestone > gameState.lastMilestone && currentMilestone > 0 && gameTimeElapsed >= milestoneInterval) {
                gameState.lastMilestone = currentMilestone;
                
                // Calculate milestone bonus (reasonable amounts)
                const milestoneBonus = Math.min(100, currentMilestone * 2); // Max 100 points per milestone
                addScore(milestoneBonus, 'milestone_bonus');
                
                // Show milestone UI
                showMilestoneUI(currentMilestone, milestoneBonus);
                
                // Audio celebration
                audioManager.play('powerup');
                audioManager.createTone(523, 0.2, 'sine'); // C5
                setTimeout(() => audioManager.createTone(659, 0.2, 'sine'), 100); // E5
                setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 200); // G5
                
                // Visual celebration
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        createParticleEffect(
                            new THREE.Vector3(
                                player.position.x + (Math.random() - 0.5) * 2,
                                player.position.y + 2,
                                player.position.z
                            ),
                            [0x00FF00, 0xFFD700, 0xFF00FF][i],
                            'success'
                        );
                    }, i * 100);
                }
                
                // BUGFIX: Life awards based on actual game time, not score-based milestones
                const gameTimeElapsed = (performance.now() - gameState.gameStartTime) / 1000;
                const lifeAwardInterval = 20; // Award life every 20 seconds
                const expectedLives = Math.min(5, 3 + Math.floor(gameTimeElapsed / lifeAwardInterval));
                
                if (gameState.lives < expectedLives && currentMilestone >= 1500) {
                    gameState.lives = expectedLives;
                    console.log(`Extra life awarded! Lives: ${gameState.lives} (time: ${gameTimeElapsed.toFixed(1)}s)`);
                }
            }
        }
        
        // Show milestone UI feedback
        function showMilestoneUI(distance, bonus) {
            const milestoneDisplay = document.getElementById('milestoneDisplay');
            const milestoneText = document.getElementById('milestoneText');
            const milestoneBonus = document.getElementById('milestoneBonus');
            const milestoneIcon = document.getElementById('milestoneIcon');
            
            if (milestoneDisplay) {
                milestoneDisplay.style.display = 'block';
                milestoneText.textContent = `${distance}m!`;
                milestoneBonus.textContent = bonus;
                
                // Special icons for major milestones
                if (distance >= 3000) {
                    milestoneIcon.textContent = '🏆';
                } else if (distance >= 2000) {
                    milestoneIcon.textContent = '⭐';
                } else if (distance >= 1000) {
                    milestoneIcon.textContent = '🎯';
                } else {
                    milestoneIcon.textContent = '🏁';
                }
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    milestoneDisplay.style.display = 'none';
                }, 3000);
            }
        }
        
        // Update visual effects based on speed and game state
        function updateVisualEffects() {
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Update fog density based on speed
            gameState.targetFogDensity = 0.002 + (speedRatio * 0.003);
            gameState.currentFogDensity += (gameState.targetFogDensity - gameState.currentFogDensity) * 0.1;
            if (scene.fog) {
                scene.fog.density = gameState.currentFogDensity;
            }
            
            // Speed lines effect
            if (speedRatio > 0.5) {
                gameState.speedLineIntensity = Math.min((speedRatio - 0.5) * 2, 1);
                createSpeedLines();
            }
            
            // Vignette effect at high speed
            const vignetteOverlay = document.getElementById('vignetteOverlay');
            if (vignetteOverlay) {
                if (speedRatio > 0.7) {
                    vignetteOverlay.classList.add('active');
                } else {
                    vignetteOverlay.classList.remove('active');
                }
            }
            
            // ENHANCED: Magnet vignette effect (blue/magnetic instead of black)
            const magnetVignette = document.getElementById('magnetVignette');
            if (magnetVignette) {
                if (gameState.magnetActive || gameState.adrenalineActive || gameState.activeFusion === 'magnet_speedboost' || gameState.activeFusion === 'magnet_shield') {
                    magnetVignette.classList.add('active');
                    console.log('🧲 MAGNET VIGNETTE: Activated - Blue magnetic effect active');
                } else {
                    magnetVignette.classList.remove('active');
                }
            }
            
            // Motion blur simulation
            if (speedRatio > 0.8 && !gameState.motionBlurActive) {
                gameState.motionBlurActive = true;
                renderer.domElement.style.filter = `blur(${(speedRatio - 0.8) * 2}px)`;
            } else if (speedRatio <= 0.8 && gameState.motionBlurActive) {
                gameState.motionBlurActive = false;
                renderer.domElement.style.filter = 'none';
            }
            
            // Camera shake at extreme speeds
            if (speedRatio > 0.9) {
                gameState.cameraShakeIntensity = (speedRatio - 0.9) * 0.5;
            }
            
            // Update point lights intensity based on environment
            const lights = scene.children.filter(child => child.type === 'PointLight');
            lights.forEach(light => {
                if (gameState.currentEnvironment === 'tunnel') {
                    light.intensity = 0.8;
                } else {
                    light.intensity = 0.5;
                }
            });
        }
        
        // Create speed lines for high-speed effect
        function createSpeedLines() {
            const speedLinesContainer = document.getElementById('speedLines');
            if (!speedLinesContainer || Math.random() > gameState.speedLineIntensity) return;
            
            const speedLine = document.createElement('div');
            speedLine.className = 'speed-line';
            speedLine.style.left = Math.random() * 100 + '%';
            speedLine.style.opacity = gameState.speedLineIntensity;
            
            speedLinesContainer.appendChild(speedLine);
            
            // Remove after animation
            setTimeout(() => {
                speedLine.remove();
            }, 300);
        }
        
        // Enhanced particle effect for collisions
        function createCollisionParticles(position, obstacleType) {
            // Main collision effect
            createParticleEffect(position, 0xFF4444, 'collision');
            
            // Sparks
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const sparkPos = position.clone();
                    sparkPos.x += (Math.random() - 0.5) * 2;
                    sparkPos.y += Math.random() * 2;
                    createParticleEffect(sparkPos, 0xFFFF00, 'spark');
                }, i * 50);
            }
            
            // Screen effects
            screenShake(0.3, 500);
            flashScreen(0xFF0000, 200);
        }
        
        // Flash screen effect
        function flashScreen(color, duration) {
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = `#${color.toString(16)}`;
            flash.style.opacity = '0.3';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '100';
            
            document.getElementById('gameContainer').appendChild(flash);
            
            setTimeout(() => {
                flash.style.transition = `opacity ${duration}ms`;
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), duration);
            }, 10);
        }
        
        // REMOVED: Old updateScoreWithMultipliers function replaced by centralized score system
        
        // Touch control handlers
        function handleTouchStart(event) {
            if (!gameState.isPlaying) return;
            
            const touch = event.touches[0];
            gameState.touchStartX = touch.clientX;
            gameState.touchStartY = touch.clientY;
        }
        
        function handleTouchEnd(event) {
            if (!gameState.isPlaying) return;
            
            const touch = event.changedTouches[0];
            const deltaX = touch.clientX - gameState.touchStartX;
            const deltaY = touch.clientY - gameState.touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > gameState.touchThreshold) {
                    if (deltaX > 0 && gameState.playerLane < 2) {
                        // Swipe right
                        gameState.playerLane++;
                        audioManager.play('whoosh');
                        trackPlayerMove('right', gameState.playerLane);
                    } else if (deltaX < 0 && gameState.playerLane > 0) {
                        // Swipe left
                        gameState.playerLane--;
                        audioManager.play('whoosh');
                        trackPlayerMove('left', gameState.playerLane);
                    }
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > gameState.touchThreshold) {
                    if (deltaY < 0 && gameState.playerAction === 'running') {
                        // Swipe up - jump
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        audioManager.play('jump');
                        // Sprung-Partikel (nur bei erfolgreichem Obstacle-Avoidance)
                        // Removed automatic jump particles - only success particles when avoiding obstacles
                        trackPlayerMove('jumping');
                    } else if (deltaY > 0 && gameState.playerAction === 'running') {
                        // Swipe down - duck
                        gameState.playerAction = 'ducking';
                        audioManager.play('duck');
                        trackPlayerMove('ducking');
                    }
                }
            }
        }
        
        function handleTouchMove(event) {
            // Prevent scrolling while playing
            if (gameState.isPlaying) {
                event.preventDefault();
            }
        }

        function onWindowResize() {
            const canvas = document.getElementById('gameCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        // Event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        // Touch event listeners
        gameState.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (gameState.isTouchDevice) {
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            
            // Auto-release duck after swipe down
            document.addEventListener('touchend', (event) => {
                if (gameState.playerAction === 'ducking') {
                    setTimeout(() => {
                        if (gameState.playerAction === 'ducking') {
                            gameState.playerAction = 'running';
                        }
                    }, 500); // Auto-release after 500ms
                }
            });
        }

        // Debug function for testing
        window.testFunction = function() {
            console.log('Test function works!');
            console.log('THREE object:', typeof THREE);
            console.log('gameState:', gameState);
            console.log('scene:', scene);
            console.log('camera:', camera);
            console.log('renderer:', renderer);
        };

        // Initialize game
        console.log('Starting game initialization...');
        init();
        initializeFusionSystem();
        
        // ==================== TRICK SYSTEM ====================
        
        function checkForTricks() {
            const currentTime = performance.now();
            const history = gameState.trickMoveHistory;
            
            if (history.length < 2) return;
            
            // Check for Double Jump (W-W within 0.5s)
            if (history.length >= 2) {
                const lastTwo = history.slice(-2);
                if (lastTwo[0].type === 'jumping' && lastTwo[1].type === 'jumping') {
                    const timeDiff = lastTwo[1].time - lastTwo[0].time;
                    if (timeDiff < 500 && currentTime - gameState.lastTrickTime > 1000) {
                        executeTrick('doubleJump', 200);
                    }
                }
            }
            
            // Check for Wallrun (Jump near wall obstacle)
            const nearbyObstacles = obstacles.filter(obs => 
                Math.abs(obs.mesh.position.z) < 3 && 
                (obs.type === 'movingwall' || obs.type === 'wallgap')
            );
            
            if (nearbyObstacles.length > 0 && gameState.playerAction === 'jumping') {
                if (currentTime - gameState.lastTrickTime > 1500) {
                    executeTrick('wallrun', 300);
                }
            }
            
            // Check for 360° Flip (A-D-A or D-A-D within 1s)
            if (history.length >= 3) {
                const lastThree = history.slice(-3);
                const isLeftPattern = lastThree[0].type === 'left' && 
                                     lastThree[1].type === 'right' && 
                                     lastThree[2].type === 'left';
                const isRightPattern = lastThree[0].type === 'right' && 
                                      lastThree[1].type === 'left' && 
                                      lastThree[2].type === 'right';
                
                if ((isLeftPattern || isRightPattern) && 
                    lastThree[2].time - lastThree[0].time < 1000 &&
                    currentTime - gameState.lastTrickTime > 2000) {
                    executeTrick('flip360', 500);
                }
            }
            
            // Check for Perfect Duck (last moment duck)
            if (gameState.playerAction === 'ducking') {
                const duckObstacles = obstacles.filter(obs => 
                    Math.abs(obs.mesh.position.z) < 1 && 
                    (obs.type === 'duckbeam' || obs.type === 'highbarrier' || obs.type === 'wallgap')
                );
                
                if (duckObstacles.length > 0 && currentTime - gameState.lastTrickTime > 500) {
                    executeTrick('perfectDuck', 100);
                }
            }
        }
        
        function executeTrick(trickType, basePoints) {
            const currentTime = performance.now();
            gameState.lastTrickTime = currentTime;
            
            // Calculate combo multiplier
            if (currentTime - gameState.lastTrickTime < 3000) {
                gameState.trickCombo++;
            } else {
                gameState.trickCombo = 1;
            }
            
            const comboMultiplier = Math.min(gameState.trickCombo, 5);
            const totalPoints = basePoints * comboMultiplier;
            
            // Add score
            addScore(totalPoints, `trick_${trickType}`);
            
            // Show trick announcement
            showTrickAnnouncement(trickType, totalPoints);
            
            // Update announcer level
            gameState.announcerLevel = Math.min(gameState.announcerLevel + 1, 4);
            
            // Particle effects for tricks
            const trickColors = {
                doubleJump: 0x00FF88,
                wallrun: 0xFF00FF,
                flip360: 0xFFD700,
                perfectDuck: 0x00FFFF
            };
            
            createParticleEffect(
                player.position.clone().add(new THREE.Vector3(0, 2, 0)),
                trickColors[trickType] || 0xFFFFFF,
                'success'
            );
            
            // Special audio for tricks
            audioManager.createTone(440 + (gameState.announcerLevel * 110), 0.2, 'sine');
            setTimeout(() => audioManager.createTone(880 + (gameState.announcerLevel * 110), 0.15, 'triangle'), 100);
        }
        
        function showTrickAnnouncement(trickType, points) {
            const announcer = document.getElementById('trickAnnouncer');
            const announcements = [
                'NICE!',
                'INCREDIBLE!',
                'LEGENDARY!',
                'INSANE!',
                'GODLIKE!'
            ];
            
            const trickNames = {
                doubleJump: 'DOUBLE JUMP',
                wallrun: 'WALLRUN',
                flip360: '360° FLIP',
                perfectDuck: 'PERFECT DUCK'
            };
            
            const colors = [
                '#00FF88',
                '#00FFFF', 
                '#FFD700',
                '#FF00FF',
                '#FF0044'
            ];
            
            announcer.innerHTML = `
                <div class="trick-announcement" style="color: ${colors[gameState.announcerLevel]};">
                    ${announcements[gameState.announcerLevel]}
                </div>
                <div class="trick-points">
                    ${trickNames[trickType]} +${points}
                </div>
            `;
            
            // Auto-hide after 2 seconds
            setTimeout(() => {
                announcer.innerHTML = '';
            }, 2000);
        }
        
        // ==================== MYSTERY BOX SYSTEM ====================
        
        function spawnMysteryBox() {
            // LIMIT: Maximum 2 mystery boxes per game
            if (gameState.mysteryBoxesSpawned >= 2) return;
            
            // 1% chance per obstacle spawn
            if (Math.random() > 0.01) return;
            
            gameState.mysteryBoxesSpawned++; // Track spawned boxes
            
            const lane = Math.floor(Math.random() * 3);
            const mysteryBoxGroup = new THREE.Group();
            
            // Golden sparkly box
            const boxGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const boxMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFD700,
                emissive: 0xFFD700,
                emissiveIntensity: 0.3
            });
            
            const box = new THREE.Mesh(boxGeometry, boxMaterial);
            box.rotation.y = Math.PI / 4;
            mysteryBoxGroup.add(box);
            
            // Question mark
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000';
            ctx.font = 'bold 100px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.5, 0.5, 0.5);
            sprite.position.y = 0.6;
            mysteryBoxGroup.add(sprite);
            
            // Golden glow
            const glowGeometry = new THREE.SphereGeometry(1, 12, 12);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            mysteryBoxGroup.add(glow);
            
            // Sparkle particles
            for (let i = 0; i < 8; i++) {
                const sparkle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
                );
                sparkle.position.set(
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5,
                    (Math.random() - 0.5) * 1.5
                );
                mysteryBoxGroup.add(sparkle);
            }
            
            // Position
            mysteryBoxGroup.position.set(LANE_POSITIONS[lane], 1.5, -40);
            
            scene.add(mysteryBoxGroup);
            
            gameState.mysteryBoxes.push({
                mesh: mysteryBoxGroup,
                lane: lane,
                collected: false,
                animationTime: 0
            });
        }
        
        function checkMysteryBoxCollection() {
            const playerPos = LANE_POSITIONS[gameState.playerLane];
            
            gameState.mysteryBoxes.forEach((box, index) => {
                if (box.collected) return;
                
                const distance = Math.abs(box.mesh.position.z);
                const laneMatch = box.lane === gameState.playerLane;
                
                if (distance < 2 && laneMatch) {
                    collectMysteryBox(box);
                    box.collected = true;
                    
                    // Remove after collection animation
                    setTimeout(() => {
                        scene.remove(box.mesh);
                        gameState.mysteryBoxes.splice(index, 1);
                    }, 500);
                }
            });
        }
        
        function collectMysteryBox(box) {
            // Pause game
            gameState.pausedForGambling = true;
            gameState.savedGameSpeed = gameState.speed;
            gameState.speed = 0;
            
            // Collection effect
            createParticleEffect(box.mesh.position, 0xFFD700, 'explosion');
            audioManager.play('powerup');
            
            // Show gambling UI
            setTimeout(() => {
                showGamblingUI();
            }, 300);
            
            // Update stats
            gameState.gamblingStats.totalBoxes++;
            updateGamblingStats();
        }
        
        function showGamblingUI() {
            const ui = document.getElementById('mysteryBoxUI');
            const result = document.getElementById('gamblingResult');
            
            ui.style.display = 'block';
            result.innerHTML = '';
            
            // Show stats
            document.getElementById('gamblingStats').style.display = 'block';
        }
        
        window.chooseGamble = function(choice) {
            const ui = document.getElementById('mysteryBoxUI');
            const result = document.getElementById('gamblingResult');
            
            // Disable buttons
            const buttons = ui.querySelectorAll('.gambling-button');
            buttons.forEach(btn => btn.disabled = true);
            
            // Suspense delay
            result.innerHTML = '<div style="color: #FFD700;">🎲 Rolling the dice...</div>';
            result.style.opacity = '1';
            result.style.transform = 'scale(1)';
            
            // Casino sounds
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    audioManager.createTone(200 + i * 100, 0.1, 'sine');
                }, i * 200);
            }
            
            setTimeout(() => {
                let outcome = '';
                let points = 0;
                let isDeath = false;
                
                switch (choice) {
                    case 'safe':
                        points = 200;
                        outcome = '✅ SAFE WIN! +200';
                        result.style.color = '#27ae60';
                        break;
                        
                    case 'risk':
                        if (Math.random() < 0.5) {
                            points = 800;
                            outcome = '💰 BIG WIN! +800';
                            result.style.color = '#f1c40f';
                            gameState.gamblingStats.wins++;
                        } else {
                            points = -300;
                            outcome = '💸 LOSS! -300';
                            result.style.color = '#e74c3c';
                            gameState.gamblingStats.losses++;
                        }
                        break;
                        
                    case 'yolo':
                        if (Math.random() < 0.3) {
                            points = 2000;
                            outcome = '🎆 JACKPOT! +2000';
                            result.style.color = '#FFD700';
                            gameState.gamblingStats.wins++;
                            
                            // Epic win effects
                            for (let i = 0; i < 10; i++) {
                                setTimeout(() => {
                                    createParticleEffect(
                                        new THREE.Vector3(
                                            (Math.random() - 0.5) * 10,
                                            Math.random() * 5,
                                            -5
                                        ),
                                        0xFFD700,
                                        'success'
                                    );
                                }, i * 100);
                            }
                        } else {
                            isDeath = true;
                            outcome = '💀 INSTANT DEATH!';
                            result.style.color = '#FF0000';
                            gameState.gamblingStats.losses++;
                        }
                        break;
                }
                
                result.innerHTML = `<div>${outcome}</div>`;
                
                if (!isDeath) {
                    addScore(points, 'mystery_box_gambling');
                    gameState.gamblingStats.netPoints += points;
                    
                    if (points > 0) {
                        audioManager.play('success');
                    } else {
                        audioManager.play('collision');
                    }
                    
                    // Close UI after showing result
                    setTimeout(() => {
                        ui.style.display = 'none';
                        gameState.pausedForGambling = false;
                        gameState.speed = gameState.savedGameSpeed;
                        updateGamblingStats();
                    }, 2000);
                } else {
                    // Death animation
                    audioManager.play('collision');
                    screenShake(0.5, 1000);
                    flashScreen(0xFF0000, 500);
                    
                    setTimeout(() => {
                        ui.style.display = 'none';
                        gameState.lives = 0;
                        endGame();
                    }, 1500);
                }
            }, 1500);
        };
        
        function updateGamblingStats() {
            document.getElementById('gamblingWins').textContent = gameState.gamblingStats.wins;
            document.getElementById('gamblingLosses').textContent = gameState.gamblingStats.losses;
            document.getElementById('totalGambled').textContent = gameState.gamblingStats.totalBoxes;
        }
        
        // ==================== GESTURE CONTROL SYSTEM ====================
        
        // Kalman Filter for smoothing
        class KalmanFilter {
            constructor(processNoise = 0.01, measurementNoise = 1) {
                this.processNoise = processNoise;
                this.measurementNoise = measurementNoise;
                this.value = 0;
                this.uncertainty = 1;
            }
            
            filter(measurement) {
                this.uncertainty += this.processNoise;
                const gain = this.uncertainty / (this.uncertainty + this.measurementNoise);
                this.value += gain * (measurement - this.value);
                this.uncertainty *= (1 - gain);
                return this.value;
            }
        }
        
        // Gesture Controller Class
        class GestureController {
            constructor(options = {}) {
                this.options = {
                    videoElement: options.videoElement || null,
                    canvasElement: options.canvasElement || null,
                    onGestureDetected: options.onGestureDetected || (() => {}),
                    onStatsUpdate: options.onStatsUpdate || (() => {}),
                    onError: options.onError || (() => {}),
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    smoothingFrames: 5,
                    sensitivity: 0.5,
                    debugMode: false
                };
                
                this.isRunning = false;
                this.faceLandmarker = null;
                this.lastVideoTime = -1;
                this.gestureHistory = [];
                this.lastGesture = 'NONE';
                
                this.calibrationData = {
                    neutralYaw: 0,
                    neutralPitch: 0,
                    isCalibrated: false
                };
                
                this.stats = {
                    fps: 0,
                    frameCount: 0,
                    lastFrameTime: performance.now(),
                    faceDetected: false,
                    yaw: 0,
                    pitch: 0
                };
                
                this.kalmanFilter = {
                    yaw: new KalmanFilter(0.01, 1),
                    pitch: new KalmanFilter(0.01, 1)
                };
                
                this.thresholds = {
                    yawLeft: -0.6,
                    yawRight: 0.6,
                    pitchUp: -0.6,
                    pitchDown: 0.6,
                    deadZone: 0.2
                };
                
                this.ctx = this.options.canvasElement ? 
                    this.options.canvasElement.getContext('2d') : null;
                
                this.frameSkipCounter = 0;
                this.frameSkipRate = 2;
            }
            
            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    this.options.videoElement.srcObject = stream;
                    
                    await new Promise((resolve) => {
                        this.options.videoElement.onloadedmetadata = resolve;
                    });
                    
                    try {
                        await this.initializeMediaPipe();
                    } catch (error) {
                        console.error('MediaPipe initialization failed:', error);
                        throw new Error('MediaPipe Vision library not loaded. Please refresh the page.');
                    }
                    
                    this.isRunning = true;
                    this.detectLoop();
                    
                    setTimeout(() => this.calibrate(), 2000);
                    
                } catch (error) {
                    this.options.onError(`Failed to start camera: ${error.message}`);
                    throw error;
                }
            }
            
            stop() {
                this.isRunning = false;
                
                if (this.options.videoElement && this.options.videoElement.srcObject) {
                    const tracks = this.options.videoElement.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    this.options.videoElement.srcObject = null;
                }
                
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.options.canvasElement.width, this.options.canvasElement.height);
                }
            }
            
            async initializeMediaPipe() {
                // BUGFIX: Check if MediaPipe is loaded and handle namespace properly
                if (!window.mediapipe || !window.mediapipe.tasks || !window.mediapipe.tasks.vision) {
                    throw new Error('MediaPipe Vision library not loaded yet');
                }
                
                try {
                    const vision = await window.mediapipe.tasks.vision.FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                    );
                    
                    this.faceLandmarker = await window.mediapipe.tasks.vision.FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker_lite/float16/latest/face_landmarker_lite.task",
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true,
                    runningMode: "VIDEO",
                    numFaces: 1,
                    minFaceDetectionConfidence: this.options.minDetectionConfidence,
                    minFacePresenceConfidence: this.options.minDetectionConfidence,
                    minTrackingConfidence: this.options.minTrackingConfidence
                });
                } catch (error) {
                    console.error('Failed to create FaceLandmarker:', error);
                    throw error;
                }
            }
            
            detectLoop() {
                if (!this.isRunning || !this.faceLandmarker) {
                    return;
                }
                
                this.frameSkipCounter++;
                if (this.frameSkipCounter < this.frameSkipRate) {
                    requestAnimationFrame(() => this.detectLoop());
                    return;
                }
                this.frameSkipCounter = 0;
                
                const video = this.options.videoElement;
                const startTimeMs = performance.now();
                
                if (video.readyState >= 2 && this.lastVideoTime !== video.currentTime) {
                    this.lastVideoTime = video.currentTime;
                    
                    const results = this.faceLandmarker.detectForVideo(video, startTimeMs);
                    
                    this.updateFPS();
                    
                    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                        this.processFaceLandmarks(results);
                        this.stats.faceDetected = true;
                    } else {
                        this.stats.faceDetected = false;
                        this.updateGesture('NONE');
                    }
                    
                    if (this.ctx) {
                        this.drawMinimalVisualization();
                    }
                    
                    this.options.onStatsUpdate(this.stats);
                }
                
                requestAnimationFrame(() => this.detectLoop());
            }
            
            processFaceLandmarks(results) {
                const landmarks = results.faceLandmarks[0];
                
                const nose = landmarks[1];
                const forehead = landmarks[9];
                const chin = landmarks[152];
                const leftEar = landmarks[234];
                const rightEar = landmarks[454];
                
                const earDistance = rightEar.x - leftEar.x;
                const faceCenterX = (leftEar.x + rightEar.x) / 2;
                const noseOffsetX = nose.x - faceCenterX;
                let yaw = (noseOffsetX / earDistance) * 2;
                
                const faceHeight = chin.y - forehead.y;
                const noseCenterY = (forehead.y + chin.y) / 2;
                const noseOffsetY = nose.y - noseCenterY;
                let pitch = (noseOffsetY / faceHeight) * 2;
                
                yaw = this.kalmanFilter.yaw.filter(yaw);
                pitch = this.kalmanFilter.pitch.filter(pitch);
                
                this.stats.yaw = yaw * 45;
                this.stats.pitch = pitch * 45;
                
                if (this.calibrationData.isCalibrated) {
                    yaw -= this.calibrationData.neutralYaw;
                    pitch -= this.calibrationData.neutralPitch;
                }
                
                yaw *= this.options.sensitivity * 2;
                pitch *= this.options.sensitivity * 2;
                
                const gesture = this.detectGesture(yaw, pitch);
                this.updateGesture(gesture);
            }
            
            detectGesture(yaw, pitch) {
                const inDeadZone = Math.abs(yaw) < this.thresholds.deadZone && 
                                  Math.abs(pitch) < this.thresholds.deadZone;
                
                if (pitch > this.thresholds.pitchDown) {
                    return 'DUCK';
                } else if (pitch < this.thresholds.pitchUp) {
                    return 'JUMP';
                } else if (yaw < this.thresholds.yawLeft) {
                    return 'MOVE_LEFT';
                } else if (yaw > this.thresholds.yawRight) {
                    return 'MOVE_RIGHT';
                } else if (inDeadZone || this.lastGesture === 'DUCK') {
                    return 'NONE';
                }
                
                return this.lastGesture;
            }
            
            updateGesture(gesture) {
                this.gestureHistory.push(gesture);
                if (this.gestureHistory.length > this.options.smoothingFrames) {
                    this.gestureHistory.shift();
                }
                
                const gestureCount = {};
                this.gestureHistory.forEach(g => {
                    gestureCount[g] = (gestureCount[g] || 0) + 1;
                });
                
                let maxCount = 0;
                let smoothedGesture = 'NONE';
                for (const [g, count] of Object.entries(gestureCount)) {
                    if (count > maxCount) {
                        maxCount = count;
                        smoothedGesture = g;
                    }
                }
                
                if (smoothedGesture !== this.lastGesture) {
                    this.lastGesture = smoothedGesture;
                    this.options.onGestureDetected(smoothedGesture);
                }
            }
            
            calibrate() {
                this.calibrationData.neutralYaw = this.stats.yaw / 45;
                this.calibrationData.neutralPitch = this.stats.pitch / 45;
                this.calibrationData.isCalibrated = true;
                
                if (this.ctx) {
                    const canvas = this.options.canvasElement;
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('KALIBRIERT!', canvas.width / 2, canvas.height / 2);
                    
                    setTimeout(() => {
                        if (this.ctx) {
                            this.ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }, 1000);
                }
            }
            
            drawMinimalVisualization() {
                const canvas = this.options.canvasElement;
                const video = this.options.videoElement;
                
                canvas.width = 160;
                canvas.height = 120;
                
                this.ctx.save();
                this.ctx.scale(-1, 1);
                this.ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
                this.ctx.restore();
                
                if (this.stats.faceDetected) {
                    this.ctx.strokeStyle = '#00ff88';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                } else {
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                }
                
                if (this.lastGesture !== 'NONE') {
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.lastGesture.replace('_', ' '), canvas.width / 2, canvas.height - 10);
                }
            }
            
            updateFPS() {
                this.stats.frameCount++;
                const now = performance.now();
                const elapsed = now - this.stats.lastFrameTime;
                
                if (elapsed >= 1000) {
                    this.stats.fps = (this.stats.frameCount * 1000) / elapsed;
                    this.stats.frameCount = 0;
                    this.stats.lastFrameTime = now;
                }
            }
            
            setSensitivity(value) {
                this.options.sensitivity = Math.max(0.1, Math.min(1, value));
            }
        }
        
        // Global gesture controller instance
        let gestureController = null;
        let gestureEnabled = false;
        
        // Initialize gesture controller
        function initGestureController() {
            // Wait for MediaPipe to load
            if (!window.mediapipe || !window.mediapipe.tasks || !window.mediapipe.tasks.vision) {
                console.warn('MediaPipe not loaded yet, waiting...');
                setTimeout(initGestureController, 500);
                return;
            }
            
            gestureController = new GestureController({
                videoElement: document.getElementById('gestureVideo'),
                canvasElement: document.getElementById('gestureCanvas'),
                onGestureDetected: handleGestureInput,
                onStatsUpdate: updateGestureStats,
                onError: showGestureError
            });
        }
        
        // Handle gesture input
        function handleGestureInput(gesture) {
            if (!gameState.isPlaying || !gestureEnabled) return;
            
            const feedbackEl = document.getElementById('gestureFeedback');
            
            switch (gesture) {
                case 'MOVE_LEFT':
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        trackPlayerMove('left', gameState.playerLane);
                        
                        // Show feedback
                        feedbackEl.textContent = '⬅️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'MOVE_RIGHT':
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        trackPlayerMove('right', gameState.playerLane);
                        
                        // Show feedback
                        feedbackEl.textContent = '➡️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'JUMP':
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                        audioManager.resume();
                        
                        createParticleEffect(
                            new THREE.Vector3(player.position.x, 0.1, player.position.z),
                            0xFFFF00,
                            'jump'
                        );
                        
                        trackPlayerMove('jumping');
                        
                        // Show feedback
                        feedbackEl.textContent = '⬆️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'DUCK':
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                        trackPlayerMove('ducking');
                        
                        // Show feedback
                        feedbackEl.textContent = '⬇️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'NONE':
                    if (gameState.playerAction === 'ducking') {
                        gameState.playerAction = 'running';
                    }
                    break;
            }
        }
        
        // Update gesture stats display
        function updateGestureStats(stats) {
            // Update status text
            const statusEl = document.getElementById('gestureStatus');
            if (stats.faceDetected) {
                statusEl.textContent = `Gesten: Aktiv (${stats.fps.toFixed(0)} FPS)`;
                statusEl.style.color = '#00ff88';
            } else {
                statusEl.textContent = 'Gesten: Kein Gesicht erkannt';
                statusEl.style.color = '#ff4444';
            }
        }
        
        // Show gesture error
        function showGestureError(message) {
            const statusEl = document.getElementById('gestureStatus');
            statusEl.textContent = `Fehler: ${message}`;
            statusEl.style.color = '#ff4444';
            
            // Disable gesture controls
            gestureEnabled = false;
            document.getElementById('gestureToggle').textContent = '🎥 Gesten aktivieren';
            document.getElementById('gestureToggle').classList.remove('active');
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('gestureCanvas').classList.remove('active');
        }
        
        // Toggle gesture control
        async function toggleGestureControl() {
            const toggleBtn = document.getElementById('gestureToggle');
            const calibrateBtn = document.getElementById('calibrateBtn');
            const canvas = document.getElementById('gestureCanvas');
            
            if (!gestureController) {
                initGestureController();
            }
            
            if (gestureEnabled) {
                // Disable gesture control
                gestureEnabled = false;
                gestureController.stop();
                toggleBtn.textContent = '🎥 Gesten aktivieren';
                toggleBtn.classList.remove('active');
                calibrateBtn.disabled = true;
                canvas.classList.remove('active');
                document.getElementById('gestureStatus').textContent = 'Gesten: Inaktiv';
            } else {
                // Enable gesture control
                try {
                    await gestureController.start();
                    gestureEnabled = true;
                    toggleBtn.textContent = '🎥 Gesten deaktivieren';
                    toggleBtn.classList.add('active');
                    calibrateBtn.disabled = false;
                    canvas.classList.add('active');
                    document.getElementById('gestureStatus').textContent = 'Gesten: Wird initialisiert...';
                } catch (error) {
                    showGestureError(error.message);
                }
            }
        }
        
        // Calibrate gestures
        function calibrateGestures() {
            if (gestureController && gestureEnabled) {
                gestureController.calibrate();
                const statusEl = document.getElementById('gestureStatus');
                statusEl.textContent = 'Kalibrierung erfolgreich!';
                statusEl.style.color = '#4CAF50';
                setTimeout(() => {
                    updateGestureStats(gestureController.stats);
                }, 2000);
            }
        }
        
        // Make functions globally available
        window.toggleGestureControl = toggleGestureControl;
        window.calibrateGestures = calibrateGestures;
        window.submitHighscore = submitHighscoreInternal;
        window.skipHighscore = skipHighscoreInternal;
        
        // ==================== END GESTURE CONTROL SYSTEM ====================
    </script>
</body>
</html>