<!-- GESICHERTE BASISVERSION 3 - FUNKTIONIERENDE HINDERNISSE & GAMEPLAY -->
<!-- Erstellt: 2025-08-03 20:00 -->
<!-- Version: BASISVERSION 3 - Stabile Version vor Collectibles-Implementation -->
<!-- Status: ‚úÖ Hindernisse funktionieren, ‚úÖ Gameplay stabil -->
<!-- TODO: Kiwis und Broccolis m√ºssen noch implementiert werden -->

<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subway Runner 3D - BASISVERSION 3</title>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #gameInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            text-align: right;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: center;
            z-index: 100;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        #menu h1 {
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        #menu button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #menu button:hover {
            background: #45a049;
        }
        
        .version-info {
            position: absolute;
            bottom: 5px;
            right: 5px;
            color: rgba(255,255,255,0.5);
            font-size: 10px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Kiwis: <span id="kiwis">0</span>/30</div>
        <div>Broccolis: <span id="broccolis">0</span>/7</div>
    </div>
    
    <div id="gameInfo">
        <div>Version: BASISVERSION 3</div>
        <div>Status: STABLE</div>
    </div>
    
    <div id="instructions">
        A/D oder ‚Üê/‚Üí: Lane wechseln | W/Space: Springen | S/‚Üì: Ducken
    </div>
    
    <div id="menu">
        <h1>üéÆ Subway Runner 3D</h1>
        <p>BASISVERSION 3 - Stabile Grundlage</p>
        <p style="color: yellow;">‚ö†Ô∏è Collectibles noch nicht implementiert</p>
        <button onclick="startGame()">Start Game</button>
    </div>
    
    <div class="version-info">BASISVERSION 3 - Gesichert am 03.08.2025 20:00</div>

    <script>
        // ===== BASISVERSION 3 - STABILES GRUNDGER√úST =====
        // Diese Version enth√§lt:
        // ‚úÖ Funktionierende Hindernisse
        // ‚úÖ Stabiles Gameplay
        // ‚úÖ Kollisionserkennung
        // ‚ùå Kiwis/Broccolis (noch zu implementieren)
        
        // Global Variables
        let scene, camera, renderer;
        let player, track = [];
        let obstacles = [];
        let kiwis = [];
        let broccolis = [];
        let collectibles = { kiwis: [], broccolis: [] };
        let gameState = {
            running: false,
            score: 0,
            kiwisCollected: 0,
            broccolisCollected: 0,
            speed: 0.12,
            baseSpeed: 0.12,
            playerLane: 1, // 0=left, 1=center, 2=right
            playerY: 0,
            jumping: false,
            ducking: false,
            jumpVelocity: 0
        };
        
        const LANE_POSITIONS = [-2, 0, 2];
        const LANE_WIDTH = 2;
        const GRAVITY = 30;
        const JUMP_POWER = 12;
        
        // Initialize Three.js
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87CEEB, 10, 100);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 4, 8);
            camera.lookAt(0, 0, -5);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Create player
            createPlayer();
            
            // Create initial track
            createTrack();
            
            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            window.addEventListener('resize', handleResize);
        }
        
        function createPlayer() {
            const geometry = new THREE.BoxGeometry(0.8, 1.5, 0.8);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            player = new THREE.Mesh(geometry, material);
            player.position.set(0, 0.75, 0);
            player.castShadow = true;
            scene.add(player);
        }
        
        function createTrack() {
            for (let i = 0; i < 100; i++) {
                const geometry = new THREE.PlaneGeometry(6, 10);
                const material = new THREE.MeshLambertMaterial({ 
                    color: i % 2 === 0 ? 0x555555 : 0x666666 
                });
                const segment = new THREE.Mesh(geometry, material);
                segment.rotation.x = -Math.PI / 2;
                segment.position.z = -i * 10;
                segment.receiveShadow = true;
                track.push(segment);
                scene.add(segment);
            }
        }
        
        function createObstacle(type, lane, z) {
            let obstacle;
            const laneX = LANE_POSITIONS[lane];
            
            switch(type) {
                case 'lowbarrier':
                    const lowGeometry = new THREE.BoxGeometry(1.8, 0.5, 0.5);
                    const lowMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                    obstacle = new THREE.Mesh(lowGeometry, lowMaterial);
                    obstacle.position.set(laneX, 0.25, z);
                    break;
                    
                case 'highbarrier':
                    const highGeometry = new THREE.BoxGeometry(1.8, 1, 3);
                    const highMaterial = new THREE.MeshLambertMaterial({ color: 0xff00ff });
                    obstacle = new THREE.Mesh(highGeometry, highMaterial);
                    obstacle.position.set(laneX, 1.4, z);
                    break;
                    
                case 'spikes':
                    const spikeGeometry = new THREE.ConeGeometry(0.3, 1, 4);
                    const spikeMaterial = new THREE.MeshLambertMaterial({ color: 0xff9900 });
                    const spikeGroup = new THREE.Group();
                    for (let i = -1; i <= 1; i++) {
                        const spike = new THREE.Mesh(spikeGeometry, spikeMaterial);
                        spike.position.set(i * 0.5, 0.5, 0);
                        spikeGroup.add(spike);
                    }
                    spikeGroup.position.set(laneX, 0, z);
                    obstacle = spikeGroup;
                    break;
                    
                default:
                    const defaultGeometry = new THREE.BoxGeometry(1.5, 1, 0.5);
                    const defaultMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });
                    obstacle = new THREE.Mesh(defaultGeometry, defaultMaterial);
                    obstacle.position.set(laneX, 0.5, z);
            }
            
            obstacle.obstacleType = type;
            obstacle.castShadow = true;
            obstacles.push(obstacle);
            scene.add(obstacle);
        }
        
        // Implementierte Kiwi-Spawn-Funktion
        function createKiwi(lane, z) {
            const kiwiGroup = new THREE.Group();
            
            // LANE_POSITIONS definieren falls nicht vorhanden
            const LANE_POSITIONS = [-2, 0, 2];
            
            // Einfache braune Kiwi-Geometrie (elliptisch)
            const kiwiRadiusX = 0.3;
            const kiwiRadiusY = 0.4; 
            const kiwiRadiusZ = 0.3;
            
            // Hauptk√∂rper - braune Au√üenhaut
            const kiwiGeometry = new THREE.SphereGeometry(1, 12, 8);
            kiwiGeometry.scale(kiwiRadiusX, kiwiRadiusY, kiwiRadiusZ);
            const skinMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,  // Braun wie spezifiziert
                emissive: 0x2A1A0A
            });
            const kiwiSkin = new THREE.Mesh(kiwiGeometry, skinMaterial);
            kiwiSkin.position.y = 0.3;  // Y = 0.3 wie spezifiziert
            kiwiSkin.castShadow = true;
            kiwiGroup.add(kiwiSkin);
            
            // Gr√ºnes Fruchtfleisch (flache Oberseite)
            const fleshGeometry = new THREE.CircleGeometry(kiwiRadiusX * 0.9, 16);
            const fleshMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90EE90,
                emissive: 0x2F5F2F
            });
            const kiwiFlesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
            kiwiFlesh.rotation.x = -Math.PI / 2;
            kiwiFlesh.position.y = 0.3 + kiwiRadiusY * 0.9;  // Oben auf dem Kiwi
            kiwiGroup.add(kiwiFlesh);
            
            // Position setzen
            kiwiGroup.position.set(LANE_POSITIONS[lane], 0, z);
            kiwiGroup.userData = { type: 'kiwi', lane: lane, collected: false };
            scene.add(kiwiGroup);
            
            const kiwiData = {
                mesh: kiwiGroup,
                lane: lane,
                z: z,
                type: 'kiwi',
                collected: false
            };
            
            kiwis.push(kiwiData);
            return kiwiData;
        }
        
        // Implementierte Broccoli-Spawn-Funktion
        function createBroccoli(lane, z) {
            const broccoliGroup = new THREE.Group();
            
            // LANE_POSITIONS definieren falls nicht vorhanden
            const LANE_POSITIONS = [-2, 0, 2];
            
            // Stiel (Stamm)
            const stemGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.6, 8);
            const stemMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A6741,  // Dunkles Gr√ºn f√ºr Stiel
                emissive: 0x1A241A
            });
            const broccoliStem = new THREE.Mesh(stemGeometry, stemMaterial);
            broccoliStem.position.y = 0.3;  // Y = 0.3 wie spezifiziert
            broccoliStem.castShadow = true;
            broccoliGroup.add(broccoliStem);
            
            // Broccoli-Kopf (mehrere kleine Kugeln)
            const floretPositions = [
                { x: 0, y: 0.5, scale: 1.0 },
                { x: -0.15, y: 0.6, scale: 0.8 },
                { x: 0.15, y: 0.6, scale: 0.8 },
                { x: 0, y: 0.7, scale: 0.9 }
            ];
            
            floretPositions.forEach(pos => {
                const floretGeometry = new THREE.SphereGeometry(0.15 * pos.scale, 8, 6);
                const floretMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x228B22,  // Gr√ºn wie spezifiziert
                    emissive: 0x0F3F0F
                });
                const floret = new THREE.Mesh(floretGeometry, floretMaterial);
                floret.position.set(pos.x, pos.y, 0);
                floret.castShadow = true;
                broccoliGroup.add(floret);
            });
            
            // Position setzen
            broccoliGroup.position.set(LANE_POSITIONS[lane], 0, z);
            broccoliGroup.userData = { type: 'broccoli', lane: lane, collected: false };
            scene.add(broccoliGroup);
            
            const broccoliData = {
                mesh: broccoliGroup,
                lane: lane,
                z: z,
                type: 'broccoli',
                collected: false
            };
            
            broccolis.push(broccoliData);
            return broccoliData;
        }
        
        function handleKeyDown(event) {
            if (!gameState.running) return;
            
            switch(event.key) {
                case 'a':
                case 'A':
                case 'ArrowLeft':
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                    }
                    break;
                case 'd':
                case 'D':
                case 'ArrowRight':
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                    }
                    break;
                case 'w':
                case 'W':
                case ' ':
                case 'ArrowUp':
                    if (!gameState.jumping) {
                        gameState.jumping = true;
                        gameState.jumpVelocity = JUMP_POWER;
                    }
                    break;
                case 's':
                case 'S':
                case 'ArrowDown':
                    gameState.ducking = true;
                    break;
            }
        }
        
        function checkCollisions() {
            const playerBBox = new THREE.Box3().setFromObject(player);
            
            // Check obstacle collisions
            for (let obstacle of obstacles) {
                if (obstacle.position.z > 2 || obstacle.position.z < -2) continue;
                
                const obstacleBBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBBox.intersectsBox(obstacleBBox)) {
                    if (obstacle.obstacleType === 'highbarrier' && gameState.ducking) {
                        // Safe - ducked under high barrier
                        continue;
                    }
                    // Game Over
                    gameOver();
                    return;
                }
            }
            
            // Check collectible collisions
            const playerBBox = new THREE.Box3().setFromObject(player);
            
            // Check kiwi collisions
            for (let i = kiwis.length - 1; i >= 0; i--) {
                if (kiwis[i].collected) continue;
                if (kiwis[i].z > 2 || kiwis[i].z < -2) continue;
                
                const kiwiBBox = new THREE.Box3().setFromObject(kiwis[i].mesh);
                if (playerBBox.intersectsBox(kiwiBBox)) {
                    // Collect kiwi
                    kiwis[i].collected = true;
                    scene.remove(kiwis[i].mesh);
                    gameState.score += 50;
                    console.log("Kiwi collected! +50 points");
                    kiwis.splice(i, 1);
                }
            }
            
            // Check broccoli collisions  
            for (let i = broccolis.length - 1; i >= 0; i--) {
                if (broccolis[i].collected) continue;
                if (broccolis[i].z > 2 || broccolis[i].z < -2) continue;
                
                const broccoliBBox = new THREE.Box3().setFromObject(broccolis[i].mesh);
                if (playerBBox.intersectsBox(broccoliBBox)) {
                    // Collect broccoli
                    broccolis[i].collected = true;
                    scene.remove(broccolis[i].mesh);
                    gameState.score += 75;
                    console.log("Broccoli collected! +75 points");
                    broccolis.splice(i, 1);
                }
            }
        }
        
        function updateGame(deltaTime) {
            if (!gameState.running) return;
            
            // Update score
            gameState.score += Math.floor(gameState.speed * 100);
            document.getElementById('score').textContent = gameState.score;
            
            // Update player position
            const targetX = LANE_POSITIONS[gameState.playerLane];
            player.position.x += (targetX - player.position.x) * 0.2;
            
            // Jump physics
            if (gameState.jumping) {
                gameState.playerY += gameState.jumpVelocity * deltaTime;
                gameState.jumpVelocity -= GRAVITY * deltaTime;
                
                if (gameState.playerY <= 0) {
                    gameState.playerY = 0;
                    gameState.jumping = false;
                    gameState.jumpVelocity = 0;
                }
            }
            
            // Duck handling
            if (gameState.ducking) {
                player.scale.y = 0.5;
                player.position.y = 0.375;
            } else {
                player.scale.y = 1;
                player.position.y = gameState.playerY + 0.75;
            }
            
            // Reset ducking when key released
            if (!event || event.type !== 'keydown') {
                gameState.ducking = false;
            }
            
            // Move track
            for (let segment of track) {
                segment.position.z += gameState.speed;
                if (segment.position.z > 10) {
                    segment.position.z -= 1000;
                }
            }
            
            // Move and spawn obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].position.z += gameState.speed;
                if (obstacles[i].position.z > 10) {
                    scene.remove(obstacles[i]);
                    obstacles.splice(i, 1);
                }
            }
            
            // Move kiwis
            for (let i = kiwis.length - 1; i >= 0; i--) {
                kiwis[i].mesh.position.z += gameState.speed;
                kiwis[i].z = kiwis[i].mesh.position.z;
                if (kiwis[i].z > 10) {
                    scene.remove(kiwis[i].mesh);
                    kiwis.splice(i, 1);
                }
            }
            
            // Move broccolis
            for (let i = broccolis.length - 1; i >= 0; i--) {
                broccolis[i].mesh.position.z += gameState.speed;
                broccolis[i].z = broccolis[i].mesh.position.z;
                if (broccolis[i].z > 10) {
                    scene.remove(broccolis[i].mesh);
                    broccolis.splice(i, 1);
                }
            }
            
            // Spawn new obstacles
            if (Math.random() < 0.02) {
                const types = ['lowbarrier', 'highbarrier', 'spikes'];
                const type = types[Math.floor(Math.random() * types.length)];
                const lane = Math.floor(Math.random() * 3);
                createObstacle(type, lane, -50);
            }
            
            // TODO: Spawn collectibles
            if (Math.random() < 0.03) {
                const lane = Math.floor(Math.random() * 3);
                if (Math.random() < 0.85) {
                    createKiwi(lane, -50);
                } else {
                    createBroccoli(lane, -50);
                }
            }
            
            // Check collisions
            checkCollisions();
            
            // Increase speed gradually
            gameState.speed = Math.min(gameState.speed + 0.00001, 0.35);
        }
        
        function gameOver() {
            gameState.running = false;
            document.getElementById('menu').style.display = 'block';
            document.getElementById('menu').innerHTML = `
                <h1>Game Over!</h1>
                <p>Score: ${gameState.score}</p>
                <p>Kiwis: ${gameState.kiwisCollected}/30</p>
                <p>Broccolis: ${gameState.broccolisCollected}/7</p>
                <button onclick="startGame()">Play Again</button>
            `;
        }
        
        function startGame() {
            // Reset game state
            gameState = {
                running: true,
                score: 0,
                kiwisCollected: 0,
                broccolisCollected: 0,
                speed: 0.12,
                baseSpeed: 0.12,
                playerLane: 1,
                playerY: 0,
                jumping: false,
                ducking: false,
                jumpVelocity: 0
            };
            
            // Clear obstacles
            for (let obstacle of obstacles) {
                scene.remove(obstacle);
            }
            obstacles = [];
            
            // Clear collectibles
            for (let kiwi of kiwis) {
                scene.remove(kiwi.mesh);
            }
            for (let broccoli of broccolis) {
                scene.remove(broccoli.mesh);
            }
            kiwis = [];
            broccolis = [];
            collectibles = { kiwis: [], broccolis: [] };
            
            // Reset UI
            document.getElementById('score').textContent = '0';
            document.getElementById('kiwis').textContent = '0';
            document.getElementById('broccolis').textContent = '0';
            document.getElementById('menu').style.display = 'none';
            
            // Start game loop
            animate();
        }
        
        function animate() {
            if (!gameState.running) return;
            
            requestAnimationFrame(animate);
            
            const deltaTime = 0.016; // ~60fps
            updateGame(deltaTime);
            
            renderer.render(scene, camera);
        }
        
        function handleResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>