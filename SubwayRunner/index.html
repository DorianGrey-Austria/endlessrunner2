<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subway Runner 3D - Challenge</title>
    <!-- BUGFIX: CSP headers to allow MediaPipe and other external resources -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdn.jsdelivr.net https://storage.googleapis.com; connect-src 'self' https://umvrurelsxpxmyzcvrcd.supabase.co https://storage.googleapis.com; worker-src 'self' blob:; img-src 'self' data: blob:; media-src 'self' blob:;">
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <!-- MediaPipe CDN for Gesture Control -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"></script>
    
    <!-- ==================== LEVEL SYSTEM SCRIPTS ==================== -->
    <!-- Load level system components in order -->
    <script src="LevelBase.js"></script>
    <script src="LevelManagerPro.js"></script>
    <script src="Level1_Subway.js"></script>
    <script src="Level2_Cyberpunk.js"></script>
    <script src="Level3_Space.js"></script>
    <script src="Level4_Jungle.js"></script>
    <script src="Level5_Ice.js"></script>
    <script src="Level6_Underwater.js"></script>
    <script src="Level7_Desert.js"></script>
    <script src="Level8_Forest.js"></script>
    <script src="Level9_Volcano.js"></script>
    <script src="Level10_Crystal.js"></script>
    <!-- ==================== END LEVEL SYSTEM SCRIPTS ==================== -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            max-width: 133.33vh; /* 4:3 aspect ratio */
            max-height: 75vw;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #versionInfo {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #FFD700;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 999;
            background: rgba(0,0,0,0.8);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,215,0,0.5);
            font-family: monospace;
            line-height: 1.2;
        }
        
        /* Live Debug Console Styles */
        #debugToggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 68, 68, 0.9);
            color: white;
            border: 2px solid #ff4444;
            border-radius: 6px;
            padding: 8px 12px;
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(255, 68, 68, 0.3);
            transition: all 0.3s ease;
        }
        
        #debugToggle:hover {
            background: rgba(255, 68, 68, 1);
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.5);
        }
        
        #debugToggle.active {
            background: rgba(68, 255, 68, 0.9);
            border-color: #44ff44;
            box-shadow: 0 2px 10px rgba(68, 255, 68, 0.3);
        }
        
        #liveDebugConsole {
            font-family: 'Courier New', monospace !important;
            border: 2px solid #ff4444 !important;
            border-radius: 8px !important;
            backdrop-filter: blur(10px);
        }
        
        #liveDebugConsole.dragging {
            transform: scale(0.98);
            box-shadow: 0 8px 25px rgba(255, 68, 68, 0.4) !important;
        }
        
        /* Visual Enhancement Styles */
        .speed-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 50;
        }
        
        .speed-line {
            position: absolute;
            width: 2px;
            height: 100px;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0.6), rgba(255,255,255,0));
            animation: speedLineMove 0.3s linear;
        }
        
        @keyframes speedLineMove {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            to {
                transform: translateY(100vh);
                opacity: 0;
            }
        }
        
        .vignette-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%);
            z-index: 60;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .vignette-overlay.active {
            opacity: 1;
        }
        
        /* ENHANCED: Magnet Visual Effect - Blue/Magnetic Vignette */
        .magnet-vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 30%, rgba(30, 144, 255, 0.3) 70%, rgba(0, 100, 200, 0.5) 100%);
            box-shadow: inset 0 0 100px rgba(30, 144, 255, 0.3);
            z-index: 61;
            opacity: 0;
            transition: opacity 0.5s;
            animation: magnetPulse 2s ease-in-out infinite;
        }

        @keyframes magnetPulse {
            0%, 100% { 
                filter: brightness(1) hue-rotate(0deg);
                box-shadow: inset 0 0 100px rgba(30, 144, 255, 0.3);
            }
            50% { 
                filter: brightness(1.2) hue-rotate(10deg);
                box-shadow: inset 0 0 120px rgba(30, 144, 255, 0.5);
            }
        }

        .magnet-vignette.active {
            opacity: 1;
        }
        
        /* UI Element Animations */
        .ui-glow {
            animation: uiGlow 2s ease-in-out infinite;
        }
        
        @keyframes uiGlow {
            0%, 100% {
                filter: drop-shadow(0 0 5px rgba(255,215,0,0.5));
            }
            50% {
                filter: drop-shadow(0 0 15px rgba(255,215,0,0.8));
            }
        }
        
        .ui-bounce {
            animation: uiBounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes uiBounce {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }
        
        /* Motion Blur Effect */
        .motion-blur {
            filter: blur(0px);
            transition: filter 0.2s;
        }
        
        .motion-blur.active {
            filter: blur(2px);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: right;
            z-index: 100;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        #menu h1 {
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        #menu button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #menu button:hover {
            background: #45a049;
        }
        
        #timer {
            font-size: 20px;
            margin-top: 5px;
        }
        
        .timer-warning {
            color: #FF4444 !important;
            animation: pulse 0.5s infinite;
        }
        
        .timer-critical {
            color: #FF0000 !important;
            animation: fastPulse 0.2s infinite;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes fastPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-20px); }
            60% { transform: translateY(-10px); }
        }
        
        /* Near Miss and Milestone displays positioning */
        #nearMissDisplay {
            position: absolute;
            top: 150px;
            right: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: pulse 0.5s ease-in-out;
        }
        
        #milestoneDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
        }
        
        #multiplierDisplay {
            opacity: 0.8;
        }
        
        .name-input-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 16px;
            z-index: 300;
            text-align: center;
            min-width: 350px;
            border: 2px solid #4CAF50;
        }
        
        .name-input-dialog input {
            width: 200px;
            padding: 10px;
            margin: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }
        
        .name-input-dialog button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .name-input-dialog button:hover {
            background: #45a049;
        }
        
        .name-input-dialog button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .highscore-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            min-width: 200px;
            font-size: 12px;
        }
        
        .highscore-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .highscore-entry.current-player {
            color: #4CAF50;
            font-weight: bold;
        }
        
        /* Gesture Control UI */
        #gestureControls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 200;
        }
        
        #gestureToggle {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #gestureToggle:hover {
            background: #00cc70;
            transform: translateY(-2px);
        }
        
        #gestureToggle.active {
            background: #ff4444;
            color: white;
        }
        
        #calibrateBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #calibrateBtn:hover {
            background: #45a049;
        }
        
        #calibrateBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #gestureStatus {
            color: #00ff88;
            font-weight: bold;
        }
        
        /* Video preview for gesture control */
        #gestureCanvas {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #00ff88;
            border-radius: 8px;
            background: #000;
            z-index: 150;
            display: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        #gestureCanvas.active {
            display: block;
        }
        
        /* Gesture indicator */
        .gesture-feedback {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 250;
        }
        
        .gesture-feedback.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Version Info Display -->
        <div id="versionInfo">
            🚀 V7.6.0-GAME-RULES-SYSTEM<br>
            📅 10.07.2025
        </div>
        
        <!-- Debug Console Toggle -->
        <div id="debugToggle" onclick="window.errorTracker?.toggle()" title="Live Error Console (Ctrl+E)">
            🚨 DEBUG
        </div>
        
        <!-- Level Test Toggle -->
        <div id="levelTestToggle" onclick="document.getElementById('levelTestPanel').style.display='block'" title="Level Testing Panel" style="
            position: fixed;
            top: 20px;
            right: 120px;
            background: rgba(0, 255, 0, 0.9);
            color: black;
            border: 2px solid #00ff00;
            border-radius: 6px;
            padding: 8px 12px;
            font-family: monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10001;
        ">
            🎮 LEVELS
        </div>
        
        <!-- 🎮 LEVEL TESTING PANEL -->
        <div id="levelTestPanel" style="
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #00ff00;
            z-index: 10000;
            display: none;
        ">
            <div style="font-weight: bold; margin-bottom: 8px;">🎮 LEVEL TESTING</div>
            <button onclick="testLevel(1)" style="margin: 2px; padding: 4px 8px; background: #006600; color: white; border: none; border-radius: 3px; cursor: pointer;">L1 Subway</button><br>
            <button onclick="testLevel(2)" style="margin: 2px; padding: 4px 8px; background: #0066cc; color: white; border: none; border-radius: 3px; cursor: pointer;">L2 Cyberpunk</button><br>
            <button onclick="testLevel(3)" style="margin: 2px; padding: 4px 8px; background: #cc0066; color: white; border: none; border-radius: 3px; cursor: pointer;">L3 Space</button><br>
            <button onclick="testLevel(4)" style="margin: 2px; padding: 4px 8px; background: #cc6600; color: white; border: none; border-radius: 3px; cursor: pointer;">L4 Jungle</button><br>
            <button onclick="testLevel(5)" style="margin: 2px; padding: 4px 8px; background: #0099cc; color: white; border: none; border-radius: 3px; cursor: pointer;">L5 Ice</button><br>
            <button onclick="testLevel(6)" style="margin: 2px; padding: 4px 8px; background: #0066aa; color: white; border: none; border-radius: 3px; cursor: pointer;">L6 Ocean</button><br>
            <button onclick="testLevel(7)" style="margin: 2px; padding: 4px 8px; background: #cc9900; color: white; border: none; border-radius: 3px; cursor: pointer;">L7 Desert</button><br>
            <button onclick="testLevel(8)" style="margin: 2px; padding: 4px 8px; background: #009900; color: white; border: none; border-radius: 3px; cursor: pointer;">L8 Forest</button><br>
            <button onclick="testLevel(9)" style="margin: 2px; padding: 4px 8px; background: #cc3300; color: white; border: none; border-radius: 3px; cursor: pointer;">L9 Volcano</button><br>
            <button onclick="testLevel(10)" style="margin: 2px; padding: 4px 8px; background: #9900cc; color: white; border: none; border-radius: 3px; cursor: pointer;">L10 Crystal</button><br>
            <hr style="margin: 8px 0; border: 1px solid #00ff00;">
            <button onclick="importLineDrawing()" style="margin: 2px; padding: 4px 8px; background: #ff6600; color: white; border: none; border-radius: 3px; cursor: pointer;">🎨 Import Strichzeichnung</button><br>
            <button onclick="document.getElementById('levelTestPanel').style.display='none'" style="margin: 2px; padding: 4px 8px; background: #cc0000; color: white; border: none; border-radius: 3px; cursor: pointer;">Close</button>
        </div>
        
        <!-- Visual Effects Overlays -->
        <div id="speedLines" class="speed-lines"></div>
        <div id="vignetteOverlay" class="vignette-overlay"></div>
        <div id="magnetVignette" class="magnet-vignette"></div>
        
        <!-- Gesture Control UI -->
        <div id="gestureControls">
            <button id="gestureToggle" onclick="toggleGestureControl()">🎥 Gesten aktivieren</button>
            <button id="calibrateBtn" onclick="calibrateGestures()" disabled>🎯 Kalibrieren</button>
            <span id="gestureStatus">Gesten: Inaktiv</span>
        </div>
        
        <!-- Gesture Feedback -->
        <div class="gesture-feedback" id="gestureFeedback"></div>
        
        <!-- Hidden video element for camera -->
        <video id="gestureVideo" style="display: none;" autoplay playsinline></video>
        
        <!-- Canvas for gesture preview -->
        <canvas id="gestureCanvas"></canvas>
        
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Speed: <span id="speed">100</span></div>
            <div>❤️ Leben: <span id="lives">3</span></div>
            <div id="timer">⏱️ Zeit: <span id="timeRemaining">60</span>s</div>
            
            <!-- NEW: Power-Up & Coins UI -->
            <div id="collectiblesCounter" style="color: #8BC34A; font-weight: bold;">
                🥝 <span id="kiwiCount">0</span>/30 | 🥦 <span id="broccoliCount">0</span>/7
                <div style="font-size: 12px; margin-top: 2px;">
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; width: 60px; height: 8px; overflow: hidden;">
                            <div id="kiwiProgress" style="background: #FFD700; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; width: 40px; height: 8px; overflow: hidden;">
                            <div id="broccoliProgress" style="background: #8BC34A; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="comboDisplay" style="color: #FF6B35; display: none; font-size: 20px; animation: pulse 0.5s infinite;">
                COMBO x<span id="comboMultiplier">1</span>!
            </div>
            
            <!-- NEW: Near Miss Display -->
            <div id="nearMissDisplay" style="color: #FFD700; display: none; font-size: 18px; font-weight: bold;">
                NEAR MISS! x<span id="nearMissCount">1</span>
                <div style="font-size: 14px;">+<span id="nearMissBonus">50</span> Bonus!</div>
            </div>
            
            <!-- NEW: Milestone Display -->
            <div id="milestoneDisplay" style="color: #00FF00; display: none; font-size: 24px; font-weight: bold; animation: bounce 1s;">
                <span id="milestoneIcon">🏁</span> <span id="milestoneText">500m!</span>
                <div style="font-size: 16px;">+<span id="milestoneBonus">500</span> Punkte!</div>
            </div>
            
            <!-- NEW: Score Multiplier Display -->
            <div id="multiplierDisplay" style="color: #FF1493; font-size: 16px; font-weight: bold; margin-top: 5px;">
                Multiplikator: x<span id="currentMultiplier">1.0</span>
            </div>
            <div id="powerUpDisplay" style="color: #4ECDC4; display: none; font-weight: bold;">
                <span id="powerUpIcon">⚡</span> <span id="powerUpName">Speed</span>: <span id="powerUpTime">8</span>s
            </div>
            
            <!-- NEW: Skill Combo UI -->
            <div id="skillComboDisplay" style="color: #FF4500; display: none; font-size: 22px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                <span id="skillComboIcon">🔥</span> SKILL COMBO x<span id="skillComboCount">1</span>! 
                <div style="font-size: 14px; color: #FFD700;"><span id="skillComboBonus">+100</span> Punkte!</div>
            </div>
            
            <!-- NEW: Environment Display -->
            <div id="environmentDisplay" style="color: #87CEEB; font-weight: bold; margin-top: 10px;">
                🏙️ <span id="currentEnvironment">Straße</span>
            </div>
            
            <!-- NEW: Difficulty Progress Display -->
            <div id="difficultyDisplay" style="color: #FFB347; font-weight: bold; margin-top: 5px; font-size: 14px;">
                📈 Schwierigkeit: <span id="difficultyLevel">Leicht</span>
            </div>
        </div>
        
        <div id="instructions">
            <div><strong>🎮 Steuerung:</strong></div>
            <div>A/D: Spurwechsel</div>
            <div>Leertaste/W: Springen 🦘</div>
            <div>S: Ducken 🦆</div>
            <div><strong>📱 Touch-Steuerung:</strong></div>
            <div>← → Wischen: Spurwechsel</div>
            <div>↑ Wischen: Springen</div>
            <div>↓ Wischen: Ducken</div>
            <div><strong>💡 Tipps:</strong></div>
            <div>🟠 Orange/Braun: Überspringen!</div>
            <div>🔵 Blau/Grau oben: Ducken!</div>
            <div>🔴 Stacheln: Beides möglich!</div>
            <div><strong>🎯 Neue Features:</strong></div>
            <div>⚡ Near-Miss Bonus!</div>
            <div>🏁 Meilenstein-Belohnungen!</div>
            <div>🔥 Combo-Multiplikator!</div>
        </div>
        
        <div id="menu">
            <h1>🚇 Subway Runner 3D</h1>
            <h2>⏱️ 60-Sekunden Challenge!</h2>
            <p>Überlebe 60 Sekunden bei stetig steigender Geschwindigkeit!</p>
            <p><strong>🎯 Ziel:</strong> 60 Sekunden überleben</p>
            <p><strong>⚡ Warnung:</strong> Wird sehr schnell!</p>
            <p><strong>🎮 Steuerung:</strong></p>
            <p>A/D: Spurwechsel | W/Space: Springen | S: Ducken</p>
            <button onclick="startGame()">🎮 Challenge starten!</button>
        </div>
        
        <div id="highscorePanel" class="highscore-panel">
            <div style="font-weight: bold; margin-bottom: 10px;">🏆 TOP 10</div>
            <div id="highscoreList">Lade Bestenliste...</div>
        </div>
        
        <div id="nameInputDialog" class="name-input-dialog" style="display: none;">
            <h2>🎉 Neuer Highscore!</h2>
            <p>Gib deinen Namen ein:</p>
            <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="20">
            <br>
            <button onclick="submitHighscore()">💾 Speichern</button>
            <button onclick="skipHighscore()">⏭️ Überspringen</button>
        </div>
    </div>

    <script>
        // 🔧 BULLETPROOF MATERIAL FACTORY - Future-Proof 3D Engine Protection
        console.log('🛡️ [MaterialFactory] Initializing bulletproof material system...');
        
        /**
         * Universal Material Factory - Prevents ALL future shader crashes
         * Automatically includes fog, light, shadow, and common uniforms
         */
        function createUniversalMaterial(type, options = {}) {
            const { 
                color = 0xffffff, 
                opacity = 1.0,
                transparent = false,
                wireframe = false,
                side = THREE.FrontSide,
                customUniforms = {},
                vertexShader = null,
                fragmentShader = null
            } = options;

            console.log(`[MaterialFactory] Creating ${type} material with color:`, color);

            switch(type) {
                case 'basic':
                    return new THREE.MeshBasicMaterial({
                        color, opacity, transparent, wireframe, side
                    });
                
                case 'lambert':
                    return new THREE.MeshLambertMaterial({
                        color, opacity, transparent, wireframe, side
                    });
                
                case 'phong':
                    return new THREE.MeshPhongMaterial({
                        color, opacity, transparent, wireframe, side
                    });
                
                case 'shader':
                    // BULLETPROOF SHADER MATERIAL with ALL standard uniforms
                    console.log(`[MaterialFactory] Creating BULLETPROOF shader with fog/light support`);
                    return new THREE.ShaderMaterial({
                        uniforms: THREE.UniformsUtils.merge([
                            THREE.UniformsLib.common,     // Basic uniforms (diffuse, opacity, etc.)
                            THREE.UniformsLib.specularmap, // Specular mapping
                            THREE.UniformsLib.envmap,     // Environment mapping
                            THREE.UniformsLib.aomap,      // Ambient occlusion
                            THREE.UniformsLib.lightmap,   // Light mapping
                            THREE.UniformsLib.emissivemap, // Emissive mapping
                            THREE.UniformsLib.fog,        // FOG COMPATIBILITY ✅
                            THREE.UniformsLib.lights,     // LIGHT COMPATIBILITY ✅
                            THREE.UniformsLib.shadowmap,  // Shadow mapping
                            THREE.UniformsLib.clipping,   // Clipping planes
                            customUniforms               // Level-specific uniforms
                        ]),
                        vertexShader: vertexShader || `
                            void main() {
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: fragmentShader || `
                            uniform vec3 diffuse;
                            uniform float opacity;
                            void main() {
                                gl_FragColor = vec4(diffuse, opacity);
                            }
                        `,
                        fog: true,           // ✅ Enable fog support
                        lights: true,       // ✅ Enable light support
                        transparent: transparent,
                        side: side
                    });
                
                default:
                    console.warn(`[MaterialFactory] Unknown type: ${type}, falling back to MeshLambertMaterial`);
                    return new THREE.MeshLambertMaterial({ color, opacity, transparent, wireframe, side });
            }
        }

        /**
         * Quick material creation functions
         */
        function createSafeMaterial(color = 0xffffff, options = {}) {
            return createUniversalMaterial('lambert', { color, ...options });
        }

        function createSafeShader(customUniforms, vertexShader, fragmentShader, options = {}) {
            return createUniversalMaterial('shader', { 
                customUniforms, 
                vertexShader, 
                fragmentShader, 
                ...options 
            });
        }

        /**
         * Safe material replacement utility
         */
        function replaceMaterialSafely(object, newMaterialType = 'lambert', options = {}) {
            if (object.material) {
                const oldType = object.material.type;
                const newMaterial = createUniversalMaterial(newMaterialType, options);
                
                // Dispose old material to prevent memory leaks
                if (object.material.dispose) {
                    object.material.dispose();
                }
                
                object.material = newMaterial;
                console.log(`[MaterialFactory] Replaced ${oldType} with safe ${newMaterialType} material`);
            }
        }

        /**
         * Material audit tool - checks scene for problematic materials
         */
        function auditSceneMaterials(scene) {
            console.log('🔍 [MaterialAudit] Starting comprehensive material audit...');
            let totalMaterials = 0;
            let problematicMaterials = 0;
            let shaderMaterials = 0;
            
            scene.traverse(child => {
                if (child.material) {
                    totalMaterials++;
                    
                    if (child.material.type === 'ShaderMaterial') {
                        shaderMaterials++;
                        const hasFogUniforms = child.material.uniforms && child.material.uniforms.fogColor;
                        const hasLightUniforms = child.material.uniforms && child.material.uniforms.directionalLights;
                        
                        if (!hasFogUniforms || !hasLightUniforms) {
                            problematicMaterials++;
                            console.warn(`🚨 [MaterialAudit] Problematic ShaderMaterial found:`, {
                                name: child.name || 'unnamed',
                                type: child.material.type,
                                hasFogUniforms,
                                hasLightUniforms,
                                object: child
                            });
                        } else {
                            console.log(`✅ [MaterialAudit] Safe ShaderMaterial:`, child.name || 'unnamed');
                        }
                    }
                }
            });
            
            console.log(`📊 [MaterialAudit] Results:`, {
                totalMaterials,
                shaderMaterials,
                problematicMaterials,
                safePercentage: Math.round(((totalMaterials - problematicMaterials) / totalMaterials) * 100) + '%'
            });
            
            return { totalMaterials, shaderMaterials, problematicMaterials };
        }

        // Global debug flags
        const DEBUG = {
            DISABLE_FOG: false,           // Emergency fog disable switch
            MATERIAL_AUDIT: true,         // Enable material auditing
            SHADER_LOGGING: true,         // Log shader material creation
            PERFORMANCE_MONITOR: true     // Enable FPS monitoring
        };

        console.log('✅ [MaterialFactory] Bulletproof material system ready!');
        
        // ==================== LIVE ERROR TRACKING SYSTEM ====================
        
        /**
         * 🔧 AUTOMATIC ERROR CAPTURE & DISPLAY SYSTEM
         * Captures ALL errors, warnings, and logs for real-time debugging
         */
        class LiveErrorTracker {
            constructor() {
                this.errors = [];
                this.warnings = [];
                this.logs = [];
                this.maxEntries = 50;
                this.isVisible = false;
                this.problemPatterns = this.initializeProblemPatterns();
                this.performanceAlerts = [];
                this.memoryBaseline = 0;
                this.shaderHealthCheck = true;
                this.assetHealthStatus = new Map();
                this.setupErrorCapture();
                this.createErrorDisplay();
                this.initializeSmartMonitoring();
                
                console.log('🚨 [SmartDebug] Ultra-Intelligent Debug Console 2.0 activated!');
            }
            
            // 🧠 PUNKT 1: Problem Pattern Recognition
            initializeProblemPatterns() {
                return {
                    '3GS_SHADER': /Cannot read properties of undefined.*reading.*value|ShaderMaterial|refreshUniformsCommon/,
                    'SCORE_EXPLOSION': /score.*\+=|totalScore|scoreMultiplier/,
                    'MEMORY_LEAK': /dispose|material.*geometry|THREE\.Object3D/,
                    'SCOPE_ERROR': /is not defined|playerGroup|ReferenceError/,
                    'LEVEL_CRASH': /level.*load|LevelManager|transition/,
                    'PERFORMANCE_DROP': /FPS|render|triangles/,
                    'ASSET_404': /404|Failed to load|sound.*not found/,
                    'JUMP_PHYSICS': /playerY|jumpVelocity|position\.y/,
                    'SPEED_BALANCE': /speed.*too|gameSpeed|acceleration/,
                    'CSP_BLOCK': /Content Security Policy|CSP|unsafe/
                };
            }
            
            setupErrorCapture() {
                // Capture console.error
                const originalError = console.error;
                console.error = (...args) => {
                    this.addError('ERROR', args.join(' '));
                    originalError.apply(console, args);
                };
                
                // Capture console.warn
                const originalWarn = console.warn;
                console.warn = (...args) => {
                    this.addError('WARN', args.join(' '));
                    originalWarn.apply(console, args);
                };
                
                // Capture uncaught exceptions
                window.addEventListener('error', (event) => {
                    this.addError('UNCAUGHT', `${event.message} at ${event.filename}:${event.lineno}:${event.colno}`);
                });
                
                // Capture unhandled promise rejections
                window.addEventListener('unhandledrejection', (event) => {
                    this.addError('PROMISE', `Unhandled promise rejection: ${event.reason}`);
                });
                
                // Capture Three.js specific errors
                const originalThreeError = THREE.Object3D.prototype.dispatchEvent;
                if (originalThreeError) {
                    THREE.Object3D.prototype.dispatchEvent = function(event) {
                        if (event.type === 'error') {
                            window.errorTracker?.addError('THREE.JS', `Three.js error: ${event.message || 'Unknown error'}`);
                        }
                        return originalThreeError.call(this, event);
                    };
                }
            }
            
            addError(type, message) {
                const timestamp = new Date().toLocaleTimeString();
                const entry = {
                    type,
                    message,
                    timestamp,
                    id: Date.now() + Math.random()
                };
                
                // 🧠 PUNKT 2: Smart Problem Analysis
                const problemType = this.analyzeProblemPattern(message);
                if (problemType) {
                    entry.problemType = problemType;
                    this.handleKnownProblem(problemType, message);
                }
                
                this.errors.unshift(entry);
                if (this.errors.length > this.maxEntries) {
                    this.errors.pop();
                }
                
                this.updateDisplay();
                
                // Auto-show on errors (but not warnings)
                if (type === 'ERROR' || type === 'UNCAUGHT' || type === 'PROMISE') {
                    this.show();
                }
            }
            
            // 🧠 PUNKT 2 & 3: Problem Pattern Analysis + Smart Alerts
            analyzeProblemPattern(message) {
                for (const [pattern, regex] of Object.entries(this.problemPatterns)) {
                    if (regex.test(message)) {
                        return pattern;
                    }
                }
                return null;
            }
            
            handleKnownProblem(problemType, message) {
                const solutions = {
                    '3GS_SHADER': () => this.suggest3GSFix(),
                    'SCORE_EXPLOSION': () => this.suggestScoreFix(),
                    'MEMORY_LEAK': () => this.suggestMemoryFix(),
                    'SCOPE_ERROR': () => this.suggestScopeFix(),
                    'LEVEL_CRASH': () => this.suggestLevelFix(),
                    'PERFORMANCE_DROP': () => this.suggestPerformanceFix(),
                    'ASSET_404': () => this.suggestAssetFix(),
                    'JUMP_PHYSICS': () => this.suggestJumpFix(),
                    'SPEED_BALANCE': () => this.suggestSpeedFix(),
                    'CSP_BLOCK': () => this.suggestCSPFix()
                };
                
                const solution = solutions[problemType];
                if (solution) {
                    setTimeout(solution, 100); // Show after error is logged
                }
            }
            
            createErrorDisplay() {
                // Create floating error console
                const errorConsole = document.createElement('div');
                errorConsole.id = 'liveErrorConsole';
                errorConsole.innerHTML = `
                    <div id="errorHeader">
                        🧠 Smart Debug Console 2.0
                        <button id="toggleErrors" onclick="window.errorTracker.toggle()">Hide</button>
                        <button id="clearErrors" onclick="window.errorTracker.clear()">Clear</button>
                        <button id="copyErrors" onclick="window.errorTracker.copyErrors()">Copy</button>
                    </div>
                    <div id="alertsContent"></div>
                    <div id="metricsContent"></div>
                    <div id="quickFixContent"></div>
                    <div id="errorContent"></div>
                `;
                
                // Styling
                errorConsole.style.cssText = `
                    position: fixed;
                    bottom: 60px;
                    right: 20px;
                    width: 400px;
                    max-height: 300px;
                    background: rgba(0, 0, 0, 0.95);
                    border: 2px solid #ff4444;
                    border-radius: 8px;
                    font-family: 'Courier New', monospace;
                    font-size: 12px;
                    z-index: 9999;
                    display: none;
                    box-shadow: 0 4px 20px rgba(255, 68, 68, 0.3);
                `;
                
                document.body.appendChild(errorConsole);
                
                // Style the header
                const header = document.getElementById('errorHeader');
                header.style.cssText = `
                    background: #ff4444;
                    color: white;
                    padding: 8px;
                    font-weight: bold;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                `;
                
                // Style the alerts area
                const alertsContent = document.getElementById('alertsContent');
                alertsContent.style.cssText = `
                    background: rgba(255, 165, 0, 0.2);
                    border: 1px solid #ffa500;
                    margin: 4px;
                    padding: 6px;
                    font-size: 10px;
                    color: #ffa500;
                    border-radius: 3px;
                    display: none;
                `;
                
                // Style the metrics area
                const metricsContent = document.getElementById('metricsContent');
                metricsContent.style.cssText = `
                    background: rgba(0, 100, 0, 0.2);
                    border: 1px solid #00ff00;
                    margin: 4px;
                    padding: 6px;
                    font-size: 10px;
                    color: #00ff00;
                    border-radius: 3px;
                `;
                
                // Style the quick fix area
                const quickFixContent = document.getElementById('quickFixContent');
                quickFixContent.style.cssText = `
                    background: rgba(0, 150, 255, 0.2);
                    border: 1px solid #0096ff;
                    margin: 4px;
                    padding: 6px;
                    font-size: 10px;
                    color: #0096ff;
                    border-radius: 3px;
                    display: none;
                `;
                
                // Style the content area
                const content = document.getElementById('errorContent');
                content.style.cssText = `
                    max-height: 200px;
                    overflow-y: auto;
                    padding: 8px;
                    color: #fff;
                `;
                
                // Style buttons
                const buttons = header.querySelectorAll('button');
                buttons.forEach(button => {
                    button.style.cssText = `
                        background: rgba(255, 255, 255, 0.2);
                        border: 1px solid rgba(255, 255, 255, 0.3);
                        color: white;
                        padding: 4px 8px;
                        border-radius: 4px;
                        cursor: pointer;
                        margin-left: 5px;
                        font-size: 10px;
                    `;
                    
                    button.addEventListener('mouseenter', () => {
                        button.style.background = 'rgba(255, 255, 255, 0.3)';
                    });
                    
                    button.addEventListener('mouseleave', () => {
                        button.style.background = 'rgba(255, 255, 255, 0.2)';
                    });
                });
                
                this.errorDisplay = errorConsole;
                
                // Start live metrics monitoring
                this.startMetricsMonitoring();
            }
            
            // 🧠 PUNKT 4: Smart Monitoring Initialization
            initializeSmartMonitoring() {
                // Initialize baseline measurements
                this.memoryBaseline = performance.memory?.usedJSHeapSize || 0;
                
                // Start proactive monitoring
                setInterval(() => this.proactiveHealthCheck(), 1000);
                setInterval(() => this.memoryLeakDetection(), 5000);
                setInterval(() => this.performanceProfiler(), 2000);
                setInterval(() => this.assetHealthMonitor(), 3000);
                
                console.log('🧠 [SmartDebug] Proactive monitoring systems activated');
            }
            
            // 🧠 PUNKT 5: Proactive Health Checks
            proactiveHealthCheck() {
                // Check for potential 3GS issues
                if (window.scene) {
                    let shaderMaterialCount = 0;
                    window.scene.traverse(child => {
                        if (child.material && child.material.type === 'ShaderMaterial') {
                            shaderMaterialCount++;
                            if (!child.material.fog) {
                                this.showAlert('SHADER_WARNING', 'ShaderMaterial without fog support detected - potential 3GS risk!');
                            }
                        }
                    });
                }
                
                // Check variable scope issues
                if (typeof playerGroup !== 'undefined' && window.validatePlayerGroundPosition) {
                    this.showAlert('SCOPE_WARNING', 'playerGroup variable may cause scope conflicts');
                }
                
                // Check score explosion patterns
                if (window.gameState?.score > 1000000) {
                    this.showAlert('SCORE_WARNING', 'Score explosion detected - check score throttling');
                }
            }
            
            // 🧠 PUNKT 6: Memory Leak Detection
            memoryLeakDetection() {
                if (!performance.memory) return;
                
                const currentMemory = performance.memory.usedJSHeapSize;
                const memoryIncrease = currentMemory - this.memoryBaseline;
                
                if (memoryIncrease > 50 * 1024 * 1024) { // 50MB increase
                    this.showAlert('MEMORY_LEAK', `Memory increased by ${this.formatBytes(memoryIncrease)} - potential leak detected`);
                    this.suggestMemoryFix();
                }
            }
            
            // 🧠 PUNKT 7: Performance Profiler
            performanceProfiler() {
                const fps = this.currentFPS || 60;
                const threejsInfo = window.renderer?.info;
                
                if (fps < 30) {
                    this.showAlert('PERFORMANCE_CRITICAL', `Critical FPS drop: ${fps} FPS - performance issues detected`);
                    this.suggestPerformanceFix();
                }
                
                if (threejsInfo?.render.triangles > 100000) {
                    this.showAlert('TRIANGLES_HIGH', `High triangle count: ${threejsInfo.render.triangles} - optimize geometry`);
                }
            }
            
            // 🧠 PUNKT 8: Asset Health Monitor
            assetHealthMonitor() {
                // Monitor for 404 errors and asset loading failures
                if (window.audioManager?.loadingErrors?.length > 0) {
                    this.showAlert('ASSET_ERRORS', `${window.audioManager.loadingErrors.length} audio assets failed to load`);
                }
            }
            
            // 🧠 PUNKT 9: Smart Alerts System
            showAlert(type, message) {
                const alertsDiv = document.getElementById('alertsContent');
                if (!alertsDiv) return;
                
                alertsDiv.style.display = 'block';
                alertsDiv.innerHTML = `⚠️ ${type}: ${message}<br>` + alertsDiv.innerHTML;
                
                // Auto-hide after 10 seconds
                setTimeout(() => {
                    if (alertsDiv.innerHTML.includes(message)) {
                        alertsDiv.innerHTML = alertsDiv.innerHTML.replace(`⚠️ ${type}: ${message}<br>`, '');
                        if (alertsDiv.innerHTML.trim() === '') {
                            alertsDiv.style.display = 'none';
                        }
                    }
                }, 10000);
            }
            
            startMetricsMonitoring() {
                // Update metrics every 500ms
                setInterval(() => {
                    this.updateMetrics();
                }, 500);
            }
            
            updateMetrics() {
                const metricsDiv = document.getElementById('metricsContent');
                if (!metricsDiv || !this.isVisible) return;
                
                // Collect performance metrics
                const memInfo = performance.memory || {};
                const fps = this.calculateFPS();
                const threejsInfo = window.renderer ? window.renderer.info : null;
                
                metricsDiv.innerHTML = `
                    📊 LIVE METRICS:<br>
                    🖥️ FPS: ${fps} | Memory: ${this.formatBytes(memInfo.usedJSHeapSize || 0)}<br>
                    🎮 Player: Y=${window.gameState?.playerY?.toFixed(2) || 'N/A'} | Speed: ${window.gameState?.speed?.toFixed(2) || 'N/A'}<br>
                    🎯 Score: ${window.gameState?.score || 0} | Level: ${window.gameState?.currentLevel || 1}<br>
                    ${threejsInfo ? `🔺 Three.js: ${threejsInfo.render.triangles} triangles | ${threejsInfo.memory.geometries} geo` : ''}
                `;
            }
            
            calculateFPS() {
                if (!this.fpsCounter) {
                    this.fpsCounter = { frames: 0, lastTime: performance.now() };
                }
                
                this.fpsCounter.frames++;
                const now = performance.now();
                
                if (now - this.fpsCounter.lastTime >= 1000) {
                    const fps = Math.round(this.fpsCounter.frames * 1000 / (now - this.fpsCounter.lastTime));
                    this.fpsCounter.frames = 0;
                    this.fpsCounter.lastTime = now;
                    this.currentFPS = fps;
                }
                
                return this.currentFPS || 60;
            }
            
            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
            }
            
            // 🧠 PUNKT 10: Quick-Fix Suggestions (Based on TROUBLESHOOTING.md patterns)
            suggest3GSFix() {
                this.showQuickFix('3GS_SHADER', '🔧 3GS Shader Fix', [
                    'Replace ShaderMaterial with MeshBasicMaterial',
                    'Add THREE.UniformsLib.fog to shader uniforms',
                    'Set material.fog = true on all custom shaders',
                    'Use Material Factory for fog-compatible shaders'
                ], () => this.auto3GSFix());
            }
            
            suggestScoreFix() {
                this.showQuickFix('SCORE_EXPLOSION', '🎯 Score Explosion Fix', [
                    'Centralize score updates through addScore() function',
                    'Throttle score updates to max 100 points per 100ms',
                    'Replace all gameState.score += with addScore()',
                    'Check for unthrottled bonus systems'
                ], () => this.autoScoreFix());
            }
            
            suggestMemoryFix() {
                this.showQuickFix('MEMORY_LEAK', '🧹 Memory Leak Fix', [
                    'Force garbage collection: window.gc?.()',
                    'Dispose unused materials and geometries',
                    'Check for undisposed Three.js objects',
                    'Clear orphaned shader materials'
                ], () => this.autoMemoryFix());
            }
            
            suggestScopeFix() {
                this.showQuickFix('SCOPE_ERROR', '🔍 Variable Scope Fix', [
                    'Use global player variable instead of playerGroup',
                    'Declare variables in global scope if needed',
                    'Check for undefined variable references',
                    'Add null checks before variable access'
                ], () => this.autoScopeFix());
            }
            
            suggestLevelFix() {
                this.showQuickFix('LEVEL_CRASH', '🎮 Level Loading Fix', [
                    'Dispose previous level materials before loading new level',
                    'Use LevelManagerPro for safe level transitions',
                    'Check level registration in LevelManagerPro',
                    'Verify level class extends LevelBase correctly'
                ], () => this.autoLevelFix());
            }
            
            suggestPerformanceFix() {
                this.showQuickFix('PERFORMANCE_DROP', '⚡ Performance Fix', [
                    'Reduce triangle count in complex models',
                    'Use object pooling for frequently created objects',
                    'Enable frustum culling for off-screen objects',
                    'Lower render quality or disable shadows'
                ], () => this.autoPerformanceFix());
            }
            
            suggestAssetFix() {
                this.showQuickFix('ASSET_404', '📁 Asset Loading Fix', [
                    'Check asset paths in sounds/ directory',
                    'Implement graceful fallback for missing assets',
                    'Use audioManager.playSpeedDependentSound() safely',
                    'Add asset existence validation before loading'
                ], () => this.autoAssetFix());
            }
            
            suggestJumpFix() {
                this.showQuickFix('JUMP_PHYSICS', '🦘 Jump Physics Fix', [
                    'Force player.position.y = 0 when grounded',
                    'Add validatePlayerGroundPosition() validation',
                    'Reset jumpVelocity to 0 on landing',
                    'Check for floating point precision errors'
                ], () => this.autoJumpFix());
            }
            
            suggestSpeedFix() {
                this.showQuickFix('SPEED_BALANCE', '🏃 Speed Balance Fix', [
                    'Reduce baseSpeed to 0.05 (currently too fast)',
                    'Lower maxSpeed to 0.25 (currently too high)',
                    'Use gentler acceleration curve',
                    'Add speed scaling based on difficulty'
                ], () => this.autoSpeedFix());
            }
            
            suggestCSPFix() {
                this.showQuickFix('CSP_BLOCK', '🔒 CSP Security Fix', [
                    'Add missing domains to Content-Security-Policy',
                    'Include https://cdn.jsdelivr.net for MediaPipe',
                    'Add font-src directive for Google Fonts',
                    'Use unsafe-inline cautiously for development'
                ], () => this.autoCSPFix());
            }
            
            showQuickFix(type, title, suggestions, autoFixCallback) {
                const quickFixDiv = document.getElementById('quickFixContent');
                if (!quickFixDiv) return;
                
                quickFixDiv.style.display = 'block';
                
                const suggestionsHTML = suggestions.map(s => `• ${s}`).join('<br>');
                const autoFixButton = autoFixCallback ? 
                    `<button onclick="window.errorTracker.${autoFixCallback.name}()" style="background: #0096ff; color: white; border: none; padding: 2px 6px; border-radius: 3px; cursor: pointer; margin-top: 4px;">Auto-Fix</button>` : '';
                
                quickFixDiv.innerHTML = `
                    <strong>${title}:</strong><br>
                    ${suggestionsHTML}
                    ${autoFixButton}
                    <hr style="margin: 8px 0; border: 1px solid #0096ff;">
                ` + quickFixDiv.innerHTML;
            }
            
            // Auto-Fix Methods (Conservative implementations)
            auto3GSFix() {
                console.log('🔧 [Auto-Fix] Applying 3GS prevention measures...');
                if (window.scene) {
                    window.scene.traverse(child => {
                        if (child.material && child.material.type === 'ShaderMaterial' && !child.material.fog) {
                            console.warn('Found problematic ShaderMaterial, consider replacing with MeshBasicMaterial');
                        }
                    });
                }
            }
            
            autoMemoryFix() {
                console.log('🧹 [Auto-Fix] Performing memory cleanup...');
                if (window.gc) window.gc(); // Force garbage collection if available
                
                // Conservative memory cleanup
                if (window.renderer) {
                    console.log('Renderer info:', window.renderer.info);
                }
            }
            
            autoJumpFix() {
                console.log('🦘 [Auto-Fix] Validating jump physics...');
                if (window.gameState && window.player && window.gameState.playerAction !== 'jumping') {
                    if (Math.abs(window.gameState.playerY) > 0.01) {
                        window.gameState.playerY = 0;
                        window.player.position.y = 0;
                        console.log('✅ Player position corrected to ground level');
                    }
                }
            }
            
            updateDisplay() {
                const content = document.getElementById('errorContent');
                if (!content) return;
                
                content.innerHTML = this.errors.map(entry => {
                    const colorMap = {
                        'ERROR': '#ff4444',
                        'WARN': '#ffaa00',
                        'UNCAUGHT': '#ff0000',
                        'PROMISE': '#ff6666',
                        'THREE.JS': '#4444ff'
                    };
                    
                    const color = colorMap[entry.type] || '#ffffff';
                    
                    return `
                        <div style="
                            margin-bottom: 8px; 
                            padding: 4px; 
                            border-left: 3px solid ${color};
                            background: rgba(255, 255, 255, 0.05);
                            border-radius: 3px;
                        ">
                            <div style="
                                font-size: 10px; 
                                color: ${color}; 
                                font-weight: bold;
                                margin-bottom: 2px;
                            ">
                                [${entry.timestamp}] ${entry.type}
                            </div>
                            <div style="color: #fff; word-break: break-word;">
                                ${entry.message}
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Auto-scroll to top for newest errors
                content.scrollTop = 0;
                
                // Update error counter in header
                const header = document.getElementById('errorHeader');
                if (header) {
                    const errorCount = this.errors.filter(e => e.type === 'ERROR' || e.type === 'UNCAUGHT' || e.type === 'PROMISE').length;
                    const warnCount = this.errors.filter(e => e.type === 'WARN').length;
                    header.firstChild.textContent = `🚨 Live Console (${errorCount} errors, ${warnCount} warnings)`;
                }
            }
            
            show() {
                this.isVisible = true;
                this.errorDisplay.style.display = 'block';
                document.getElementById('toggleErrors').textContent = 'Hide';
            }
            
            hide() {
                this.isVisible = false;
                this.errorDisplay.style.display = 'none';
                document.getElementById('toggleErrors').textContent = 'Show';
            }
            
            toggle() {
                if (this.isVisible) {
                    this.hide();
                } else {
                    this.show();
                }
            }
            
            clear() {
                this.errors = [];
                this.warnings = [];
                this.logs = [];
                this.updateDisplay();
            }
            
            // Copy errors to clipboard
            copyErrors() {
                const errorText = this.errors.map(entry => 
                    `[${entry.timestamp}] ${entry.type}: ${entry.message}`
                ).join('\n');
                
                if (errorText.trim() === '') {
                    alert('No errors to copy!');
                    return;
                }
                
                // Try modern clipboard API first
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(errorText).then(() => {
                        alert('Errors copied to clipboard!');
                    }).catch(err => {
                        console.error('Clipboard copy failed:', err);
                        this.fallbackCopyText(errorText);
                    });
                } else {
                    this.fallbackCopyText(errorText);
                }
            }
            
            // Fallback copy method for older browsers
            fallbackCopyText(text) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.top = '0';
                textArea.style.left = '0';
                textArea.style.width = '2em';
                textArea.style.height = '2em';
                textArea.style.padding = '0';
                textArea.style.border = 'none';
                textArea.style.outline = 'none';
                textArea.style.boxShadow = 'none';
                textArea.style.background = 'transparent';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    alert('Errors copied to clipboard!');
                } catch (err) {
                    alert('Copy failed. Please select and copy manually.');
                }
                
                document.body.removeChild(textArea);
            }
            
            // Export errors for debugging
            exportErrors() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    errors: this.errors,
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `endlessrunner-errors-${Date.now()}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            }
        }
        
        // Initialize the error tracker
        window.errorTracker = new LiveErrorTracker();
        
        // Add keyboard shortcut to toggle error console
        document.addEventListener('keydown', (event) => {
            // Ctrl+E or Cmd+E to toggle error console
            if ((event.ctrlKey || event.metaKey) && event.key === 'e') {
                event.preventDefault();
                window.errorTracker.toggle();
            }
            
            // Ctrl+Shift+E to export errors
            if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === 'E') {
                event.preventDefault();
                window.errorTracker.exportErrors();
            }
        });
        
        // Test the error tracker
        console.log('✅ [ErrorTracker] Error tracking system ready! Press Ctrl+E to toggle console.');
        console.warn('🧪 [ErrorTracker] Test warning - error tracker is working!');
        
        // ==================== END LIVE ERROR TRACKING SYSTEM ====================
        
        // ==================== LEVEL SYSTEM INCLUDES ====================
        
        // Load all level classes before initializing the game
        // Level Base Class and Manager must be loaded first
        console.log('📋 [LevelSystem] Loading level base classes...');
        
        // Level Base Class
        if (!window.LevelBase) {
            console.error('❌ LevelBase not found! Loading LevelBase.js...');
        }
        
        // Level Manager Pro
        if (!window.LevelManagerPro) {
            console.error('❌ LevelManagerPro not found! Loading LevelManagerPro.js...');
        }
        
        console.log('🎮 [LevelSystem] Loading all 10 levels...');
        
        // Level 1: Already included (Subway Daylight)
        // Level 2: Cyberpunk Night
        if (!window.Level2_Cyberpunk) {
            console.error('❌ Level2_Cyberpunk not found! Loading Level2_Cyberpunk.js...');
        }
        
        // Level 3: Space Station
        if (!window.Level3_Space) {
            console.error('❌ Level3_Space not found! Loading Level3_Space.js...');
        }
        
        // Level 4: Jungle Adventure
        if (!window.Level4_Jungle) {
            console.error('❌ Level4_Jungle not found! Loading Level4_Jungle.js...');
        }
        
        // Level 5: Ice Crystal
        if (!window.Level5_Ice) {
            console.error('❌ Level5_Ice not found! Loading Level5_Ice.js...');
        }
        
        // Level 6: Underwater
        if (!window.Level6_Underwater) {
            console.error('❌ Level6_Underwater not found! Loading Level6_Underwater.js...');
        }
        
        // Level 7: Desert Storm
        if (!window.Level7_Desert) {
            console.error('❌ Level7_Desert not found! Loading Level7_Desert.js...');
        }
        
        // Level 8: Forest Twilight
        if (!window.Level8_Forest) {
            console.error('❌ Level8_Forest not found! Loading Level8_Forest.js...');
        }
        
        // Level 9: Volcano
        if (!window.Level9_Volcano) {
            console.error('❌ Level9_Volcano not found! Loading Level9_Volcano.js...');
        }
        
        // Level 10: Crystal Dimension
        if (!window.Level10_Crystal) {
            console.error('❌ Level10_Crystal not found! Loading Level10_Crystal.js...');
        }
        
        console.log('✅ [LevelSystem] All level checks complete! Ready for dynamic loading.');
        
        // ==================== END LEVEL SYSTEM INCLUDES ====================
        
        // Audio System
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.masterVolume = 0.3;
                this.backgroundMusic = null;
                this.musicVolume = 0.15; // Lower volume for background music
                this.musicGain = null;
                this.musicLoaded = false;
                this.musicPlaying = false;
                this.initAudio();
            }

            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Create separate gain node for background music
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.gain.value = this.musicVolume;
                    this.musicGain.connect(this.audioContext.destination);
                    
                    this.createAdvancedSounds();
                    
                    // Preload background music (but don't play yet)
                    this.preloadBackgroundMusic();
                } catch (error) {
                    console.log('Audio not supported');
                }
            }

            async preloadBackgroundMusic() {
                try {
                    console.log('🎵 Starting background music preload...');
                    // Try to load background music file (multiple formats)
                    const musicPaths = [
                        'sounds/background/background.mp3',
                        'sounds/background/background.wav',
                        'sounds/background/game-music.mp3',
                        'sounds/background/game-music.wav',
                        'sounds/background/subway-theme.mp3',
                        'sounds/background/subway-theme.wav'
                    ];
                    
                    for (let path of musicPaths) {
                        try {
                            console.log(`🎵 Trying to load background music: ${path}`);
                            const audio = new Audio(path);
                            audio.preload = 'metadata'; // Changed from 'auto' for large files
                            audio.loop = true;
                            audio.volume = 0; // Start silent
                            audio.crossOrigin = 'anonymous'; // Fix CORS issues
                            
                            // Test if file exists by trying to load it
                            await new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => {
                                    console.log(`⏰ Timeout loading: ${path}`);
                                    reject(new Error('Timeout'));
                                }, 10000); // 10 second timeout for large files
                                
                                audio.addEventListener('canplaythrough', () => {
                                    clearTimeout(timeout);
                                    console.log(`✅ Background music loaded: ${path}`);
                                    this.backgroundMusic = audio;
                                    this.musicLoaded = true;
                                    resolve();
                                });
                                audio.addEventListener('loadedmetadata', () => {
                                    console.log(`📊 Music metadata loaded: ${path} (${audio.duration}s)`);
                                });
                                audio.addEventListener('error', (e) => {
                                    clearTimeout(timeout);
                                    console.log(`❌ Audio error for ${path}:`, e);
                                    reject(e);
                                });
                                audio.load();
                            });
                            break; // If successful, stop trying other files
                        } catch (error) {
                            console.log(`❌ Failed to load: ${path}`);
                            continue; // Try next file
                        }
                    }
                    
                    if (!this.musicLoaded) {
                        console.log('🎵 No background music found - running without music');
                    }
                } catch (error) {
                    console.log('Background music preload failed:', error);
                }
            }

            startBackgroundMusic() {
                if (!this.backgroundMusic || !this.musicLoaded || this.musicPlaying) return;
                
                try {
                    this.backgroundMusic.currentTime = 0;
                    this.backgroundMusic.volume = this.musicVolume;
                    this.backgroundMusic.play();
                    this.musicPlaying = true;
                    
                    // Fade in effect
                    this.fadeInMusic();
                    console.log('🎵 Background music started');
                } catch (error) {
                    console.log('Failed to start background music:', error);
                }
            }

            stopBackgroundMusic() {
                if (!this.backgroundMusic || !this.musicPlaying) return;
                
                try {
                    this.fadeOutMusic(() => {
                        this.backgroundMusic.pause();
                        this.backgroundMusic.currentTime = 0;
                        this.musicPlaying = false;
                        console.log('🎵 Background music stopped');
                    });
                } catch (error) {
                    console.log('Failed to stop background music:', error);
                }
            }

            fadeInMusic(duration = 2000) {
                if (!this.backgroundMusic) return;
                
                const startVolume = 0;
                const endVolume = this.musicVolume;
                const steps = 20;
                const stepDuration = duration / steps;
                const volumeStep = (endVolume - startVolume) / steps;
                
                this.backgroundMusic.volume = startVolume;
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        if (this.backgroundMusic && this.musicPlaying) {
                            this.backgroundMusic.volume = Math.min(startVolume + (volumeStep * i), endVolume);
                        }
                    }, stepDuration * i);
                }
            }

            fadeOutMusic(callback, duration = 1000) {
                if (!this.backgroundMusic) return;
                
                const startVolume = this.backgroundMusic.volume;
                const steps = 20;
                const stepDuration = duration / steps;
                const volumeStep = startVolume / steps;
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        if (this.backgroundMusic) {
                            this.backgroundMusic.volume = Math.max(startVolume - (volumeStep * i), 0);
                            if (i === steps && callback) {
                                callback();
                            }
                        }
                    }, stepDuration * i);
                }
            }

            setMusicVolume(volume) {
                this.musicVolume = Math.max(0, Math.min(1, volume));
                if (this.backgroundMusic) {
                    this.backgroundMusic.volume = this.musicVolume;
                }
            }

            createTone(frequency, duration, type = 'sine', fadeOut = true) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                if (fadeOut) {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                } else {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                }
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            createNoise(duration, filterFreq = 1000) {
                if (!this.audioContext) return;
                
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const source = this.audioContext.createBufferSource();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();
                
                source.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;
                
                source.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                source.start();
            }

            createAdvancedSounds() {
                // Enhanced realistic sounds using multiple layers
                this.sounds = {
                    jump: () => {
                        // Multi-layered jump sound: impact + whoosh + landing prep
                        this.createTone(180, 0.08, 'sine'); // Base thump
                        setTimeout(() => this.createTone(320, 0.12, 'triangle'), 20); // Whoosh up
                        setTimeout(() => this.createNoise(0.06, 4000), 40); // Air resistance
                        this.createReverbEffect(240, 0.15, 0.3); // Echo for depth
                    },
                    
                    land: () => {
                        // Heavy landing with ground impact and dust
                        this.createTone(80, 0.15, 'square'); // Deep thud
                        this.createNoise(0.12, 800); // Ground crunch
                        setTimeout(() => this.createNoise(0.08, 1500), 50); // Dust settle
                        this.createReverbEffect(120, 0.2, 0.4); // Ground echo
                    },
                    
                    duck: () => {
                        // Quick duck sound with fabric/wind
                        this.createTone(140, 0.15, 'sawtooth');
                        this.createNoise(0.1, 3500); // Wind resistance
                        setTimeout(() => this.createTone(110, 0.1, 'sine'), 80); // Body movement
                    },
                    
                    success: () => {
                        // Triumphant success with harmonic progression
                        const notes = [400, 500, 630, 800, 1000];
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.2, 'sine');
                                this.createReverbEffect(freq, 0.15, 0.6); // Rich reverb
                            }, i * 80);
                        });
                        // Add sparkle effect
                        setTimeout(() => {
                            for (let j = 0; j < 8; j++) {
                                setTimeout(() => this.createTone(1200 + j * 100, 0.05, 'sine'), j * 25);
                            }
                        }, 400);
                    },
                    
                    collision: () => {
                        // Dramatic collision with multiple impact layers
                        this.createNoise(0.4, 1200); // Main crash
                        this.createTone(60, 0.6, 'sawtooth', false); // Low rumble
                        setTimeout(() => this.createNoise(0.25, 2500), 100); // Glass/debris
                        setTimeout(() => this.createTone(200, 0.3, 'square'), 150); // Metal impact
                        this.createReverbEffect(150, 0.8, 0.7); // Long echo
                        
                        // Add screen shake intensity based on collision
                        if (window.gameState) {
                            gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, 0.3);
                        }
                    },
                    
                    coin: () => {
                        // Magical kiwi collection with sparkle
                        this.createTone(800, 0.12, 'sine');
                        setTimeout(() => this.createTone(1200, 0.1, 'sine'), 40);
                        setTimeout(() => this.createTone(1600, 0.08, 'triangle'), 80);
                        this.createReverbEffect(1000, 0.2, 0.5); // Magical echo
                        // Add subtle high-frequency shimmer
                        setTimeout(() => {
                            for (let k = 0; k < 4; k++) {
                                setTimeout(() => this.createTone(2000 + k * 200, 0.03, 'sine'), k * 15);
                            }
                        }, 120);
                    },
                    
                    whoosh: () => {
                        // Enhanced lane change with speed-dependent pitch
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.5;
                        const baseFreq = 2000 + speedMultiplier * 2000;
                        this.createNoise(0.15 + speedMultiplier * 0.1, baseFreq);
                        this.createTone(250 + speedMultiplier * 100, 0.1, 'triangle');
                    },
                    
                    powerup: () => {
                        // Epic power-up activation sequence
                        const powerChord = [400, 500, 600, 750, 900];
                        powerChord.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.25, 'sine');
                                this.createReverbEffect(freq, 0.2, 0.8);
                            }, i * 60);
                        });
                        
                        // Add ascending energy effect
                        setTimeout(() => {
                            for (let m = 0; m < 12; m++) {
                                setTimeout(() => {
                                    this.createTone(1000 + m * 50, 0.04, 'triangle');
                                }, m * 30);
                            }
                        }, 300);
                    },
                    
                    // NEW: Ambient city sounds
                    ambient: () => {
                        if (!this.ambientPlaying) {
                            this.ambientPlaying = true;
                            this.playAmbientLoop();
                        }
                    },
                    
                    // NEW: Speed-based engine sound
                    engine: () => {
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.3;
                        const engineFreq = 40 + speedMultiplier * 60;
                        this.createTone(engineFreq, 0.2, 'sawtooth', false);
                    },
                    
                    // NEW: Near miss bonus sound
                    nearmiss: () => {
                        this.createTone(600, 0.08, 'sine');
                        setTimeout(() => this.createTone(800, 0.06, 'triangle'), 30);
                        this.createNoise(0.05, 5000); // Subtle whoosh
                    }
                };
            }

            // Enhanced reverb effect for depth
            createReverbEffect(frequency, duration, intensity) {
                if (!this.audioContext) return;
                
                const delay = this.audioContext.createDelay(0.3);
                const feedback = this.audioContext.createGain();
                const wetGain = this.audioContext.createGain();
                
                delay.delayTime.value = 0.1;
                feedback.gain.value = intensity * 0.4;
                wetGain.gain.value = intensity * 0.3;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(wetGain);
                wetGain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            // Ambient city soundscape
            playAmbientLoop() {
                if (!this.audioContext || !this.ambientPlaying) return;
                
                // Distant traffic rumble
                const trafficFreq = 60 + Math.random() * 20;
                this.createTone(trafficFreq, 2.0, 'sawtooth', false);
                
                // Occasional distant sounds
                if (Math.random() > 0.7) {
                    setTimeout(() => {
                        this.createNoise(0.05, 800 + Math.random() * 1000);
                    }, Math.random() * 1000);
                }
                
                // Continue ambient loop
                setTimeout(() => this.playAmbientLoop(), 2000);
            }
            
            stopAmbient() {
                this.ambientPlaying = false;
            }
            
            // Dynamic sound based on game speed
            playSpeedDependentSound(soundName, speedMultiplier = 1) {
                const originalVolume = this.masterGain.gain.value;
                const speedVolume = Math.min(originalVolume * (0.8 + speedMultiplier * 0.4), 1.0);
                
                this.masterGain.gain.value = speedVolume;
                this.play(soundName);
                
                // Restore original volume
                setTimeout(() => {
                    this.masterGain.gain.value = originalVolume;
                }, 200);
            }
            
            play(soundName) {
                if (this.sounds[soundName]) {
                    try {
                        this.sounds[soundName]();
                    } catch (error) {
                        console.warn('Audio playback error:', error);
                    }
                } else {
                    // BUGFIX: Silently ignore missing sound effects to prevent console spam
                    // console.log(`Sound effect '${soundName}' not available`);
                }
            }

            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        const audioManager = new AudioManager();
        audioManager.ambientPlaying = false;
        
        // CRITICAL FIX: Centralized score management to prevent explosion
        function addScore(amount, source = 'unknown') {
            // Add to queue instead of directly to score
            gameState.scoreQueue += Math.max(0, Math.floor(amount));
            
            // Debug logging for score tracking
            if (amount > 0) {
                console.log(`🎯 Score queued: +${amount} from ${source} (queue: ${gameState.scoreQueue})`);
            }
        }
        
        function processScoreQueue() {
            const currentTime = performance.now();
            
            // Only process queue every scoreUpdateInterval
            if (currentTime - gameState.lastScoreUpdate < gameState.scoreUpdateInterval) {
                return;
            }
            
            if (gameState.scoreQueue > 0) {
                // Apply limited amount from queue
                const scoreToAdd = Math.min(gameState.scoreQueue, gameState.maxScorePerUpdate);
                gameState.score += scoreToAdd;
                gameState.scoreQueue -= scoreToAdd;
                
                gameState.lastScoreUpdate = currentTime;
                
                console.log(`📊 Score processed: +${scoreToAdd} (total: ${gameState.score}, remaining queue: ${gameState.scoreQueue})`);
            }
        }
        
        // Auto-start ambient sounds when game starts
        let ambientStarted = false;

        // Supabase Configuration - Using working credentials
        const SUPABASE_URL = 'https://umvrurelsxpxmyzcvrcd.supabase.co'
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVtdnJ1cmVsc3hweG15emN2cmNkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzUzMzQ5OTYsImV4cCI6MjA1MDkxMDk5Nn0.xpBgJ0BQN86JqhNtKzKNl1kchO1IU_oXI7SYpgfLBJU'
        
        // Initialize Supabase client
        let supabase = null;
        let highscores = [];
        let currentScore = 0;
        let currentSurvivalTime = 0;

        // Initialize Supabase connection
        try {
            if (window.supabase) {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('✅ Supabase initialized successfully');
                console.log('🔗 Database URL:', SUPABASE_URL);
                console.log('🔑 Using API Key:', SUPABASE_ANON_KEY.substring(0, 20) + '...');
            } else {
                throw new Error('Supabase library not loaded');
            }
        } catch (error) {
            console.log('⚠️ Supabase initialization failed, using offline mode:', error);
            supabase = null;
        }

        // Highscore Management System
        class HighscoreManager {
            constructor() {
                this.localStorageKey = 'subwayRunner_highscores';
                this.loadHighscores();
            }

            async loadHighscores() {
                console.log('📊 Loading highscores...');
                try {
                    if (supabase) {
                        console.log('🔄 Fetching from Supabase...');
                        
                        // BUGFIX: Add timeout and better error handling for DNS issues
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Request timeout - possible DNS/network issue')), 5000)
                        );
                        
                        const supabasePromise = supabase
                            .from('subway_runner_scores')
                            .select('*')
                            .order('score', { ascending: false })
                            .limit(10);
                            
                        const { data, error } = await Promise.race([supabasePromise, timeoutPromise]);
                        
                        if (!error && data) {
                            console.log(`✅ Loaded ${data.length} scores from Supabase:`, data);
                            highscores = data;
                        } else {
                            console.log('❌ Supabase error:', error);
                            throw new Error('Supabase error: ' + (error?.message || 'Unknown'));
                        }
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    console.log('⚠️ Network/DNS error, falling back to localStorage:', error.message);
                    // Fallback to localStorage
                    const localScores = localStorage.getItem(this.localStorageKey);
                    highscores = localScores ? JSON.parse(localScores) : [];
                    console.log(`📱 Loaded ${highscores.length} local scores:`, highscores);
                }
                this.displayHighscores();
            }

            async submitScore(playerName, score, survivalTime, isVictory) {
                const scoreEntry = {
                    player_name: playerName,
                    score: score,
                    survival_time: survivalTime,
                    is_victory: isVictory,
                    created_at: new Date().toISOString()
                };

                console.log('💾 Submitting score:', scoreEntry);

                try {
                    if (supabase) {
                        console.log('🔄 Inserting to Supabase...');
                        const { data, error } = await supabase
                            .from('subway_runner_scores')
                            .insert([scoreEntry])
                            .select();
                        
                        if (error) {
                            console.log('❌ Supabase insert error:', error);
                            throw error;
                        }
                        
                        console.log('✅ Score submitted to Supabase:', data);
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    console.log('⚠️ Supabase submit failed, using localStorage:', error.message);
                    // Fallback to localStorage
                    highscores.push(scoreEntry);
                    highscores.sort((a, b) => b.score - a.score);
                    highscores = highscores.slice(0, 10); // Keep only top 10
                    localStorage.setItem(this.localStorageKey, JSON.stringify(highscores));
                    console.log('📱 Score saved locally');
                }

                await this.loadHighscores();
            }

            isHighscore(score) {
                if (highscores.length < 10) return true;
                return score > highscores[9].score;
            }

            displayHighscores() {
                const list = document.getElementById('highscoreList');
                if (highscores.length === 0) {
                    list.innerHTML = 'Keine Scores vorhanden';
                    return;
                }

                let html = '';
                highscores.forEach((score, index) => {
                    const rank = index + 1;
                    const victoryIcon = score.is_victory ? '🏆' : '';
                    const timeText = score.is_victory ? '60s' : `${score.survival_time}s`;
                    
                    html += `<div class="highscore-entry">
                        ${rank}. ${score.player_name} ${victoryIcon}<br>
                        <small>${score.score} pts - ${timeText}</small>
                    </div>`;
                });
                list.innerHTML = html;
            }
        }

        const highscoreManager = new HighscoreManager();

        // Make functions globally available for onclick handlers
        window.startGame = function() {
            console.log('startGame called');
            try {
                startGameInternal();
            } catch (error) {
                console.error('Error in startGame:', error);
            }
        };

        window.submitHighscore = function() {
            console.log('submitHighscore called');
            submitHighscoreInternal();
        };

        window.skipHighscore = function() {
            console.log('skipHighscore called');
            skipHighscoreInternal();
        };

        // Game state
        let gameState = {
            isPlaying: false,
            isGameOver: false,
            isVictory: false,
            score: 0,
            speed: 0.05, // Noch langsamerer Start (war 0.08)
            baseSpeed: 0.05,
            maxSpeed: 0.25, // Reduzierte Maximalgeschwindigkeit (war 0.45)
            lives: 3,
            gameTime: 60, // 60 Sekunden
            timeRemaining: 60,
            gameStartTime: 0,
            playerLane: 1, // 0=left, 1=center, 2=right
            playerAction: 'running', // running, jumping, ducking
            playerY: 0,
            jumpVelocity: 0,
            jumpStartTime: 0,  // BUGFIX: Track jump start time for safety
            maxJumpDuration: 2000, // Maximum 2 seconds jump duration
            obstacles: [],
            invulnerable: false,
            invulnerabilityTime: 0,
            timeScale: 1.0,
            cameraShakeIntensity: 0,
            cameraZoom: 1.0,
            slowMotionActive: false,
            
            // NEW: Power-Up & Collectibles System
            powerUps: [],              // Spawned power-ups in world
            kiwis: [],                 // Spawned kiwis in world
            broccolis: [],             // Spawned broccolis in world  
            collectedKiwis: 0,         // Current session kiwis
            collectedBroccolis: 0,     // Current session broccolis
            totalKiwis: 0,             // Lifetime kiwis
            totalBroccolis: 0,         // Lifetime broccolis
            totalCollectibles: 0,      // Total spawned this session
            collectionGoal: 10,        // Target collectibles for bonus (80% of max ~12-15)
            collectionBonusAwarded: {      // Track tiered collection bonuses
                fiveOfOne: false,               // 5+ of one type
                allOfOne: false,                // All 30 kiwis OR all 7 broccolis  
                allThirtySeven: false,          // All 37 collectibles (30 kiwis + 7 broccolis)
                broccoliMaster: false,          // 5 broccolis (+200 points)
                veggieChampion: false           // 7 broccolis (+500 points)
            },
            activePowerUp: null,       // Currently active power-up
            powerUpTimeRemaining: 0,   // Time left for active power-up
            magnetActive: false,       // Magnet power-up state
            shieldActive: false,       // Shield power-up state
            speedBoostActive: false,   // Speed boost power-up state
            kiwiCombo: 0,              // Current kiwi collection combo
            comboMultiplier: 1,        // Score multiplier from combos
            lastKiwiTime: 0,           // For combo timeout
            
            // NEW: Advanced Skill & Combo System
            skillCombo: 0,             // Current skill move combo (dodge sequences)
            lastSkillTime: 0,          // Time of last skill move
            moveSequence: [],          // Track recent moves for combo detection
            consecutiveAvoidances: 0,  // Count of consecutive obstacle avoidances
            lastAvoidanceTime: 0,      // Time of last successful avoidance
            lastAction: 'running',     // Track last player action for sequences
            rapidMoveBonus: 0,         // Bonus for rapid direction changes
            perfectTimingCount: 0,     // Count of perfect timing moves
            skillMultiplier: 1,        // Score multiplier for skill moves
            comboActive: false,        // Visual indicator for active combo
            
            // NEW: Enhanced Gameplay Features
            nearMissStreak: 0,         // Consecutive near misses
            lastNearMissTime: 0,       // Time of last near miss
            nearMissMultiplier: 1,     // Bonus multiplier for near misses
            milestoneReached: 0,       // Track distance milestones
            lastMilestone: 0,          // Last milestone distance
            scoreMultiplier: 1,        // Combined score multiplier
            maxCombo: 0,               // Highest combo achieved
            perfectRun: true,          // No hits taken
            totalDistance: 0,          // Total distance travelled
            
            // 10-Level System
            currentLevel: 1,           // Current level (1-10)
            levelManager: null,        // LevelManagerPro instance
            
            // Touch Controls
            touchStartX: 0,
            touchStartY: 0,
            touchThreshold: 50,        // Swipe distance threshold
            isTouchDevice: false,      // Auto-detect touch support
            
            // Environment state
            currentEnvironment: 'street', // 'street', 'tunnel', 'tunnel_entrance', 'tunnel_exit'
            environmentTransition: false,
            tunnelProgress: 0,
            tunnelStartTime: 0,
            tunnelDuration: 15000, // 15 seconds in tunnel
            nextTunnelTime: 20000, // First tunnel after 20 seconds
            tunnelCooldown: 30000, // 30 seconds between tunnels
            lastTunnelExit: 0,
            tunnelSegments: [], // Tunnel wall/ceiling segments
            tunnelLights: [], // Tunnel lighting
            ambientLightIntensity: 1.0, // For tunnel dimming effect
            
            // Visual Effects State
            speedLineIntensity: 0,
            currentFogDensity: 0.002,
            targetFogDensity: 0.002,
            motionBlurActive: false,
            vignetteIntensity: 0,
            particleEffects: [],
            
            // Score update throttling (FIX: Prevent 60FPS score updates)
            lastScoreUpdate: 0,
            scoreUpdateInterval: 100, // Update score every 100ms (10 times per second)
            
            // Centralized score queue for throttling ALL score additions
            scoreQueue: 0,
            maxScorePerUpdate: 100 // Maximum score increase per throttled update
        };

        // Three.js setup
        let scene, camera, renderer, player, track, obstacles = [];
        const LANE_POSITIONS = [-2, 0, 2];
        
        // Power-Up and Collectible arrays for tracking
        let powerUps = [];
        let kiwis = [];
        let broccolis = [];  // NEW: Brokkoli tracking
        
        // Power-Up configuration
        const POWER_UP_TYPES = {
            magnet: {
                name: 'Magnet',
                icon: '🧲',
                color: 0xFFD700, // Keep golden color for UI/effects
                duration: 15000, // 15 seconds
                effect: 'magnetActive'
            },
            largeMagnet: {
                name: 'Large Magnet',
                icon: '🧲',
                color: 0xFFD700, // Same golden color
                duration: 15000, // Same duration as regular magnet
                effect: 'magnetActive', // Same effect
                isLarge: true, // Special flag to identify large magnet
                spawnRate: 0.3 // 30% chance when spawning magnets
            },
            shield: {
                name: 'Shield', 
                icon: '🛡️',
                color: 0x4ECDC4,
                duration: 10000, // 10 seconds
                effect: 'shieldActive'
            },
            speedboost: {
                name: 'Speed Boost',
                icon: '⚡',
                color: 0xFF6B35,
                duration: 8000, // 8 seconds
                effect: 'speedBoostActive'
            }
        };
        
        // Environment object tracking for parallax movement
        let environmentObjects = {
            buildings: [],
            streetLamps: [],
            trafficSigns: [],
            streetLines: [],
            sidewalks: []
        };
        
        // Smooth speed system
        let visualSpeed = 0.08;
        let lastFrameTime = 0;
        const SPEED_LERP_FACTOR = 0.05;

        // 🎮 LEVEL TESTING FUNCTION
        /**
         * SENIOR DEVELOPER ULTRA-ROBUST: Level Testing System mit Level-Manager Integration
         * @param {number} levelNumber - Level number to activate (1-10)
         */
        function testLevel(levelNumber) {
            console.log(`🎮 [Testing] ULTRA-ROBUST Level Switch to Level ${levelNumber}`);
            
            // PROTECTION: Validate level number
            if (levelNumber < 1 || levelNumber > 10) {
                console.error('❌ [Testing] Invalid level number:', levelNumber);
                return;
            }
            
            // Force set current level
            gameState.currentLevel = levelNumber;
            gameState.score = (levelNumber - 1) * 1000; // Set score to trigger level
            
            // Update UI
            const levelDisplay = document.getElementById('levelDisplay');
            if (levelDisplay) {
                levelDisplay.textContent = `Level ${levelNumber}`;
            }
            
            // SENIOR DEVELOPER RULE: Verwende Level-Manager-Pro System
            if (window.LevelManagerPro && window.LevelManagerPro.switchToLevel) {
                try {
                    console.log(`🔄 [Testing] Using LevelManagerPro to switch to Level ${levelNumber}`);
                    window.LevelManagerPro.switchToLevel(levelNumber);
                    console.log(`✅ [Testing] Level ${levelNumber} activated via LevelManagerPro`);
                    return;
                } catch (error) {
                    console.warn('⚠️ [Testing] LevelManagerPro failed, falling back to manual method:', error);
                }
            }
            
            // FALLBACK: Manual level switching for visual changes
            if (levelNumber === 1) {
                // Reset to basic level 1
                scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);
                document.body.style.background = 'linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%)';
                console.log('✅ Level 1 (Subway) activated');
            } else {
                // Apply level themes manually
                const levelThemes = {
                    2: { name: 'Cyberpunk', fog: 0x4B0082, bg: 'linear-gradient(to bottom, #4B0082 0%, #9400D3 100%)' },
                    3: { name: 'Space', fog: 0x000033, bg: 'linear-gradient(to bottom, #000033 0%, #000066 100%)' },
                    4: { name: 'Jungle', fog: 0x228B22, bg: 'linear-gradient(to bottom, #228B22 0%, #006400 100%)' },
                    5: { name: 'Ice', fog: 0xB0E0E6, bg: 'linear-gradient(to bottom, #B0E0E6 0%, #87CEEB 100%)' },
                    6: { name: 'Ocean', fog: 0x006994, bg: 'linear-gradient(to bottom, #006994 0%, #4682B4 100%)' },
                    7: { name: 'Desert', fog: 0xDAA520, bg: 'linear-gradient(to bottom, #DAA520 0%, #F4A460 100%)' },
                    8: { name: 'Forest', fog: 0x2F4F2F, bg: 'linear-gradient(to bottom, #2F4F2F 0%, #228B22 100%)' },
                    9: { name: 'Volcano', fog: 0x8B0000, bg: 'linear-gradient(to bottom, #8B0000 0%, #FF4500 100%)' },
                    10: { name: 'Crystal', fog: 0x9400D3, bg: 'linear-gradient(to bottom, #9400D3 0%, #8A2BE2 100%)' }
                };
                
                const theme = levelThemes[levelNumber];
                if (theme) {
                    scene.fog = new THREE.FogExp2(theme.fog, 0.002);
                    document.body.style.background = theme.bg;
                    console.log(`✅ Level ${levelNumber} (${theme.name}) theme applied`);
                }
            }
            
            // Hide panel
            document.getElementById('levelTestPanel').style.display = 'none';
            
            // Start/restart game if not running
            if (!gameState.isPlaying) {
                startGame();
            }
        }

        async function init() {
            console.log('Initializing Three.js scene...');
            try {
                // Scene setup with conditional fog (3GS-Prevention)
                scene = new THREE.Scene();
                
                // 🚨 CRITICAL: Fog Toggle Implementation (3GS-Safe)
                if (DEBUG.DISABLE_FOG) {
                    console.log('⚠️ [3GS-Prevention] Fog DISABLED for debugging - no refreshUniformsCommon crashes possible');
                    scene.fog = null;
                } else {
                    console.log('✅ [3GS-Prevention] Fog ENABLED with bulletproof materials');
                    scene.fog = new THREE.FogExp2(0x87CEEB, gameState.currentFogDensity);
                }
                
                // ==================== INITIALIZE 10-LEVEL SYSTEM ====================
                console.log('🎮 [LevelSystem] Initializing Level Manager Pro...');
                
                if (window.LevelManagerPro) {
                    try {
                        // Initialize Level Manager with scene and resource manager
                        await LevelManagerPro.initialize(scene, window.ResourceManager);
                        gameState.levelManager = LevelManagerPro;
                        
                        // Start with Level 1
                        const level1Success = await LevelManagerPro.loadLevel(1, true); // Skip transition for initial load
                        if (level1Success) {
                            console.log('✅ [LevelSystem] Level 1 (Subway Daylight) loaded successfully');
                            updateLevelDisplay(1);
                        } else {
                            console.error('❌ [LevelSystem] Failed to load Level 1');
                        }
                        
                        console.log('✅ [LevelSystem] Level Manager Pro initialized successfully');
                    } catch (error) {
                        console.error('❌ [LevelSystem] Failed to initialize Level Manager Pro:', error);
                        console.warn('⚠️ [LevelSystem] Continuing without level system...');
                    }
                } else {
                    console.error('❌ [LevelSystem] LevelManagerPro not found! Check script loading order');
                }
                
                // ==================== END LEVEL SYSTEM INITIALIZATION ====================

            // Camera (Subway Surfers perspective)
            camera = new THREE.PerspectiveCamera(60, 4/3, 0.1, 1000);
            camera.position.set(0, 3, 8);

            // Renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Modern lighting system
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);

            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFE4B5, 1.2);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);

            // Atmospheric hemisphere light for sky gradient
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.6);
            scene.add(hemisphereLight);

            // Rim lighting for urban atmosphere
            const rimLight = new THREE.DirectionalLight(0x4A90E2, 0.3);
            rimLight.position.set(-5, 8, -10);
            scene.add(rimLight);

            // Enhance renderer for better visuals
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            // Create player
            createPlayer();
            
            // Create track
            createTrack();
            
            // Create environment
            createEnvironment();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
                // 🔍 PHASE 1.5: Material Audit Tool - Check scene safety
                if (DEBUG.MATERIAL_AUDIT) {
                    setTimeout(() => {
                        console.log('🔍 [3GS-Prevention] Running initial material audit...');
                        const auditResult = auditSceneMaterials(scene);
                        
                        if (auditResult.problematicMaterials > 0) {
                            console.error(`🚨 [3GS-WARNING] Found ${auditResult.problematicMaterials} problematic materials!`);
                            console.warn('💡 [3GS-Fix] Consider using createSafeShader() for custom shaders');
                            
                            if (DEBUG.DISABLE_FOG) {
                                console.log('✅ [3GS-Safe] Fog disabled - problematic materials won\'t cause crashes');
                            } else {
                                console.warn('⚠️ [3GS-Risk] Fog enabled with problematic materials - monitor for crashes');
                            }
                        } else {
                            console.log('✅ [3GS-Safe] All materials are bulletproof - no shader crashes possible');
                        }
                    }, 1000); // Delay to ensure all objects are created
                }
                
                // Start render loop
                animate();
                console.log('Three.js initialization complete');
            } catch (error) {
                console.error('Error initializing Three.js:', error);
            }
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            // Player body (torso)
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A90E2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.7;
            body.castShadow = true;
            playerGroup.add(body);

            // Player head
            const headGeometry = new THREE.SphereGeometry(0.25);
            const headMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF5B041
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.35;
            head.castShadow = true;
            playerGroup.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.4, 0.2);
            playerGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.4, 0.2);
            playerGroup.add(rightEye);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xF5B041 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            playerGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2C3E50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.0, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.0, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            // Shoes
            const shoeGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.15, -0.35, 0.1);
            leftShoe.castShadow = true;
            playerGroup.add(leftShoe);
            
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.15, -0.35, 0.1);
            rightShoe.castShadow = true;
            playerGroup.add(rightShoe);

            // Backpack
            const backpackGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
            const backpackMaterial = new THREE.MeshLambertMaterial({ color: 0xE74C3C });
            const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.7, -0.25);
            backpack.castShadow = true;
            playerGroup.add(backpack);

            // Cap
            const capGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1);
            const capMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.55;
            cap.castShadow = true;
            playerGroup.add(cap);

            // Cap visor
            const visorGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.02);
            const visorMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 1.48, 0.2);
            visor.rotation.x = -0.3;
            visor.castShadow = true;
            playerGroup.add(visor);

            playerGroup.position.set(LANE_POSITIONS[gameState.playerLane], 0, 0);
            
            // FIX: Player should look forward (negative Z direction)
            playerGroup.rotation.y = Math.PI;
            
            scene.add(playerGroup);
            player = playerGroup;
        }

        function createTrack() {
            const trackGroup = new THREE.Group();
            
            // Create track segments
            for (let i = 0; i < 10; i++) {
                const segmentGroup = new THREE.Group();
                segmentGroup.position.z = -i * 10;
                
                // Main track
                const trackGeometry = new THREE.BoxGeometry(8, 0.1, 10);
                const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.receiveShadow = true;
                segmentGroup.add(trackMesh);
                
                // Lane dividers
                const dividerGeometry = new THREE.BoxGeometry(0.1, 0.05, 10);
                const dividerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
                
                const leftDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                leftDivider.position.x = -1;
                segmentGroup.add(leftDivider);
                
                const rightDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                rightDivider.position.x = 1;
                segmentGroup.add(rightDivider);
                
                trackGroup.add(segmentGroup);
            }
            
            scene.add(trackGroup);
            track = trackGroup;
        }

        function createEnvironment() {
            // Urban ground with asphalt texture
            const groundGeometry = new THREE.PlaneGeometry(80, 120);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(0, -1, -30);
            ground.receiveShadow = true;
            scene.add(ground);

            // Sidewalks
            const sidewalkGeometry = new THREE.PlaneGeometry(8, 120);
            const sidewalkMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x999999
            });
            
            const leftSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            leftSidewalk.rotation.x = -Math.PI / 2;
            leftSidewalk.position.set(-10, -0.98, -30);
            leftSidewalk.receiveShadow = true;
            leftSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(leftSidewalk);
            environmentObjects.sidewalks.push(leftSidewalk);
            
            const rightSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            rightSidewalk.rotation.x = -Math.PI / 2;
            rightSidewalk.position.set(10, -0.98, -30);
            rightSidewalk.receiveShadow = true;
            rightSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(rightSidewalk);
            environmentObjects.sidewalks.push(rightSidewalk);

            // Street lines
            for (let i = 0; i < 20; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.3, 2);
                const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const streetLine = new THREE.Mesh(lineGeometry, lineMaterial);
                streetLine.rotation.x = -Math.PI / 2;
                streetLine.position.set(0, -0.95, -i * 6);
                streetLine.userData = { 
                    type: 'streetLine', 
                    initialZ: -i * 6,
                    parallaxSpeed: 0.95 // 95% of game speed (close to track)
                };
                scene.add(streetLine);
                environmentObjects.streetLines.push(streetLine);
            }

            // Realistic city buildings
            for (let i = 0; i < 15; i++) {
                createRealisticBuilding(-15 - Math.random() * 8, -i * 8 - Math.random() * 4, 'left');
                createRealisticBuilding(15 + Math.random() * 8, -i * 8 - Math.random() * 4, 'right');
            }

            // Street lamps
            for (let i = 0; i < 12; i++) {
                createStreetLamp(-6, -i * 10);
                createStreetLamp(6, -i * 10);
            }

            // Traffic signs and urban details
            for (let i = 0; i < 8; i++) {
                if (Math.random() > 0.5) {
                    createTrafficSign(-7, -i * 12 - 5);
                    createTrafficSign(7, -i * 12 - 5);
                }
            }
        }

        function createRealisticBuilding(x, z, side) {
            const buildingGroup = new THREE.Group();
            
            // Building dimensions
            const width = 4 + Math.random() * 3;
            const depth = 4 + Math.random() * 3;
            const height = 8 + Math.random() * 12;
            
            // Main building structure
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create building materials with windows
            const buildingMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.2, 0.3 + Math.random() * 0.4)
            });
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2 - 1; // Ground level
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows
            const windowsPerFloor = Math.floor(width / 1.5);
            const floors = Math.floor(height / 3);
            
            for (let floor = 0; floor < floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    // Window facing the street
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const isLit = Math.random() > 0.4;
                    const windowMaterial = new THREE.MeshLambertMaterial({ 
                        color: isLit ? 0xFFFF88 : 0x222244,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    const windowX = -width/2 + 0.7 + w * 1.5;
                    const windowY = floor * 3 + 1.5;
                    const windowZ = side === 'left' ? depth/2 + 0.01 : -depth/2 - 0.01;
                    
                    window.position.set(windowX, windowY, windowZ);
                    if (side === 'right') window.rotation.y = Math.PI;
                    
                    buildingGroup.add(window);
                }
            }

            // Rooftop details
            if (Math.random() > 0.6) {
                // Air conditioning units
                const acGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const acMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const ac = new THREE.Mesh(acGeometry, acMaterial);
                ac.position.set(0, height/2 + 0.25, 0);
                ac.castShadow = true;
                buildingGroup.add(ac);
            }

            if (Math.random() > 0.7) {
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0, height/2 + 1, 0);
                buildingGroup.add(antenna);
            }

            buildingGroup.position.set(x, 0, z);
            buildingGroup.userData = { 
                type: 'building', 
                initialZ: z,
                parallaxSpeed: 0.7 + Math.random() * 0.2 // 70-90% of game speed
            };
            scene.add(buildingGroup);
            environmentObjects.buildings.push(buildingGroup);
        }

        function createStreetLamp(x, z) {
            const lampGroup = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1;
            pole.castShadow = true;
            lampGroup.add(pole);
            
            // Light fixture
            const lightGeometry = new THREE.SphereGeometry(0.3);
            const lightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFF88,
                emissive: 0x444400
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = 3;
            lampGroup.add(light);
            
            // Add point light
            const pointLight = new THREE.PointLight(0xFFFF88, 0.5, 10);
            pointLight.position.y = 3;
            lampGroup.add(pointLight);
            
            lampGroup.position.set(x, 0, z);
            lampGroup.userData = { 
                type: 'streetLamp', 
                initialZ: z,
                parallaxSpeed: 0.85 // 85% of game speed
            };
            scene.add(lampGroup);
            environmentObjects.streetLamps.push(lampGroup);
        }

        function createTrafficSign(x, z) {
            const signGroup = new THREE.Group();
            
            // Sign post
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.25;
            signGroup.add(post);
            
            // Sign board
            const signGeometry = new THREE.PlaneGeometry(1, 1);
            const signMaterial = new THREE.MeshLambertMaterial({ 
                color: Math.random() > 0.5 ? 0xFF4444 : 0x4444FF
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.y = 2;
            sign.rotation.y = x < 0 ? Math.PI/4 : -Math.PI/4;
            signGroup.add(sign);
            
            signGroup.position.set(x, 0, z);
            signGroup.userData = { 
                type: 'trafficSign', 
                initialZ: z,
                parallaxSpeed: 0.8 // 80% of game speed
            };
            scene.add(signGroup);
            environmentObjects.trafficSigns.push(signGroup);
        }

        function createObstacle(type, lane, z) {
            const obstacleGroup = new THREE.Group();
            obstacleGroup.position.set(LANE_POSITIONS[lane], 0, z);
            
            let obstacleGeometry, obstacleMaterial, height;
            
            switch (type) {
                case 'lowbarrier':
                    // Niedrige Barriere - muss übersprungen werden
                    obstacleGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35
                    });
                    height = 0.8;
                    break;
                case 'highbarrier':
                    // Hohe Barriere - muss unterduckt werden
                    obstacleGeometry = new THREE.BoxGeometry(1.8, 0.4, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B0000
                    });
                    height = 0.4;
                    break;
                case 'spikes':
                    // Stacheln - überspringen oder ducken
                    obstacleGeometry = new THREE.ConeGeometry(0.25, 0.6, 6);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF4500,
                        emissive: 0x221100
                    });
                    height = 0.6;
                    break;
                case 'jumpblock':
                    // Block zum Überspringen - Concrete texture
                    obstacleGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B8B8B
                    });
                    height = 1.2;
                    // Add concrete details
                    const detailGeom = new THREE.BoxGeometry(0.1, 0.1, 1.3);
                    const detailMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    for (let i = 0; i < 4; i++) {
                        const detail = new THREE.Mesh(detailGeom, detailMat);
                        detail.position.set(
                            (i % 2 - 0.5) * 1.2, 
                            (Math.floor(i / 2) - 0.5) * 1.2, 
                            0
                        );
                        detail.castShadow = true;
                        obstacleGroup.add(detail);
                    }
                    break;
                case 'duckbeam':
                    // Balken zum Unterducken - Metal beam
                    obstacleGeometry = new THREE.BoxGeometry(2.2, 0.3, 0.8);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x4682B4
                    });
                    height = 0.3;
                    // Add support struts
                    const strutGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.8);
                    const strutMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
                    for (let i = 0; i < 2; i++) {
                        const strut = new THREE.Mesh(strutGeom, strutMat);
                        strut.position.set((i - 0.5) * 1.5, -0.75, 0);
                        strut.castShadow = true;
                        obstacleGroup.add(strut);
                    }
                    break;
                case 'hurdleset':
                    // Hürden-Set - mehrere niedrige Hürden
                    for (let i = 0; i < 3; i++) {
                        const hurdleGeometry = new THREE.BoxGeometry(1.4, 0.7, 0.2);
                        const hurdleMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22
                        });
                        const hurdle = new THREE.Mesh(hurdleGeometry, hurdleMaterial);
                        hurdle.position.set(0, 0.35, -0.5 + i * 0.5);
                        hurdle.castShadow = true;
                        hurdle.receiveShadow = true;
                        obstacleGroup.add(hurdle);
                        
                        // Add warning stripes
                        const stripeGeom = new THREE.PlaneGeometry(1.5, 0.1);
                        const stripeMat = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00,
                            transparent: true,
                            opacity: 0.8
                        });
                        const stripe = new THREE.Mesh(stripeGeom, stripeMat);
                        stripe.position.set(0, 0.6, -0.5 + i * 0.5 + 0.11);
                        obstacleGroup.add(stripe);
                    }
                    height = 0.7;
                    break;
                case 'wallgap':
                    // Wand mit Lücke zum Ducken - Industrial wall
                    const wallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090
                    });
                    
                    const wallLeft = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallLeft.position.set(-0.5, 1.25, 0);
                    wallLeft.castShadow = true;
                    wallLeft.receiveShadow = true;
                    obstacleGroup.add(wallLeft);
                    
                    const wallRight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallRight.position.set(0.5, 1.25, 0);
                    wallRight.castShadow = true;
                    wallRight.receiveShadow = true;
                    obstacleGroup.add(wallRight);
                    
                    const wallTop = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.8, 0.4),
                        wallMaterial
                    );
                    wallTop.position.set(0, 2.1, 0);
                    wallTop.castShadow = true;
                    wallTop.receiveShadow = true;
                    obstacleGroup.add(wallTop);
                    
                    // Add hazard warning lights
                    const lightGeom = new THREE.SphereGeometry(0.08);
                    const lightMat = new THREE.MeshLambertMaterial({ 
                        color: 0xFF0000,
                        emissive: 0x440000
                    });
                    const warningLight = new THREE.Mesh(lightGeom, lightMat);
                    warningLight.position.set(0, 1.3, 0.25);
                    obstacleGroup.add(warningLight);
                    
                    height = 1.3; // Höhe der Lücke
                    break;
                    
                case 'rotatingblade':
                    // NEW: Rotating blade obstacle
                    const bladeGroup = new THREE.Group();
                    
                    // Central hub
                    const hubGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4);
                    const hubMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                    hub.position.y = 1;
                    bladeGroup.add(hub);
                    
                    // Rotating blades
                    for (let i = 0; i < 3; i++) {
                        const bladeGeometry = new THREE.BoxGeometry(2, 0.1, 0.2);
                        const bladeMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B0000,
                            emissive: 0x220000
                        });
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.y = 1;
                        blade.rotation.y = (i * Math.PI * 2) / 3;
                        blade.castShadow = true;
                        bladeGroup.add(blade);
                    }
                    
                    // Add warning lights
                    for (let j = 0; j < 2; j++) {
                        const warnLight = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06),
                            new THREE.MeshLambertMaterial({ 
                                color: 0xFF0000,
                                emissive: 0x330000
                            })
                        );
                        warnLight.position.set(j === 0 ? -1.2 : 1.2, 1.5, 0);
                        bladeGroup.add(warnLight);
                    }
                    
                    obstacleGroup.add(bladeGroup);
                    height = 2;
                    break;
                    
                case 'swinginghammer':
                    // NEW: Swinging hammer obstacle
                    const hammerGroup = new THREE.Group();
                    
                    // Support structure
                    const supportGeometry = new THREE.BoxGeometry(0.2, 3, 0.2);
                    const supportMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const support = new THREE.Mesh(supportGeometry, supportMaterial);
                    support.position.y = 1.5;
                    support.castShadow = true;
                    hammerGroup.add(support);
                    
                    // Swinging arm
                    const armGroup = new THREE.Group();
                    const armGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.y = -0.75;
                    arm.castShadow = true;
                    armGroup.add(arm);
                    
                    // Hammer head
                    const hammerGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
                    const hammerMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hammerHead = new THREE.Mesh(hammerGeometry, hammerMaterial);
                    hammerHead.position.y = -1.4;
                    hammerHead.castShadow = true;
                    armGroup.add(hammerHead);
                    
                    armGroup.position.y = 3;
                    hammerGroup.add(armGroup);
                    obstacleGroup.add(hammerGroup);
                    height = 1.8;
                    break;
                    
                case 'movingwall':
                    // NEW: Side-to-side moving wall
                    const movingWallGeometry = new THREE.BoxGeometry(0.3, 2, 1);
                    const movingWallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090,
                        transparent: true,
                        opacity: 0.9
                    });
                    const movingWall = new THREE.Mesh(movingWallGeometry, movingWallMaterial);
                    movingWall.position.y = 1;
                    movingWall.castShadow = true;
                    
                    // Add warning stripes
                    for (let k = 0; k < 4; k++) {
                        const stripeGeometry = new THREE.PlaneGeometry(0.35, 0.2);
                        const stripeMaterial = new THREE.MeshLambertMaterial({ 
                            color: k % 2 === 0 ? 0xFFFF00 : 0xFF0000
                        });
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.set(0.16, 0.5 + k * 0.4, 0);
                        movingWall.add(stripe);
                    }
                    
                    obstacleGroup.add(movingWall);
                    height = 2;
                    break;
                    
                case 'bouncingball':
                    // NEW: Bouncing ball obstacle - bounces up and down
                    const ballGroup = new THREE.Group();
                    
                    // Main bouncing ball
                    const ballGeometry = new THREE.SphereGeometry(0.6);
                    const ballMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35,
                        emissive: 0x331100
                    });
                    const bouncingBall = new THREE.Mesh(ballGeometry, ballMaterial);
                    bouncingBall.position.y = 1.5; // Starting height
                    bouncingBall.castShadow = true;
                    ballGroup.add(bouncingBall);
                    
                    // Shadow indicator on ground
                    const shadowGeometry = new THREE.CircleGeometry(0.4);
                    const shadowMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.3
                    });
                    const ballShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
                    ballShadow.rotation.x = -Math.PI / 2;
                    ballShadow.position.y = 0.01; // Just above ground
                    ballGroup.add(ballShadow);
                    
                    // Warning ring around bounce area
                    const ringGeometry = new THREE.RingGeometry(0.8, 1.0);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 0.6
                    });
                    const warningRing = new THREE.Mesh(ringGeometry, ringMaterial);
                    warningRing.rotation.x = -Math.PI / 2;
                    warningRing.position.y = 0.02;
                    ballGroup.add(warningRing);
                    
                    obstacleGroup.add(ballGroup);
                    height = 3; // Max bounce height
                    break;
                    
                case 'spinninglaser':
                    // NEW: Spinning laser beam obstacle
                    const laserGroup = new THREE.Group();
                    
                    // Central hub
                    const laserHubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6);
                    const laserHubMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x333333,
                        emissive: 0x110011
                    });
                    const laserHub = new THREE.Mesh(laserHubGeometry, laserHubMaterial);
                    laserHub.position.y = 1.2;
                    laserHub.castShadow = true;
                    laserGroup.add(laserHub);
                    
                    // Spinning laser beam (multiple segments for effect)
                    const laserBeamGroup = new THREE.Group();
                    for (let i = 0; i < 2; i++) {
                        const beamGeometry = new THREE.BoxGeometry(3, 0.1, 0.1);
                        const beamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0044,
                            emissive: 0x660022,
                            transparent: true,
                            opacity: 0.8
                        });
                        const laserBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                        laserBeam.position.y = 1.2;
                        laserBeam.rotation.y = i * Math.PI; // 180 degrees apart
                        laserBeam.castShadow = true;
                        laserBeamGroup.add(laserBeam);
                        
                        // Add glowing effect with smaller inner beam
                        const innerBeamGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
                        const innerBeamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFFFF,
                            emissive: 0xFF0044
                        });
                        const innerBeam = new THREE.Mesh(innerBeamGeometry, innerBeamMaterial);
                        innerBeam.position.copy(laserBeam.position);
                        innerBeam.rotation.copy(laserBeam.rotation);
                        laserBeamGroup.add(innerBeam);
                    }
                    
                    laserGroup.add(laserBeamGroup);
                    
                    // Warning lights at corners
                    for (let j = 0; j < 4; j++) {
                        const angle = (j * Math.PI) / 2;
                        const lightGeometry = new THREE.SphereGeometry(0.08);
                        const lightMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0000,
                            emissive: 0x440000
                        });
                        const warningLight = new THREE.Mesh(lightGeometry, lightMaterial);
                        warningLight.position.set(
                            Math.cos(angle) * 1.8,
                            0.2,
                            Math.sin(angle) * 1.8
                        );
                        laserGroup.add(warningLight);
                    }
                    
                    obstacleGroup.add(laserGroup);
                    height = 1.4; // Laser height
                    break;
            }
            
            // Für einfache Hindernisse (nicht die komplexen oder neuen Typen)
            if (type !== 'hurdleset' && type !== 'wallgap' && 
                type !== 'rotatingblade' && type !== 'swinginghammer' && type !== 'movingwall' &&
                type !== 'bouncingball' && type !== 'spinninglaser') {
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.castShadow = true;
                
                if (type === 'spikes') {
                    obstacle.position.y = height / 2;
                } else if (type === 'duckbeam') {
                    obstacle.position.y = 1.4; // FIXED: Niedriger positioniert für echtes Ducken
                } else if (type === 'highbarrier') {
                    obstacle.position.y = 1.4; // FIXED: Niedriger positioniert für echtes Ducken
                } else {
                    obstacle.position.y = height / 2;
                }
                
                obstacleGroup.add(obstacle);
            }
            
            scene.add(obstacleGroup);
            
            // Enhanced obstacle data with animation properties
            const obstacleData = {
                mesh: obstacleGroup,
                type: type,
                lane: lane,
                z: z,
                height: height,
                animationTime: 0,
                rotationSpeed: 0,
                swingAmplitude: 0,
                swingSpeed: 0,
                movementRange: 0,
                movementSpeed: 0,
                initialX: LANE_POSITIONS[lane]
            };
            
            // Set animation properties for moving obstacles
            switch (type) {
                case 'rotatingblade':
                    obstacleData.rotationSpeed = 3 + Math.random() * 2; // Random rotation speed
                    break;
                case 'swinginghammer':
                    obstacleData.swingAmplitude = Math.PI / 3; // 60 degree swing
                    obstacleData.swingSpeed = 2 + Math.random(); // Random swing speed
                    break;
                case 'movingwall':
                    obstacleData.movementRange = 3; // Movement range across lanes
                    obstacleData.movementSpeed = 1.5 + Math.random() * 0.5;
                    break;
                case 'bouncingball':
                    obstacleData.bounceHeight = 2.5; // Max bounce height
                    obstacleData.bounceSpeed = 3 + Math.random() * 1.5; // Bounce frequency
                    break;
                case 'spinninglaser':
                    obstacleData.rotationSpeed = 2 + Math.random() * 1.5; // Laser spin speed
                    obstacleData.pulseSpeed = 4; // Warning light pulse
                    break;
            }
            
            obstacles.push(obstacleData);
        }

        async function startGameInternal() {
            // Resume audio context
            audioManager.resume();
            
            // Start background music
            audioManager.startBackgroundMusic();
            
            // Start ambient city sounds
            if (!ambientStarted) {
                audioManager.play('ambient');
                ambientStarted = true;
            }
            
            gameState.isPlaying = true;
            gameState.isGameOver = false;
            gameState.isVictory = false;
            gameState.score = 0;
            gameState.speed = gameState.baseSpeed;
            gameState.lives = 3;
            gameState.timeRemaining = gameState.gameTime;
            gameState.gameStartTime = Date.now();
            gameState.playerLane = 1;
            gameState.playerAction = 'running';
            gameState.playerY = 0;
            gameState.jumpVelocity = 0;
            gameState.invulnerable = false;
            gameState.invulnerabilityTime = 0;
            gameState.timeScale = 1.0;
            gameState.cameraShakeIntensity = 0;
            gameState.slowMotionActive = false;
            
            // BUGFIX: Reset milestone tracking to prevent constant confetti
            gameState.lastMilestone = 0;
            gameState.milestoneReached = 0;
            gameState.totalDistance = 0;
            
            // BUGFIX: Initialize centralized score system
            gameState.lastScoreUpdate = performance.now();
            gameState.scoreQueue = 0;
            gameState.lastDistanceScore = performance.now();
            
            // Reset all multipliers and combos
            gameState.comboMultiplier = 1;
            gameState.nearMissMultiplier = 1;
            gameState.skillMultiplier = 1;
            gameState.scoreMultiplier = 1;
            gameState.nearMissStreak = 0;
            gameState.kiwiCombo = 0;
            
            // Reset collectible system with debug logging
            console.log('🔄 RESETTING COLLECTIBLE COUNTERS');
            console.log(`   Before reset - Kiwis: ${gameState.collectedKiwis}, Broccolis: ${gameState.collectedBroccolis}`);
            
            gameState.collectedKiwis = 0;
            gameState.collectedBroccolis = 0;
            gameState.totalCollectibles = 0;
            gameState.collectionBonusAwarded = {
                fiveOfOne: false,
                allOfOne: false, 
                allThirtySeven: false,
                broccoliMaster: false,
                veggieChampion: false
            };
            
            console.log(`   After reset - Kiwis: ${gameState.collectedKiwis}, Broccolis: ${gameState.collectedBroccolis}`);
            
            // Force immediate UI update
            updateKiwiUI();
            
            // Clear obstacles and collectibles
            obstacles.forEach(obs => scene.remove(obs.mesh));
            obstacles = [];
            
            // Clear existing collectibles
            gameState.kiwis.forEach(kiwi => scene.remove(kiwi.mesh));
            gameState.kiwis = [];
            gameState.broccolis.forEach(broccoli => scene.remove(broccoli.mesh));
            gameState.broccolis = [];
            
            // Start sound
            audioManager.play('powerup');
            
            document.getElementById('menu').style.display = 'none';
            updateUI();
            
            // Extra check to ensure UI is properly updated at game start
            setTimeout(() => {
                updateKiwiUI();
                console.log('✅ Game started - UI updated after delay');
            }, 100);
        }

        function endGame() {
            gameState.isPlaying = false;
            gameState.isGameOver = true;
            
            // Stop background music and ambient sounds
            audioManager.stopBackgroundMusic();
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = Math.max(0, gameState.gameTime - Math.ceil(gameState.timeRemaining));
            
            // Check for highscore
            console.log('Game ended. Checking highscore:', currentScore, 'isHighscore:', highscoreManager.isHighscore(currentScore));
            if (highscoreManager.isHighscore(currentScore)) {
                console.log('New highscore achieved! Showing name input dialog.');
                showNameInputDialog(false);
            } else {
                showGameOverMenu(false);
            }
        }

        function victoryGame() {
            gameState.isPlaying = false;
            gameState.isVictory = true;
            
            // Stop ambient sounds
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = 60; // Full 60 seconds survived!
            
            // Victory celebration!
            audioManager.play('powerup');
            
            // Fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createParticleEffect(
                        new THREE.Vector3((Math.random() - 0.5) * 10, 5, -5),
                        [0xFF6B35, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFEDE57][i],
                        'success'
                    );
                }, i * 300);
            }
            
            // Always show name input for victory (it's always a highscore achievement!)
            showNameInputDialog(true);
        }

        function updateUI() {
            // Animate score changes
            const scoreElement = document.getElementById('score');
            const currentDisplayScore = parseInt(scoreElement.textContent) || 0;
            const targetScore = Math.floor(gameState.score);
            
            if (targetScore > currentDisplayScore) {
                scoreElement.classList.add('ui-bounce');
                setTimeout(() => scoreElement.classList.remove('ui-bounce'), 500);
            }
            scoreElement.textContent = targetScore;
            
            // Speed display with color coding
            const speedElement = document.getElementById('speed');
            speedElement.textContent = Math.floor(gameState.speed * 1000);
            const speedRatio = gameState.speed / gameState.maxSpeed;
            if (speedRatio > 0.8) {
                speedElement.style.color = '#FF4444';
            } else if (speedRatio > 0.6) {
                speedElement.style.color = '#FFA500';
            } else if (speedRatio > 0.4) {
                speedElement.style.color = '#FFD700';
            } else {
                speedElement.style.color = 'white';
            }
            
            // Lives with pulse animation on change
            const livesElement = document.getElementById('lives');
            const currentLives = parseInt(livesElement.textContent) || 3;
            if (gameState.lives < currentLives) {
                livesElement.classList.add('ui-bounce');
                livesElement.style.color = '#FF4444';
                setTimeout(() => {
                    livesElement.classList.remove('ui-bounce');
                    livesElement.style.color = 'white';
                }, 1000);
            }
            livesElement.textContent = gameState.lives;
            
            // Update timer with visual warnings
            const timeElement = document.getElementById('timeRemaining');
            const timerElement = document.getElementById('timer');
            timeElement.textContent = Math.max(0, Math.ceil(gameState.timeRemaining));
            
            // Timer visual states with audio warnings
            const timeLeft = Math.ceil(gameState.timeRemaining);
            if (timeLeft <= 10) {
                timerElement.className = 'timer-critical';
                // Final countdown beeps
                if (timeLeft <= 5 && timeLeft > 0 && Math.ceil(gameState.timeRemaining) !== Math.ceil(gameState.timeRemaining + 0.016)) {
                    audioManager.play('coin'); // High pitched beep
                }
            } else if (timeLeft <= 20) {
                timerElement.className = 'timer-warning';
                // Warning at 20 seconds
                if (timeLeft === 20 && Math.abs(gameState.timeRemaining - 20) < 0.1) {
                    audioManager.play('duck'); // Warning sound
                }
            } else {
                timerElement.className = '';
            }
            
            // Update multiplier display with glow effect
            const multiplierElement = document.getElementById('currentMultiplier');
            if (multiplierElement) {
                const newMultiplier = gameState.scoreMultiplier.toFixed(1);
                if (parseFloat(newMultiplier) > 1.0) {
                    multiplierElement.parentElement.classList.add('ui-glow');
                } else {
                    multiplierElement.parentElement.classList.remove('ui-glow');
                }
                multiplierElement.textContent = newMultiplier;
            }
            
            // Update difficulty progress display
            updateDifficultyUI();
            
            // Update collectible counters
            updateKiwiUI();
        }

        function showNameInputDialog(isVictory) {
            const dialog = document.getElementById('nameInputDialog');
            const title = dialog.querySelector('h2');
            
            if (isVictory) {
                title.innerHTML = '🎉 VICTORY + HIGHSCORE! 🎉';
            } else {
                title.innerHTML = '🎉 Neuer Highscore! 🎉';
            }
            
            dialog.style.display = 'block';
            document.getElementById('playerNameInput').focus();
        }

        function showGameOverMenu(isVictory) {
            const menu = document.getElementById('menu');
            
            if (isVictory) {
                menu.innerHTML = `
                    <h1>🎉 VICTORY! 🎉</h1>
                    <h2>Du hast 60 Sekunden überlebt!</h2>
                    <p>Final Score: ${currentScore}</p>
                    <p>Du bist ein Subway Runner Champion! 🏆</p>
                    <button onclick="startGame()">🎮 Nochmal versuchen</button>
                `;
            } else {
                const nextLevel = Math.min(gameState.currentLevel + 1, 10);
                menu.innerHTML = `
                    <h1>Game Over!</h1>
                    <p>Final Score: ${currentScore}</p>
                    <p>Zeit überlebt: ${currentSurvivalTime}s</p>
                    <p>Level ${gameState.currentLevel} nicht geschafft!</p>
                    <button onclick="startGame()">🎮 Nochmal spielen</button>
                    <button onclick="testLevel(${nextLevel}); startGame();" style="margin-left: 10px; background: #ff6600;">🚀 Nächstes Level (${nextLevel})</button>
                `;
            }
            
            menu.style.display = 'block';
        }

        async function submitHighscoreInternal() {
            const nameInput = document.getElementById('playerNameInput');
            let playerName = nameInput.value.trim();
            
            if (!playerName) {
                playerName = 'Anonymous';
            }
            
            // Disable button while submitting
            const submitBtn = document.querySelector('#nameInputDialog button');
            submitBtn.disabled = true;
            submitBtn.textContent = '💾 Speichere...';
            
            try {
                await highscoreManager.submitScore(
                    playerName, 
                    currentScore, 
                    currentSurvivalTime, 
                    gameState.isVictory
                );
                
                // Hide dialog and show game over menu
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
                
                // Clear input for next time
                nameInput.value = '';
                
            } catch (error) {
                console.error('Error submitting highscore:', error);
                // Still hide dialog and continue
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
            }
            
            // Re-enable button
            submitBtn.disabled = false;
            submitBtn.textContent = '💾 Speichern';
        }

        function skipHighscoreInternal() {
            document.getElementById('nameInputDialog').style.display = 'none';
            showGameOverMenu(gameState.isVictory);
            document.getElementById('playerNameInput').value = '';
        }

        // Handle Enter key in name input
        document.addEventListener('DOMContentLoaded', () => {
            const nameInput = document.getElementById('playerNameInput');
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitHighscoreInternal();
                }
            });
        });
        
        // Initialize UI counters on page load
        setTimeout(() => {
            updateKiwiUI();
            console.log('✅ Initial UI update completed');
        }, 100);
        
        // Debug functions for testing collectible counters
        window.debugCollectibles = function() {
            console.log('=== COLLECTIBLE DEBUG INFO ===');
            console.log(`Game State:`, {
                collectedKiwis: gameState.collectedKiwis,
                collectedBroccolis: gameState.collectedBroccolis,
                totalKiwis: gameState.totalKiwis,
                totalBroccolis: gameState.totalBroccolis,
                totalCollectibles: gameState.totalCollectibles,
                activeKiwis: gameState.kiwis.length,
                activeBroccolis: gameState.broccolis.length,
                isPlaying: gameState.isPlaying
            });
            
            console.log('UI Elements:', {
                kiwiCount: document.getElementById('kiwiCount')?.textContent,
                broccoliCount: document.getElementById('broccoliCount')?.textContent,
                kiwiElement: document.getElementById('kiwiCount'),
                broccoliElement: document.getElementById('broccoliCount')
            });
            
            // Force UI update
            updateKiwiUI();
            console.log('Force updated UI - check values now');
        };
        
        // Function to manually reset and test counters
        window.testCollectibles = function() {
            console.log('Testing collectible system...');
            
            // Reset counters
            gameState.collectedKiwis = 0;
            gameState.collectedBroccolis = 0;
            updateKiwiUI();
            
            console.log('Reset counters to 0');
            
            // Simulate collecting
            setTimeout(() => {
                gameState.collectedKiwis = 5;
                gameState.collectedBroccolis = 3;
                updateKiwiUI();
                console.log('Set test values: Kiwis=5, Broccolis=3');
            }, 1000);
        };

        function handleKeyDown(event) {
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    event.preventDefault();
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        
                        // Track lane movement for skill combos
                        trackPlayerMove('left', gameState.playerLane);
                    }
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    event.preventDefault();
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        
                        // Track lane movement for skill combos
                        trackPlayerMove('right', gameState.playerLane);
                    }
                    break;
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time // Höherer Sprung
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        
                        // Audio & Visual Feedback with speed dynamics
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                        audioManager.resume(); // Resume audio context if needed
                        
                        // Sprung-Partikel (nur bei erfolgreichem Obstacle-Avoidance)
                        // Removed automatic jump particles - only success particles when avoiding obstacles
                        
                        // Track jump for skill combos
                        trackPlayerMove('jumping');
                    }
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                        
                        // Track duck for skill combos
                        trackPlayerMove('ducking');
                    }
                    break;
            }
        }

        function handleKeyUp(event) {
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    gameState.playerAction = 'running';
                    break;
            }
        }

        function createParticleEffect(position, color, type) {
            let particleCount, spreadRange, speed, size;
            
            switch (type) {
                case 'success':
                    particleCount = 25;
                    spreadRange = 3;
                    speed = 4;
                    size = 0.06;
                    break;
                case 'explosion':
                    particleCount = 40;
                    spreadRange = 5;
                    speed = 6;
                    size = 0.08;
                    break;
                case 'jump':
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.04;
                    break;
                case 'landing':
                    particleCount = 20;
                    spreadRange = 3;
                    speed = 2;
                    size = 0.05;
                    break;
                case 'nearMiss':
                    particleCount = 10;
                    spreadRange = 1.5;
                    speed = 2;
                    size = 0.03;
                    break;
                case 'collision':
                    particleCount = 30;
                    spreadRange = 4;
                    speed = 5;
                    size = 0.06;
                    break;
                case 'spark':
                    particleCount = 8;
                    spreadRange = 1;
                    speed = 6;
                    size = 0.02;
                    break;
                case 'dust':
                    particleCount = 12;
                    spreadRange = 2.5;
                    speed = 1;
                    size = 0.04;
                    break;
                case 'duckConfetti':
                    particleCount = 20;
                    spreadRange = 3;
                    speed = 4;
                    size = 0.07;
                    break;
                default:
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.05;
            }
            
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 6, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true
                    })
                );
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spreadRange,
                    Math.random() * speed + 0.5,
                    (Math.random() - 0.5) * spreadRange
                );
                particle.life = 1.0;
                particle.originalSize = size;
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Enhanced particle animation
            const animateParticles = () => {
                particles.children.forEach((particle, index) => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(gameState.timeScale));
                    particle.velocity.y -= 0.15 * gameState.timeScale; // Gravity
                    particle.life -= 0.015 * gameState.timeScale;
                    
                    // Fancy effects based on type
                    if (type === 'explosion') {
                        particle.material.opacity = particle.life * 0.8;
                        particle.scale.setScalar(1 + (1 - particle.life) * 2);
                        particle.rotation.x += 0.1 * gameState.timeScale;
                        particle.rotation.y += 0.1 * gameState.timeScale;
                    } else if (type === 'success') {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(1 + Math.sin(Date.now() * 0.01 + index) * 0.3);
                    } else if (type === 'duckConfetti') {
                        // Special duck confetti: sparkly falling effect with rotation
                        particle.material.opacity = particle.life * 0.9;
                        particle.scale.setScalar(1 + Math.sin(Date.now() * 0.02 + index) * 0.4);
                        particle.rotation.x += 0.15 * gameState.timeScale;
                        particle.rotation.y += 0.2 * gameState.timeScale;
                        particle.rotation.z += 0.1 * gameState.timeScale;
                        // Floating effect: less gravity for confetti
                        particle.velocity.y += 0.05 * gameState.timeScale; // Counter some gravity
                    } else {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(particle.life);
                    }
                    
                    if (particle.life <= 0) {
                        particles.remove(particle);
                    }
                });
                
                if (particles.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }

        function startSlowMotion(duration = 800) {
            gameState.slowMotionActive = true;
            gameState.timeScale = 0.3;
            
            // Camera zoom effect
            const originalFov = camera.fov;
            camera.fov = originalFov * 0.8;
            camera.updateProjectionMatrix();
            
            setTimeout(() => {
                gameState.slowMotionActive = false;
                gameState.timeScale = 1.0;
                camera.fov = originalFov;
                camera.updateProjectionMatrix();
            }, duration);
        }

        function screenShake(intensity = 0.1, duration = 300) {
            gameState.cameraShakeIntensity = intensity;
            
            setTimeout(() => {
                gameState.cameraShakeIntensity = 0;
            }, duration);
        }

        function cameraZoomEffect(targetZoom = 1.2, duration = 500) {
            const originalFov = camera.fov;
            const targetFov = originalFov / targetZoom;
            
            const startTime = Date.now();
            const zoomAnimation = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.5) {
                    // Zoom in
                    const zoomProgress = progress * 2;
                    camera.fov = originalFov - (originalFov - targetFov) * zoomProgress;
                } else {
                    // Zoom out
                    const zoomProgress = (progress - 0.5) * 2;
                    camera.fov = targetFov + (originalFov - targetFov) * zoomProgress;
                }
                
                camera.updateProjectionMatrix();
                
                if (progress < 1) {
                    requestAnimationFrame(zoomAnimation);
                }
            };
            zoomAnimation();
        }

        function createExplosionRing(position, color = 0xFF6644) {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            ring.position.copy(position);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            // Animate ring expansion
            const animateRing = () => {
                ring.scale.x += 0.3;
                ring.scale.y += 0.3;
                ring.material.opacity -= 0.02;
                
                if (ring.material.opacity > 0) {
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ring);
                }
            };
            animateRing();
        }

        // Enhanced collision detection with precise bounding boxes and near-miss system
        function checkCollisions() {
            if (gameState.invulnerable) return;
            
            // Player bounding box calculation
            const playerBBox = calculatePlayerBoundingBox();
            
            obstacles.forEach((obstacle, index) => {
                // Calculate obstacle bounding box
                const obstacleBBox = calculateObstacleBoundingBox(obstacle);
                
                // Check for actual collision using 3D bounding box intersection
                const isColliding = boundingBoxIntersection(playerBBox, obstacleBBox);
                
                // ENHANCED DUCK COLLISION DETECTION
                if (obstacle.type === 'duckbeam' || obstacle.type === 'highbarrier' || obstacle.type === 'wallgap') {
                    console.log(`🔍 DUCK OBSTACLE CHECK:
                        Type: ${obstacle.type}
                        Action: ${gameState.playerAction}
                        Player Y: ${gameState.playerY}
                        Player BBox: min(${playerBBox.min.x.toFixed(2)}, ${playerBBox.min.y.toFixed(2)}, ${playerBBox.min.z.toFixed(2)}) max(${playerBBox.max.x.toFixed(2)}, ${playerBBox.max.y.toFixed(2)}, ${playerBBox.max.z.toFixed(2)})
                        Obstacle BBox: min(${obstacleBBox.min.x.toFixed(2)}, ${obstacleBBox.min.y.toFixed(2)}, ${obstacleBBox.min.z.toFixed(2)}) max(${obstacleBBox.max.x.toFixed(2)}, ${obstacleBBox.max.y.toFixed(2)}, ${obstacleBBox.max.z.toFixed(2)})
                        isColliding: ${isColliding}`);
                    
                    // FORCE collision detection for duck obstacles using simplified logic
                    const playerX = LANE_POSITIONS[gameState.playerLane];
                    const obstacleX = obstacle.mesh.position.x;
                    const obstacleZ = obstacle.mesh.position.z;
                    
                    // Check if player is in same lane (X axis)
                    const inSameLane = Math.abs(playerX - obstacleX) < 1.0;
                    
                    // Check if obstacle is close enough in Z direction (approaching or passing)
                    const inCollisionZone = obstacleZ > -2 && obstacleZ < 2;
                    
                    // Check if player is too high (not ducking properly)
                    // BUGFIX: Reduced duck height from 0.6 to 0.4 for better collision avoidance
                    const playerHeight = gameState.playerAction === 'ducking' ? 0.4 : 1.5;
                    let obstacleHeight = 1.4; // Default duck obstacles height
                    
                    // Adjust for wallgap (gap bottom is at 1.3)
                    // FIXED: For wallgap, the obstacleHeight should be the bottom of the gap (1.3), not the gap size
                    // Player must be below this height to pass through
                    if (obstacle.type === 'wallgap') {
                        obstacleHeight = 1.3;
                    }
                    
                    // FIXED: Player needs to duck if their height exceeds the obstacle clearance height
                    const needsToDuck = playerHeight > obstacleHeight; // Must duck to fit under obstacle
                    
                    console.log(`🎯 Duck Logic: type=${obstacle.type}, inSameLane=${inSameLane}, inCollisionZone=${inCollisionZone}, needsToDuck=${needsToDuck}, playerHeight=${playerHeight}, obstacleHeight=${obstacleHeight}`);
                    
                    if (inSameLane && inCollisionZone && needsToDuck) {
                        console.log(`💥 DUCK COLLISION TRIGGERED! Player failed to duck.`);
                        handleCollision(obstacle, obstacleBBox);
                        return; // Exit after collision
                    } else if (inSameLane && inCollisionZone && !needsToDuck) {
                        console.log(`✅ DUCK SUCCESS! Player ducked properly.`);
                        // Give bonus points for successful ducking (handled in avoidance logic)
                    }
                }
                
                // Near-miss detection (close but not colliding)
                const nearMissDistance = 0.3; // Units for near-miss threshold
                const isNearMiss = !isColliding && boundingBoxDistance(playerBBox, obstacleBBox) < nearMissDistance;
                
                if (isColliding) {
                    // Check if player can avoid this collision
                    let canAvoid = false;
                    let avoidanceType = '';
                    
                    // Enhanced avoidance logic with precise hitbox checking
                    switch (obstacle.type) {
                        case 'lowbarrier':
                        case 'jumpblock':
                        case 'hurdleset':
                            // Must be jumped - check if player is high enough to clear
                            if (gameState.playerAction === 'jumping' && 
                                playerBBox.min.y > obstacleBBox.max.y - 0.2) {
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'highbarrier':
                        case 'duckbeam':
                        case 'wallgap':
                            // CRITICAL FIX: Overhead obstacles require ducking to avoid collision
                            // Player can ONLY avoid collision if they are ducking AND low enough
                            if (gameState.playerAction === 'ducking' && 
                                playerBBox.max.y < obstacleBBox.min.y + 0.2) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else {
                                // FORCE collision if not ducking or not low enough
                                canAvoid = false;
                                console.log(`🚨 OVERHEAD COLLISION: Player must duck! action=${gameState.playerAction}, playerMaxY=${playerBBox.max.y}, obstacleMinY=${obstacleBBox.min.y}`);
                            }
                            console.log(`🎯 Overhead obstacle: action=${gameState.playerAction}, playerMaxY=${playerBBox.max.y}, obstacleMinY=${obstacleBBox.min.y}, canAvoid=${canAvoid}`);
                            break;
                            
                        case 'spikes':
                            // Flexible - can jump over or duck under
                            if ((gameState.playerAction === 'jumping' && playerBBox.min.y > obstacleBBox.max.y - 0.2) ||
                                (gameState.playerAction === 'ducking' && playerBBox.max.y < obstacleBBox.min.y + 0.2)) {
                                canAvoid = true;
                                avoidanceType = gameState.playerAction === 'jumping' ? 'jump' : 'duck';
                            }
                            break;
                            
                        case 'rotatingblade':
                            // Rotating blades - can only be ducked under
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 0.8) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'swinginghammer':
                            // Swinging hammer - timing-based avoidance
                            // Check if hammer is in safe position
                            const hammerAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                            const isSafePosition = Math.abs(hammerAngle) < obstacle.swingAmplitude * 0.3; // Safe zone
                            
                            if (isSafePosition) {
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && Math.abs(hammerAngle) > obstacle.swingAmplitude * 0.7) {
                                // Can duck under when hammer is at extreme positions
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'movingwall':
                            // Moving wall - must time movement or jump
                            const wallPosition = obstacle.mesh.position.x;
                            const playerPosition = LANE_POSITIONS[gameState.playerLane];
                            const wallDistance = Math.abs(wallPosition - playerPosition);
                            
                            if (wallDistance > 1.0) {
                                // Wall is far enough away
                                canAvoid = true;
                                avoidanceType = 'dodge';
                            } else if (gameState.playerAction === 'jumping' && playerBBox.min.y > 1.5) {
                                // Can jump over the wall
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'bouncingball':
                            // Bouncing ball - timing-based avoidance or ducking
                            const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                            
                            if (ballHeight < 0.8) {
                                // Ball is low - can run through
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && ballHeight > 1.5) {
                                // Ball is high, player is ducking
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else if (gameState.playerAction === 'jumping' && ballHeight < 1.2 && playerBBox.min.y > ballHeight + 0.3) {
                                // Ball is medium height, player jumps over
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'spinninglaser':
                            // Spinning laser - only ducking helps
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 1.1) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                    }
                    
                    if (canAvoid) {
                        // SUCCESSFUL AVOIDANCE! - ENHANCED SKILL SYSTEM
                        let bonusScore = 50;
                        
                        // Precision bonus - closer calls get more points
                        const precision = 1 - (boundingBoxDistance(playerBBox, obstacleBBox) / nearMissDistance);
                        bonusScore += Math.floor(precision * 25);
                        
                        if (avoidanceType === 'jump') bonusScore += 25; // Jump bonus
                        if (avoidanceType === 'duck') {
                            bonusScore += 30; // Duck bonus - slightly higher for skill
                            console.log(`🦆 DUCK BONUS AWARDED: +30 points for ${obstacle.type} obstacle avoidance!`);
                            // Show duck bonus feedback
                            showSkillCombo(30, `DUCK MASTER! 🦆`);
                            
                            // DUCK CONFETTI: Celebration particle effect for successful ducking
                            const duckConfettiPos = obstacle.mesh.position.clone();
                            duckConfettiPos.y += 2.0; // Above the obstacle
                            createParticleEffect(duckConfettiPos, 0x00FF88, 'duckConfetti'); // Green confetti
                        }
                        
                        // ==================== ADVANCED SKILL TRACKING ====================
                        
                        const currentTime = performance.now();
                        
                        // Track consecutive avoidances for combo system
                        if (currentTime - gameState.lastAvoidanceTime < 3000) { // 3 second window
                            gameState.consecutiveAvoidances++;
                        } else {
                            gameState.consecutiveAvoidances = 1;
                        }
                        gameState.lastAvoidanceTime = currentTime;
                        
                        // Record this move in sequence for combo detection
                        const currentMove = `${avoidanceType}_${gameState.playerLane}`;
                        gameState.moveSequence.push({
                            move: currentMove,
                            action: avoidanceType,
                            lane: gameState.playerLane,
                            time: currentTime,
                            precision: precision
                        });
                        
                        // Keep only last 5 moves for combo detection
                        if (gameState.moveSequence.length > 5) {
                            gameState.moveSequence.shift();
                        }
                        
                        // ==================== COMBO DETECTION & REWARDS ====================
                        
                        let skillBonus = 0;
                        let comboMessage = '';
                        
                        // RAPID SEQUENCE BONUS (quick consecutive moves)
                        if (gameState.consecutiveAvoidances >= 2) {
                            const timeSinceLastMove = currentTime - gameState.lastSkillTime;
                            if (timeSinceLastMove < 1500) { // Less than 1.5 seconds = rapid!
                                skillBonus += gameState.consecutiveAvoidances * 30;
                                comboMessage = `RAPID x${gameState.consecutiveAvoidances}!`;
                                
                                // Extra bonus for very fast sequences
                                if (timeSinceLastMove < 800) {
                                    skillBonus += 50;
                                    comboMessage = `LIGHTNING FAST x${gameState.consecutiveAvoidances}!`;
                                }
                            }
                        }
                        
                        // LANE SWITCHING COMBO (left-right-left sequences)
                        if (gameState.moveSequence.length >= 3) {
                            const lastThree = gameState.moveSequence.slice(-3);
                            const lanes = lastThree.map(m => m.lane);
                            const actions = lastThree.map(m => m.action);
                            
                            // Check for lane switching patterns
                            if (lanes[0] !== lanes[1] && lanes[1] !== lanes[2] && lanes[0] !== lanes[2]) {
                                // Perfect zigzag pattern!
                                skillBonus += 100;
                                comboMessage = 'ZIGZAG MASTER!';
                                
                                // Check if it includes different actions (jump + duck + lane switch)
                                const uniqueActions = [...new Set(actions)];
                                if (uniqueActions.length >= 2) {
                                    skillBonus += 75;
                                    comboMessage = 'MIXED STYLE COMBO!';
                                }
                            }
                        }
                        
                        // PERFECT TIMING BONUS (high precision sequences)
                        if (precision > 0.85) {
                            gameState.perfectTimingCount++;
                            if (gameState.perfectTimingCount >= 3) {
                                skillBonus += 150;
                                comboMessage = 'PERFECT TIMING STREAK!';
                                gameState.perfectTimingCount = 0; // Reset for next streak
                            }
                        } else {
                            gameState.perfectTimingCount = 0; // Reset on imperfect timing
                        }
                        
                        // HIGH DIFFICULTY OBSTACLE BONUS
                        const difficultyBonus = {
                            'rotatingblade': 40,
                            'swinginghammer': 50,
                            'movingwall': 45,
                            'bouncingball': 35,
                            'spinninglaser': 60
                        };
                        
                        if (difficultyBonus[obstacle.type]) {
                            skillBonus += difficultyBonus[obstacle.type];
                            if (!comboMessage) comboMessage = 'SKILL MOVE!';
                        }
                        
                        // SPEED-BASED DIFFICULTY MULTIPLIER
                        const speedRatio = gameState.speed / gameState.maxSpeed;
                        if (speedRatio > 0.7) { // High speed bonus
                            const speedMultiplier = 1 + speedRatio;
                            skillBonus = Math.floor(skillBonus * speedMultiplier);
                            bonusScore = Math.floor(bonusScore * speedMultiplier);
                            if (comboMessage) comboMessage += ' @HIGH SPEED!';
                        }
                        
                        // Apply skill combo multiplier
                        if (gameState.consecutiveAvoidances >= 3) {
                            gameState.skillMultiplier = Math.min(3, 1 + (gameState.consecutiveAvoidances - 2) * 0.5);
                            skillBonus = Math.floor(skillBonus * gameState.skillMultiplier);
                        }
                        
                        gameState.lastSkillTime = currentTime;
                        
                        // ==================== APPLY REWARDS ====================
                        
                        const totalBonus = bonusScore + skillBonus;
                        addScore(totalBonus, 'avoidance_bonus');
                        
                        // Show skill combo UI if we got a bonus
                        if (skillBonus > 0) {
                            showSkillCombo(skillBonus, comboMessage);
                        }
                        
                        // Enhanced audio feedback with precision
                        if (precision > 0.8) {
                            audioManager.play('success'); // Perfect avoidance
                        } else {
                            audioManager.playSpeedDependentSound('coin', gameState.speed / gameState.maxSpeed);
                        }
                        
                        // Spectacular success particle effects
                        const effectPos = obstacle.mesh.position.clone();
                        const effectColor = avoidanceType === 'jump' ? 0x00FF00 : 0x00FFFF;
                        
                        createParticleEffect(effectPos, effectColor, 'success');
                        
                        // Precision-based additional effects
                        if (precision > 0.8) {
                            // Perfect execution - extra sparkles
                            createParticleEffect(
                                effectPos.clone().add(new THREE.Vector3(0, 1, 0)),
                                0xFFD700,
                                'success'
                            );
                            // Mini camera zoom for perfect execution
                            cameraZoomEffect(1.1, 200);
                        }
                        
                        // Score popup with precision indicator
                        showScorePopup(bonusScore, effectPos, precision > 0.8 ? 'PERFECT!' : 'NICE!');
                        
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        
                    } else {
                        // COLLISION DETECTED!
                        handleCollision(obstacle, obstacleBBox);
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                    }
                    
                } else if (isNearMiss && obstacle.z > -1 && obstacle.z < 1) {
                    // NEAR MISS BONUS! (only when very close)
                    handleNearMiss(obstacle, playerBBox, obstacleBBox);
                }
            });
            
            // ==================== POWER-UP COLLISION DETECTION ====================
            
            gameState.powerUps.forEach((powerUp, index) => {
                // Larger collision box for large magnet
                const boxSize = powerUp.type === 'largeMagnet' ? 0.8 : 0.4;
                const powerUpBBox = {
                    min: {
                        x: powerUp.mesh.position.x - boxSize,
                        y: powerUp.mesh.position.y - boxSize,
                        z: powerUp.mesh.position.z - boxSize
                    },
                    max: {
                        x: powerUp.mesh.position.x + boxSize,
                        y: powerUp.mesh.position.y + boxSize,
                        z: powerUp.mesh.position.z + boxSize
                    }
                };
                
                const isCollecting = boundingBoxIntersection(playerBBox, powerUpBBox);
                
                if (isCollecting && !powerUp.collected) {
                    powerUp.collected = true;
                    scene.remove(powerUp.mesh);
                    gameState.powerUps.splice(index, 1);
                    
                    // Activate the power-up
                    activatePowerUp(powerUp.type);
                }
            });
            
            // ==================== KIWI COLLISION DETECTION ====================
            
            gameState.kiwis.forEach((kiwi, index) => {
                const kiwiBBox = {
                    min: {
                        x: kiwi.mesh.position.x - 0.35,
                        y: kiwi.mesh.position.y - 0.35,
                        z: kiwi.mesh.position.z - 0.35
                    },
                    max: {
                        x: kiwi.mesh.position.x + 0.35,
                        y: kiwi.mesh.position.y + 0.35,
                        z: kiwi.mesh.position.z + 0.35
                    }
                };
                
                // Magnet Power-Up Effect
                if (gameState.magnetActive) {
                    const magnetRange = 2.5; // Magnet attraction range
                    const distance = Math.sqrt(
                        Math.pow(kiwi.mesh.position.x - player.position.x, 2) +
                        Math.pow(kiwi.mesh.position.y - player.position.y, 2) +
                        Math.pow(kiwi.mesh.position.z - player.position.z, 2)
                    );
                    
                    if (distance < magnetRange && !kiwi.collected) {
                        // Attract kiwi towards player
                        const attractionSpeed = 0.15;
                        const direction = new THREE.Vector3()
                            .subVectors(player.position, kiwi.mesh.position)
                            .normalize()
                            .multiplyScalar(attractionSpeed);
                        
                        kiwi.mesh.position.add(direction);
                        
                        // Visual effect for magnet attraction
                        if (Math.random() > 0.8) {
                            createParticleEffect(
                                kiwi.mesh.position.clone(),
                                0x00FFFF,
                                'magnet'
                            );
                        }
                    }
                }
                
                const isCollecting = boundingBoxIntersection(playerBBox, kiwiBBox);
                
                if (isCollecting && !kiwi.collected) {
                    collectKiwi(kiwi);
                    gameState.kiwis.splice(index, 1);
                }
            });
            
            // ==================== BROCCOLI COLLISION DETECTION ====================
            
            gameState.broccolis.forEach((broccoli, index) => {
                const broccoliBBox = {
                    min: {
                        x: broccoli.mesh.position.x - 0.4,
                        y: broccoli.mesh.position.y - 0.4,
                        z: broccoli.mesh.position.z - 0.4
                    },
                    max: {
                        x: broccoli.mesh.position.x + 0.4,
                        y: broccoli.mesh.position.y + 0.4,
                        z: broccoli.mesh.position.z + 0.4
                    }
                };
                
                // Magnet Power-Up Effect (same as kiwis)
                if (gameState.magnetActive) {
                    const magnetRange = 2.5;
                    const distance = Math.sqrt(
                        Math.pow(broccoli.mesh.position.x - player.position.x, 2) +
                        Math.pow(broccoli.mesh.position.y - player.position.y, 2) +
                        Math.pow(broccoli.mesh.position.z - player.position.z, 2)
                    );
                    
                    if (distance < magnetRange && !broccoli.collected) {
                        const attractionSpeed = 0.15;
                        const direction = new THREE.Vector3()
                            .subVectors(player.position, broccoli.mesh.position)
                            .normalize()
                            .multiplyScalar(attractionSpeed);
                        
                        broccoli.mesh.position.add(direction);
                        broccoli.z = broccoli.mesh.position.z;
                    }
                }
                
                const isCollecting = boundingBoxIntersection(playerBBox, broccoliBBox);
                
                if (isCollecting && !broccoli.collected) {
                    collectBroccoli(broccoli);
                    gameState.broccolis.splice(index, 1);
                }
            });
        }
        
        // Calculate precise player bounding box based on current action
        function calculatePlayerBoundingBox() {
            const playerX = LANE_POSITIONS[gameState.playerLane];
            const playerY = gameState.playerY;
            
            let width = 0.8;  // Player width
            let height = 1.5; // Player height
            let depth = 0.6;  // Player depth
            
            // Adjust hitbox based on action
            if (gameState.playerAction === 'ducking') {
                height = 0.4; // Reduced from 0.6 to 0.4 for better obstacle clearance
                depth = 0.8; // Slightly larger depth when ducking
            } else if (gameState.playerAction === 'jumping') {
                // Tighter hitbox when jumping for more precise collision
                width = 0.7;
                depth = 0.5;
            }
            
            return {
                min: new THREE.Vector3(
                    playerX - width/2,
                    playerY,
                    -depth/2
                ),
                max: new THREE.Vector3(
                    playerX + width/2,
                    playerY + height,
                    depth/2
                )
            };
        }
        
        // Calculate obstacle bounding box based on type and mesh
        function calculateObstacleBoundingBox(obstacle) {
            const pos = obstacle.mesh.position;
            let width, height, depth;
            
            // Obstacle-specific bounding box dimensions
            switch (obstacle.type) {
                case 'lowbarrier':
                    width = 1.5; height = 0.8; depth = 0.3;
                    break;
                case 'highbarrier':
                    width = 1.8; height = 0.4; depth = 0.3;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'jumpblock':
                    width = 1.2; height = 1.2; depth = 1.2;
                    break;
                case 'spikes':
                    width = 0.5; height = 0.6; depth = 0.5;
                    break;
                case 'duckbeam':
                    width = 2.2; height = 0.3; depth = 0.8;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.4, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.4 + height, pos.z + depth/2)
                    };
                case 'hurdleset':
                    width = 1.4; height = 0.7; depth = 1.5; // Covers multiple hurdles
                    break;
                case 'wallgap':
                    width = 1.8; height = 1.3; depth = 0.4;
                    // Gap height consideration
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.3, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 2.5, pos.z + depth/2)
                    };
                case 'rotatingblade':
                    // Dynamic hitbox based on rotation - always dangerous
                    width = 2.2; height = 2; depth = 0.4;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'swinginghammer':
                    // Dynamic hitbox for swinging hammer - wider danger zone
                    width = 2.5; height = 1.8; depth = 0.8;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'movingwall':
                    // Moving wall uses actual position
                    width = 0.4; height = 2; depth = 1;
                    break;
                case 'bouncingball':
                    // Dynamic hitbox based on ball position
                    const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                    width = 1.2; height = ballHeight + 0.6; depth = 1.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'spinninglaser':
                    // Laser beam danger zone - wider when spinning
                    width = 3.2; height = 1.4; depth = 3.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.1, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.3, pos.z + depth/2)
                    };
                default:
                    width = 1.0; height = 1.0; depth = 1.0;
            }
            
            return {
                min: new THREE.Vector3(
                    pos.x - width/2,
                    pos.y,
                    pos.z - depth/2
                ),
                max: new THREE.Vector3(
                    pos.x + width/2,
                    pos.y + height,
                    pos.z + depth/2
                )
            };
        }
        
        // Check if two 3D bounding boxes intersect
        function boundingBoxIntersection(bbox1, bbox2) {
            return (bbox1.min.x <= bbox2.max.x && bbox1.max.x >= bbox2.min.x) &&
                   (bbox1.min.y <= bbox2.max.y && bbox1.max.y >= bbox2.min.y) &&
                   (bbox1.min.z <= bbox2.max.z && bbox1.max.z >= bbox2.min.z);
        }
        
        // Calculate minimum distance between two bounding boxes
        function boundingBoxDistance(bbox1, bbox2) {
            const dx = Math.max(0, Math.max(bbox1.min.x - bbox2.max.x, bbox2.min.x - bbox1.max.x));
            const dy = Math.max(0, Math.max(bbox1.min.y - bbox2.max.y, bbox2.min.y - bbox1.max.y));
            const dz = Math.max(0, Math.max(bbox1.min.z - bbox2.max.z, bbox2.min.z - bbox1.max.z));
            
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // Enhanced collision handling with type-specific effects
        function handleCollision(obstacle, obstacleBBox) {
            // Check if shield is active
            if (gameState.shieldActive) {
                // Shield absorbs the hit!
                deactivatePowerUp(); // Remove shield after one hit
                
                // Shield absorption effects
                const shieldPos = player.position.clone();
                createParticleEffect(shieldPos, 0x00AAFF, 'shield');
                
                // Shield audio feedback
                audioManager.createTone(600, 0.2, 'square');
                audioManager.createTone(400, 0.3, 'square');
                
                // Mild screen flash for shield activation
                screenShake(0.1, 200);
                
                // Show protection message
                showScorePopup(0, shieldPos, 'PROTECTED!');
                
                console.log('Shield absorbed collision!');
                return; // Exit early - no damage taken
            }
            
            // Slow motion for dramatic effect
            startSlowMotion(1000);
            
            // Type-specific collision audio
            audioManager.play('collision');
            
            // Lose life
            loseLife();
            
            // Enhanced collision effects based on obstacle material
            const collisionPos = obstacle.mesh.position.clone();
            let effectColor = 0xFF4444;
            
            switch (obstacle.type) {
                case 'jumpblock':
                case 'wallgap':
                    effectColor = 0x888888; // Concrete dust
                    break;
                case 'duckbeam':
                    effectColor = 0x4682B4; // Metal sparks
                    break;
                case 'spikes':
                    effectColor = 0xFF4500; // Fire/sparks
                    break;
            }
            
            // Use new enhanced collision particle system
            createCollisionParticles(collisionPos, obstacle.type);
            
            // Additional dust clouds at ground level
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const dustPos = new THREE.Vector3(
                        player.position.x + (Math.random() - 0.5) * 2,
                        0.1,
                        player.position.z + (Math.random() - 0.5)
                    );
                    createParticleEffect(dustPos, 0x8B7355, 'dust');
                }, i * 100);
            }
            
            // Screen shake intensity based on obstacle size
            const shakeIntensity = Math.min(0.5, (obstacleBBox.max.y - obstacleBBox.min.y) * 0.3);
            screenShake(shakeIntensity, 600);
            
            // Camera zoom for impact
            cameraZoomEffect(1.25, 400);
        }
        
        // ==================== POWER-UP SYSTEM ====================
        
        function createPowerUp(type, lane, z) {
            const powerUpConfig = POWER_UP_TYPES[type];
            const powerUpGroup = new THREE.Group();
            
            // Main power-up body - rotating cube
            const powerUpGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const powerUpMaterial = new THREE.MeshLambertMaterial({ 
                color: powerUpConfig.color,
                emissive: powerUpConfig.color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            const powerUpMesh = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUpMesh.position.y = 1.5; // Floating height
            powerUpMesh.castShadow = true;
            powerUpGroup.add(powerUpMesh);
            
            // Glowing ring around power-up
            const ringGeometry = new THREE.RingGeometry(0.6, 0.8);
            const ringMaterial = new THREE.MeshLambertMaterial({ 
                color: powerUpConfig.color,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            powerUpGroup.add(ring);
            
            // Particle effect (simulated with small spheres)
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05);
                const particleMaterial = new THREE.MeshLambertMaterial({ 
                    color: powerUpConfig.color,
                    emissive: powerUpConfig.color,
                    emissiveIntensity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                particle.position.set(
                    Math.cos(angle) * 1.2,
                    1.5 + Math.sin(i) * 0.3,
                    Math.sin(angle) * 1.2
                );
                powerUpGroup.add(particle);
            }
            
            powerUpGroup.position.set(LANE_POSITIONS[lane], 0, z);
            scene.add(powerUpGroup);
            
            // Store power-up data
            const powerUpData = {
                mesh: powerUpGroup,
                type: type,
                lane: lane,
                z: z,
                animationTime: 0,
                collected: false
            };
            
            powerUps.push(powerUpData);
            return powerUpData;
        }
        
        function createKiwi(lane, z, pattern = 'single') {
            const kiwiGroup = new THREE.Group();
            
            // REDESIGNED: Elongated Kiwi Geometrie (oval shape, less coin-like)
            const kiwiRadiusX = 0.3;   // Smaller width
            const kiwiRadiusY = 0.5;   // Taller height 
            const kiwiRadiusZ = 0.3;   // Smaller depth
            
            // ENHANCED: Elongated ellipsoid shape for realistic kiwi appearance
            const kiwiGeometry = new THREE.SphereGeometry(1, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.8);
            kiwiGeometry.scale(kiwiRadiusX, kiwiRadiusY, kiwiRadiusZ);  // Create oval/ellipsoid
            
            // ENHANCED: Verbesserte Braune Außenhaut mit Glow-Effekt
            const skinMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xB8860B,  // Noch heller für bessere Sichtbarkeit
                emissive: 0x3A2A0A,  // Leichtes Glühen
                roughness: 0.6
            });
            const kiwiSkin = new THREE.Mesh(kiwiGeometry, skinMaterial);
            kiwiSkin.rotation.x = -Math.PI / 2;
            kiwiSkin.position.y = 1.2;
            kiwiSkin.castShadow = true;
            kiwiGroup.add(kiwiSkin);
            
            // ENHANCED: Zusätzliche braune Textur-Ringe für bessere Kiwi-Optik (angepasst für oval)
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.RingGeometry(kiwiRadiusX * 0.7 + i * 0.04, kiwiRadiusX * 0.75 + i * 0.04, 16);
                const ringMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x8B4513,  // Dunklere braune Streifen
                    transparent: true,
                    opacity: 0.4
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = -Math.PI / 2;
                ring.position.y = 1.21 + i * 0.001;
                kiwiGroup.add(ring);
            }
            
            // Grünes Fruchtfleisch (elliptische Unterseite)
            const fleshGeometry = new THREE.EllipseGeometry ? 
                new THREE.EllipseGeometry(kiwiRadiusX * 0.95, kiwiRadiusZ * 0.95) :
                new THREE.CircleGeometry(kiwiRadiusX * 0.95, 32);
            const fleshMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8FBC8F,
                emissive: 0x2F5F2F,
                emissiveIntensity: 0.2
            });
            const kiwiFlesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
            kiwiFlesh.rotation.x = -Math.PI / 2;
            kiwiFlesh.position.y = 1.2;
            kiwiGroup.add(kiwiFlesh);
            
            // Weißer Kern in der Mitte (angepasst für oval)
            const coreGeometry = new THREE.CircleGeometry(kiwiRadiusX * 0.3, 16);
            const coreMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF5F5DC,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.1
            });
            const kiwiCore = new THREE.Mesh(coreGeometry, coreMaterial);
            kiwiCore.rotation.x = -Math.PI / 2;
            kiwiCore.position.y = 1.201;
            kiwiGroup.add(kiwiCore);
            
            // Schwarze Kerne/Samen (elliptisch verteilt)
            const seedCount = 12;
            for (let i = 0; i < seedCount; i++) {
                const angle = (i / seedCount) * Math.PI * 2;
                const distanceX = kiwiRadiusX * 0.5 + Math.random() * kiwiRadiusX * 0.2;
                const distanceZ = kiwiRadiusZ * 0.5 + Math.random() * kiwiRadiusZ * 0.2;
                
                const seedGeometry = new THREE.CircleGeometry(0.02, 4);
                const seedMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x000000
                });
                const seed = new THREE.Mesh(seedGeometry, seedMaterial);
                seed.rotation.x = -Math.PI / 2;
                seed.position.set(
                    Math.cos(angle) * distanceX,  // Use elliptical X coordinate
                    1.202,
                    Math.sin(angle) * distanceZ   // Use elliptical Z coordinate
                );
                kiwiGroup.add(seed);
            }
            
            // Glanz-Effekt für Frische
            const glintGeometry = new THREE.CircleGeometry(0.08, 8);
            const glintMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.6,
                transparent: true,
                opacity: 0.7
            });
            const glint = new THREE.Mesh(glintGeometry, glintMaterial);
            glint.rotation.x = -Math.PI / 2;
            glint.position.set(kiwiRadius * 0.4, 1.203, kiwiRadius * 0.3);
            kiwiGroup.add(glint);
            
            kiwiGroup.position.set(LANE_POSITIONS[lane], 0, z);
            scene.add(kiwiGroup);
            
            // Store kiwi data
            const kiwiData = {
                mesh: kiwiGroup,
                lane: lane,
                z: z,
                pattern: pattern,
                animationTime: 0,
                collected: false
            };
            
            kiwis.push(kiwiData);
            // REMOVED: totalCollectibles++ causes premature spawn stopping
            return kiwiData;
        }
        
        // NEW: Brokkoli creation function for variety
        function createBroccoli(lane, z, pattern = 'single') {
            const broccoliGroup = new THREE.Group();
            
            // Brokkoli Geometrie - Baum-ähnliche Form (größer für bessere Sichtbarkeit)
            const stemRadius = 0.25;
            const stemHeight = 0.6;
            const headRadius = 0.6;
            
            // Stiel (Stamm)
            const stemGeometry = new THREE.CylinderGeometry(stemRadius, stemRadius * 1.2, stemHeight, 8);
            const stemMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A6741,  // Dunkles Grün für Stiel
                emissive: 0x1A241A
            });
            const broccoliStem = new THREE.Mesh(stemGeometry, stemMaterial);
            broccoliStem.position.y = 1.0;
            broccoliStem.castShadow = true;
            broccoliGroup.add(broccoliStem);
            
            // Kopf (florettes) - mehrere kleine Kugeln
            for (let i = 0; i < 8; i++) {
                const floretGeometry = new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 8, 6);
                const floretMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x228B22,  // Helleres Grün für Florettes
                    emissive: 0x0F3F0F,  // Grünes Glühen
                    roughness: 0.7
                });
                const floret = new THREE.Mesh(floretGeometry, floretMaterial);
                
                // Zufällige Position um den Kopf
                const angle = (i / 8) * Math.PI * 2;
                const radius = 0.2 + Math.random() * 0.15;
                floret.position.set(
                    Math.cos(angle) * radius,
                    1.25 + Math.random() * 0.2,
                    Math.sin(angle) * radius
                );
                floret.castShadow = true;
                broccoliGroup.add(floret);
            }
            
            // Position and add to scene
            broccoliGroup.position.set(LANE_POSITIONS[lane], 0, z);
            broccoliGroup.userData = { type: 'broccoli', lane: lane };
            scene.add(broccoliGroup);
            
            // Brokkoli data object
            const broccoliData = {
                mesh: broccoliGroup,
                lane: lane,
                z: z,
                pattern: pattern,
                animationTime: 0,
                collected: false
            };
            
            broccolis.push(broccoliData);
            // REMOVED: totalCollectibles++ causes premature spawn stopping  
            return broccoliData;
        }
        
        function createKiwiPattern(type, baseZ) {
            switch (type) {
                case 'line':
                    // 3 kiwis in a horizontal line
                    for (let i = 0; i < 3; i++) {
                        createKiwi(i, baseZ, 'line');
                    }
                    break;
                case 'arc':
                    // 5 kiwis in a vertical arc
                    for (let i = 0; i < 5; i++) {
                        const lane = Math.floor(Math.random() * 3);
                        createKiwi(lane, baseZ - i * 2, 'arc');
                    }
                    break;
                case 'single':
                default:
                    // Single kiwi
                    const lane = Math.floor(Math.random() * 3);
                    createKiwi(lane, baseZ, 'single');
                    break;
            }
        }
        
        function activatePowerUp(type) {
            const config = POWER_UP_TYPES[type];
            
            // Deactivate any existing power-up
            if (gameState.activePowerUp) {
                deactivatePowerUp();
            }
            
            // Activate new power-up
            gameState.activePowerUp = type;
            gameState.powerUpTimeRemaining = config.duration;
            gameState[config.effect] = true;
            
            // Visual feedback
            createParticleEffect(
                player.position.clone(),
                config.color,
                'powerup'
            );
            
            // Audio feedback
            audioManager.play('powerup');
            
            // Screen flash effect
            screenShake(0.15, 200);
            
            // Update UI
            updatePowerUpUI();
            
            console.log(`Activated ${config.name} for ${config.duration/1000} seconds`);
        }
        
        function deactivatePowerUp() {
            if (!gameState.activePowerUp) return;
            
            const config = POWER_UP_TYPES[gameState.activePowerUp];
            gameState[config.effect] = false;
            gameState.activePowerUp = null;
            gameState.powerUpTimeRemaining = 0;
            
            // Update UI
            updatePowerUpUI();
            
            console.log(`Deactivated ${config.name}`);
        }
        
        function updatePowerUpUI() {
            const powerUpDisplay = document.getElementById('powerUpDisplay');
            const powerUpIcon = document.getElementById('powerUpIcon');
            const powerUpName = document.getElementById('powerUpName');
            const powerUpTime = document.getElementById('powerUpTime');
            
            if (gameState.activePowerUp) {
                const config = POWER_UP_TYPES[gameState.activePowerUp];
                powerUpDisplay.style.display = 'block';
                powerUpIcon.textContent = config.icon;
                powerUpName.textContent = config.name;
                powerUpTime.textContent = Math.ceil(gameState.powerUpTimeRemaining / 1000);
            } else {
                powerUpDisplay.style.display = 'none';
            }
        }
        
        function collectKiwi(kiwiData) {
            if (kiwiData.collected) return;
            
            kiwiData.collected = true;
            scene.remove(kiwiData.mesh);
            
            // Update kiwi count with debug logging
            gameState.collectedKiwis++;
            gameState.totalKiwis++;
            
            console.log(`🥝 COLLECTED KIWI - Session: ${gameState.collectedKiwis}, Total Lifetime: ${gameState.totalKiwis}`);
            
            // Handle combo system
            const currentTime = performance.now();
            if (currentTime - gameState.lastKiwiTime < 2000) { // 2 second combo window
                gameState.kiwiCombo++;
            } else {
                gameState.kiwiCombo = 1;
            }
            gameState.lastKiwiTime = currentTime;
            
            // Calculate score with combo multiplier
            const baseScore = 10;
            const comboBonus = gameState.kiwiCombo > 1 ? (gameState.kiwiCombo - 1) * 5 : 0;
            const totalScore = baseScore + comboBonus;
            
            addScore(totalScore, 'kiwi_collection');
            
            // Show combo UI
            updateComboUI();
            
            // Audio feedback with pitch variation (squish sound)
            const pitchVariation = 1 + (gameState.kiwiCombo * 0.1);
            audioManager.createTone(600 * pitchVariation, 0.15, 'sine');
            
            // Kiwi-Saft-Splash-Effekt
            createKiwiSplashEffect(kiwiData.mesh.position.clone());
            
            // Update UI
            updateKiwiUI();
            
            console.log(`Collected kiwi! Combo: ${gameState.kiwiCombo}, Score: +${totalScore}`);
        }
        
        // NEW: Brokkoli collection function
        function collectBroccoli(broccoliData) {
            if (broccoliData.collected) return;
            
            broccoliData.collected = true;
            scene.remove(broccoliData.mesh);
            
            // Update broccoli count with debug logging
            gameState.collectedBroccolis++;
            gameState.totalBroccolis++;
            
            console.log(`🥦 COLLECTED BROCCOLI - Session: ${gameState.collectedBroccolis}, Total Lifetime: ${gameState.totalBroccolis}`);
            
            // Broccolis give slightly more points than kiwis (health food bonus!)
            const baseScore = 15;
            const totalScore = baseScore;
            
            addScore(totalScore, 'broccoli_collection');
            
            // Green healthy effects
            createBroccoliHealthEffect(broccoliData.mesh.position.clone());
            
            // Audio feedback with lower pitch (different from kiwi)
            audioManager.createTone(400, 0.2, 'sine');
            
            // Update UI
            updateCollectibleUI();
            
            console.log(`Collected broccoli! Health bonus: +${totalScore} points`);
        }
        
        // Kiwi-Saft-Splash-Effekt
        function createKiwiSplashEffect(position) {
            const splashParticles = [];
            const particleCount = 20;
            
            for (let i = 0; i < particleCount; i++) {
                // Safttropfen-Geometrie
                const dropSize = 0.05 + Math.random() * 0.1;
                const dropGeometry = new THREE.SphereGeometry(dropSize, 4, 4);
                
                // Grüne Farbe mit Variation
                const greenVariation = Math.random() * 0.3;
                const dropMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.5 + greenVariation, 0.8 + greenVariation * 0.5, 0.3),
                    transparent: true,
                    opacity: 0.8
                });
                
                const drop = new THREE.Mesh(dropGeometry, dropMaterial);
                drop.position.copy(position);
                
                // Zufällige Geschwindigkeit in alle Richtungen
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.4 + 0.2,
                    (Math.random() - 0.5) * 0.3
                );
                
                scene.add(drop);
                splashParticles.push({ mesh: drop, velocity: velocity, life: 1.0 });
            }
            
            // Animate splash particles
            const animateSplash = () => {
                splashParticles.forEach((particle, index) => {
                    if (particle.life > 0) {
                        // Update position
                        particle.mesh.position.add(particle.velocity);
                        
                        // Apply gravity
                        particle.velocity.y -= 0.02;
                        
                        // Fade out
                        particle.life -= 0.05;
                        particle.mesh.material.opacity = particle.life * 0.8;
                        
                        // Scale down
                        const scale = particle.life;
                        particle.mesh.scale.set(scale, scale, scale);
                        
                        if (particle.life <= 0) {
                            scene.remove(particle.mesh);
                            splashParticles.splice(index, 1);
                        }
                    }
                });
                
                if (splashParticles.length > 0) {
                    requestAnimationFrame(animateSplash);
                }
            };
            
            animateSplash();
        }
        
        function updateComboUI() {
            const comboDisplay = document.getElementById('comboDisplay');
            const comboMultiplier = document.getElementById('comboMultiplier');
            
            if (gameState.kiwiCombo > 1) {
                comboDisplay.style.display = 'block';
                comboMultiplier.textContent = gameState.kiwiCombo;
                
                // Hide after 2 seconds
                setTimeout(() => {
                    comboDisplay.style.display = 'none';
                }, 2000);
            } else {
                comboDisplay.style.display = 'none';
            }
        }
        
        function updateKiwiUI() {
            const kiwiCount = document.getElementById('kiwiCount');
            const broccoliCount = document.getElementById('broccoliCount');
            const kiwiProgress = document.getElementById('kiwiProgress');
            const broccoliProgress = document.getElementById('broccoliProgress');
            
            // Debug logging
            console.log(`🔍 updateKiwiUI called - Kiwis: ${gameState.collectedKiwis}, Broccolis: ${gameState.collectedBroccolis}`);
            
            if (kiwiCount) {
                kiwiCount.textContent = gameState.collectedKiwis || 0;
            } else {
                console.error('❌ kiwiCount element not found!');
            }
            
            if (broccoliCount) {
                broccoliCount.textContent = gameState.collectedBroccolis || 0;
            } else {
                console.error('❌ broccoliCount element not found!');
            }
            
            // Update progress bars for 30:7 goals
            if (kiwiProgress) {
                const kiwiPercent = Math.min((gameState.collectedKiwis / 30) * 100, 100);
                kiwiProgress.style.width = kiwiPercent + '%';
            }
            
            if (broccoliProgress) {
                const broccoliPercent = Math.min((gameState.collectedBroccolis / 7) * 100, 100);
                broccoliProgress.style.width = broccoliPercent + '%';
            }
            
            // Also update the total for percentage calculation
            const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
            console.log(`📊 Total collected: ${collectedTotal}/${gameState.totalCollectibles} (${gameState.totalCollectibles > 0 ? (collectedTotal/gameState.totalCollectibles*100).toFixed(0) : 0}%)`);
        }
        
        function updateEnvironmentUI() {
            const environmentDisplay = document.getElementById('currentEnvironment');
            if (environmentDisplay) {
                switch (gameState.currentEnvironment) {
                    case 'street':
                        environmentDisplay.innerHTML = '🏙️ Straße';
                        break;
                    case 'tunnel_entrance':
                        environmentDisplay.innerHTML = '🚇 Tunnel Eingang';
                        break;
                    case 'tunnel':
                        environmentDisplay.innerHTML = '🚇 Tunnel';
                        break;
                    case 'tunnel_exit':
                        environmentDisplay.innerHTML = '🌅 Tunnel Ausgang';
                        break;
                    default:
                        environmentDisplay.innerHTML = '🏙️ Straße';
                }
            }
        }
        
        function updateDifficultyUI() {
            const difficultyLevel = document.getElementById('difficultyLevel');
            if (difficultyLevel) {
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime);
                
                if (gameProgress < 0.2) {
                    difficultyLevel.textContent = 'Leicht';
                    difficultyLevel.style.color = '#90EE90';
                } else if (gameProgress < 0.4) {
                    difficultyLevel.textContent = 'Mittel';
                    difficultyLevel.style.color = '#FFD700';
                } else if (gameProgress < 0.6) {
                    difficultyLevel.textContent = 'Schwer';
                    difficultyLevel.style.color = '#FFA500';
                } else if (gameProgress < 0.8) {
                    difficultyLevel.textContent = 'Extrem';
                    difficultyLevel.style.color = '#FF4500';
                } else {
                    difficultyLevel.textContent = 'Wahnsinn!';
                    difficultyLevel.style.color = '#FF0000';
                }
            }
        }
        
        // ==================== SKILL COMBO SYSTEM ====================
        
        function showSkillCombo(bonusPoints, comboMessage) {
            const skillComboDisplay = document.getElementById('skillComboDisplay');
            const skillComboCount = document.getElementById('skillComboCount');
            const skillComboBonus = document.getElementById('skillComboBonus');
            const skillComboIcon = document.getElementById('skillComboIcon');
            
            if (skillComboDisplay) {
                skillComboDisplay.style.display = 'block';
                if (skillComboCount) skillComboCount.textContent = gameState.consecutiveAvoidances;
                if (skillComboBonus) skillComboBonus.textContent = `+${bonusPoints}`;
                
                // Dynamic icon based on combo type
                if (skillComboIcon) {
                    if (comboMessage.includes('ZIGZAG')) {
                        skillComboIcon.textContent = '⚡';
                    } else if (comboMessage.includes('LIGHTNING')) {
                        skillComboIcon.textContent = '⚡';
                    } else if (comboMessage.includes('PERFECT')) {
                        skillComboIcon.textContent = '💎';
                    } else if (comboMessage.includes('RAPID')) {
                        skillComboIcon.textContent = '🔥';
                    } else {
                        skillComboIcon.textContent = '⭐';
                    }
                }
                
                // Update combo message in UI
                const comboTextElement = skillComboDisplay.querySelector('div');
                if (comboTextElement) {
                    comboTextElement.innerHTML = `<span style="color: #FFD700;">+${bonusPoints} ${comboMessage}</span>`;
                }
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    skillComboDisplay.style.display = 'none';
                }, 3000);
                
                // Enhanced audio for combos
                if (bonusPoints > 200) {
                    audioManager.createTone(880, 0.3, 'sine'); // High achievement sound
                    audioManager.createTone(660, 0.4, 'sine'); // Chord
                } else if (bonusPoints > 100) {
                    audioManager.createTone(660, 0.2, 'sine'); // Medium achievement
                } else {
                    audioManager.createTone(440, 0.15, 'sine'); // Basic skill sound
                }
                
                console.log(`SKILL COMBO: ${comboMessage} - +${bonusPoints} points`);
            }
        }
        
        function trackPlayerMove(moveType, lane = null) {
            const currentTime = performance.now();
            const actualLane = lane !== null ? lane : gameState.playerLane;
            
            // BUGFIX: Only track lane changes for rapid move bonuses, not jumping/ducking
            if (gameState.lastAction !== moveType && (moveType === 'left' || moveType === 'right')) {
                const timeSinceLastMove = currentTime - gameState.lastSkillTime;
                
                // Award rapid movement bonus only for actual lane changes (skill moves)
                if (timeSinceLastMove < 1000 && gameState.rapidMoveBonus < 5) { // Max 5 rapid moves
                    gameState.rapidMoveBonus++;
                    const rapidBonus = gameState.rapidMoveBonus * 10;
                    addScore(rapidBonus, 'rapid_lane_change');
                    
                    // Show rapid move feedback
                    if (gameState.rapidMoveBonus >= 3) {
                        showSkillCombo(rapidBonus, `RAPID LANE CHANGES x${gameState.rapidMoveBonus}!`);
                    }
                } else if (timeSinceLastMove > 2000) {
                    gameState.rapidMoveBonus = 0; // Reset if too slow
                }
                
                gameState.lastAction = moveType;
                gameState.lastSkillTime = currentTime;
            }
            
            // Track jumping and ducking without giving points (just for sequence tracking)
            if (moveType === 'jumping' || moveType === 'ducking') {
                gameState.lastAction = moveType;
            }
        }
        
        // ==================== END SKILL COMBO SYSTEM ====================
        
        // ==================== SIMPLIFIED BRIDGE/UNDERPASS SYSTEM ====================
        
        function createBridgeSegment(z) {
            const bridgeGroup = new THREE.Group();
            
            // Bridge deck (road above)
            const bridgeGeometry = new THREE.BoxGeometry(12, 0.5, 10);
            const bridgeMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            bridge.position.set(0, 6.5, z);
            bridgeGroup.add(bridge);
            
            // Support pillars
            const pillarGeometry = new THREE.BoxGeometry(0.8, 6, 0.8);
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            for (let x of [-4, 4]) {
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(x, 3, z);
                bridgeGroup.add(pillar);
            }
            
            // Bridge railings
            const railingGeometry = new THREE.BoxGeometry(12, 0.3, 0.2);
            const railingMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            
            for (let side of [-4.5, 4.5]) {
                const railing = new THREE.Mesh(railingGeometry, railingMaterial);
                railing.position.set(0, 7.2, z + side);
                bridgeGroup.add(railing);
            }
            
            // Cars on bridge (decorative)
            if (Math.random() > 0.7) {
                const carGeometry = new THREE.BoxGeometry(1.5, 0.5, 3);
                const carMaterial = new THREE.MeshLambertMaterial({ 
                    color: Math.random() > 0.5 ? 0xFF0000 : 0x0000FF 
                });
                
                const car = new THREE.Mesh(carGeometry, carMaterial);
                car.position.set(
                    (Math.random() - 0.5) * 8, 
                    7, 
                    z + (Math.random() - 0.5) * 8
                );
                bridgeGroup.add(car);
            }
            
            return bridgeGroup;
        }
        
        function createSimpleKiwi(lane, z) {
            const kiwiGroup = new THREE.Group();
            
            // Simplified elongated kiwi for performance (less detailed than createKiwi)
            const kiwiRadiusX = 0.4;   // Larger width for better visibility
            const kiwiRadiusY = 0.6;   // Taller height for better visibility
            const kiwiRadiusZ = 0.4;   // Larger depth for better visibility
            
            // Half ellipsoid for kiwi body
            const kiwiGeometry = new THREE.SphereGeometry(1, 8, 4, 0, Math.PI * 2, 0, Math.PI / 2);
            kiwiGeometry.scale(kiwiRadiusX, kiwiRadiusY, kiwiRadiusZ);  // Create oval/ellipsoid
            const kiwiMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8B6914,
                transparent: true,
                opacity: 0.9
            });
            
            const kiwiBody = new THREE.Mesh(kiwiGeometry, kiwiMaterial);
            kiwiBody.rotation.x = -Math.PI / 2;
            kiwiGroup.add(kiwiBody);
            
            // Simple flesh ellipse
            const fleshGeometry = new THREE.CircleGeometry(kiwiRadiusX * 0.9, 8);
            const fleshMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.95
            });
            
            const flesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
            flesh.rotation.x = -Math.PI / 2;
            flesh.position.y = 0.01;
            kiwiGroup.add(flesh);
            
            // Simple white core
            const coreGeometry = new THREE.CircleGeometry(kiwiRadiusX * 0.3, 6);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xF5F5DC
            });
            
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.rotation.x = -Math.PI / 2;
            core.position.y = 0.02;
            kiwiGroup.add(core);
            
            // Position
            const LANE_POSITIONS = [-2, 0, 2];
            kiwiGroup.position.set(LANE_POSITIONS[lane], 1.2, z);
            
            scene.add(kiwiGroup);
            
            return {
                mesh: kiwiGroup,
                type: 'kiwi',
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0,
                baseY: 1.2
            };
        }
        
        function createSimplePowerUp(type, lane, z) {
            const powerUpGroup = new THREE.Group();
            
            // Special geometry for magnet and large magnet
            if (type === 'magnet' || type === 'largeMagnet') {
                // Create horseshoe magnet shape
                const magnetGroup = new THREE.Group();
                
                // Scale factor for large magnet
                const scale = type === 'largeMagnet' ? 2.0 : 1.0;
                
                // Red (north) pole
                const redPoleGeometry = new THREE.BoxGeometry(0.3 * scale, 0.8 * scale, 0.3 * scale);
                const redPoleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: type === 'largeMagnet' ? 0.5 : 0.3
                });
                const redPole = new THREE.Mesh(redPoleGeometry, redPoleMaterial);
                redPole.position.set(-0.25 * scale, 0, 0);
                magnetGroup.add(redPole);
                
                // Blue (south) pole
                const bluePoleGeometry = new THREE.BoxGeometry(0.3 * scale, 0.8 * scale, 0.3 * scale);
                const bluePoleMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x0000FF,
                    emissive: 0x0000FF,
                    emissiveIntensity: type === 'largeMagnet' ? 0.5 : 0.3
                });
                const bluePole = new THREE.Mesh(bluePoleGeometry, bluePoleMaterial);
                bluePole.position.set(0.25 * scale, 0, 0);
                magnetGroup.add(bluePole);
                
                // Curved top connection (simplified with box)
                const topGeometry = new THREE.BoxGeometry(0.8 * scale, 0.3 * scale, 0.3 * scale);
                const topMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const topPart = new THREE.Mesh(topGeometry, topMaterial);
                topPart.position.set(0, 0.55 * scale, 0);
                magnetGroup.add(topPart);
                
                // Add magnet group to power-up
                magnetGroup.rotation.z = Math.PI / 6; // Slight tilt for visual interest
                powerUpGroup.add(magnetGroup);
                
                // Add golden glow around magnet (larger and brighter for large magnet)
                const glowSize = type === 'largeMagnet' ? 1.5 : 0.7;
                const glowOpacity = type === 'largeMagnet' ? 0.3 : 0.15;
                const glowGeometry = new THREE.SphereGeometry(glowSize, 12, 12);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xFFD700,
                    transparent: true,
                    opacity: glowOpacity
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                powerUpGroup.add(glow);
                
                // Add pulsing outer ring for large magnet
                if (type === 'largeMagnet') {
                    const ringGeometry = new THREE.TorusGeometry(1.2, 0.1, 8, 16);
                    const ringMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0xFFD700,
                        transparent: true,
                        opacity: 0.4
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    powerUpGroup.add(ring);
                    powerUpGroup.ring = ring; // Store reference for animation
                }
                
            } else {
                // Default crystal for other power-ups
                const crystalGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.4);
                const crystalMaterial = new THREE.MeshBasicMaterial({ 
                    color: POWER_UP_TYPES[type].color,
                    transparent: true,
                    opacity: 0.8
                });
                
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                powerUpGroup.add(crystal);
                
                // Power-up glow
                const glowGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({ 
                    color: POWER_UP_TYPES[type].color,
                    transparent: true,
                    opacity: 0.2
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                powerUpGroup.add(glow);
            }
            
            // Position
            const LANE_POSITIONS = [-2, 0, 2];
            const baseY = type === 'largeMagnet' ? 2.2 : 1.5; // Higher position for large magnet
            powerUpGroup.position.set(LANE_POSITIONS[lane], baseY, z);
            
            scene.add(powerUpGroup);
            
            return {
                mesh: powerUpGroup,
                type: type,
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0,
                baseY: baseY
            };
        }
        
        function createTunnelSegment(z) {
            const tunnelGroup = new THREE.Group();
            
            // Tunnel walls (left and right)
            const wallGeometry = new THREE.BoxGeometry(0.3, 6, 8);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            
            // Left wall
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-4, 3, z);
            tunnelGroup.add(leftWall);
            
            // Right wall  
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(4, 3, z);
            tunnelGroup.add(rightWall);
            
            // Tunnel ceiling
            const ceilingGeometry = new THREE.BoxGeometry(8, 0.3, 8);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.set(0, 5.5, z);
            tunnelGroup.add(ceiling);
            
            // Tunnel floor stripes (more industrial look)
            const stripeGeometry = new THREE.BoxGeometry(8, 0.05, 0.2);
            const stripeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 0.05, z + (i * 2 - 2));
                tunnelGroup.add(stripe);
            }
            
            // Tunnel support beams
            const beamGeometry = new THREE.BoxGeometry(0.1, 5.5, 0.2);
            const beamMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            for (let side of [-3.8, 3.8]) {
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.set(side, 2.75, z);
                tunnelGroup.add(beam);
            }
            
            // Add tunnel lighting
            const lightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFAA,
                transparent: true,
                opacity: 0.8
            });
            
            const tunnelLight = new THREE.Mesh(lightGeometry, lightMaterial);
            tunnelLight.position.set(0, 5, z);
            tunnelGroup.add(tunnelLight);
            
            // Add light glow effect
            const glowGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFAA,
                transparent: true,
                opacity: 0.2
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(0, 5, z);
            tunnelGroup.add(glow);
            
            return tunnelGroup;
        }
        
        function createTunnelEntrance(z) {
            const entranceGroup = new THREE.Group();
            
            // Tunnel entrance arch
            const archGeometry = new THREE.CylinderGeometry(4.5, 4.5, 0.5, 16, 1, false, 0, Math.PI);
            const archMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            const arch = new THREE.Mesh(archGeometry, archMaterial);
            arch.position.set(0, 4.5, z);
            arch.rotation.z = Math.PI;
            entranceGroup.add(arch);
            
            // Entrance signs
            const signGeometry = new THREE.BoxGeometry(2, 0.5, 0.1);
            const signMaterial = new THREE.MeshLambertMaterial({ color: 0x2E86AB });
            
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 6, z);
            entranceGroup.add(sign);
            
            // Warning lights
            for (let x of [-1.5, 1.5]) {
                const warningLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFF4500 })
                );
                warningLight.position.set(x, 5.5, z);
                entranceGroup.add(warningLight);
            }
            
            return entranceGroup;
        }
        
        function checkBridgeSpawning() {
            const currentTime = performance.now();
            const gameTime = (currentTime - gameState.gameStartTime);
            
            // Progressive bridge spawning (longer intervals at start, shorter later)
            if (gameTime > gameState.nextTunnelTime) {
                const bridge = createBridgeSegment(-40);
                scene.add(bridge);
                gameState.tunnelSegments.push(bridge);
                
                // Audio effect for bridge
                audioManager.createTone(300, 0.2, 'sine');
                
                // Progressive bridge frequency
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime);
                const baseInterval = 25000; // 25 seconds at start
                const minInterval = 12000; // 12 seconds at end
                const currentInterval = baseInterval - (baseInterval - minInterval) * gameProgress;
                const randomVariation = Math.random() * 5000; // ±2.5 seconds
                
                gameState.nextTunnelTime = gameTime + currentInterval + randomVariation;
                
                console.log(`Bridge spawned! Next in ${(currentInterval + randomVariation)/1000}s`);
            }
        }
        
        function startTunnelTransition() {
            console.log('Entering tunnel...');
            gameState.currentEnvironment = 'tunnel_entrance';
            gameState.environmentTransition = true;
            gameState.tunnelStartTime = performance.now();
            
            // Update UI
            updateEnvironmentUI();
            
            // Create tunnel entrance
            const entrance = createTunnelEntrance(-25);
            scene.add(entrance);
            gameState.tunnelSegments.push(entrance);
            
            // Audio effect for tunnel entrance
            audioManager.createTone(200, 0.5, 'sine');
            
            // Dim ambient lighting
            gameState.ambientLightIntensity = 0.3;
            if (scene.children.find(child => child.type === 'AmbientLight')) {
                scene.children.find(child => child.type === 'AmbientLight').intensity = 0.3;
            }
            
            // Create initial tunnel segments
            for (let i = 0; i < 8; i++) {
                const segment = createTunnelSegment(-30 - (i * 8));
                scene.add(segment);
                gameState.tunnelSegments.push(segment);
            }
            
            // Transition to full tunnel after 2 seconds
            setTimeout(() => {
                gameState.currentEnvironment = 'tunnel';
                gameState.environmentTransition = false;
                updateEnvironmentUI();
                console.log('Now in tunnel!');
            }, 2000);
        }
        
        // NEW: Brokkoli health effect
        function createBroccoliHealthEffect(position) {
            const healthParticles = [];
            const particleCount = 15;
            
            for (let i = 0; i < particleCount; i++) {
                // Heart-shaped particles for health effect
                const heartSize = 0.08 + Math.random() * 0.05;
                const heartGeometry = new THREE.SphereGeometry(heartSize, 6, 4);
                const heartMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.2, 0.8 + Math.random() * 0.2, 0.3),
                    transparent: true,
                    opacity: 0.9
                });
                
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.position.copy(position);
                
                // Upward floating motion for health
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    3 + Math.random() * 2,  // Upward
                    (Math.random() - 0.5) * 3
                );
                
                heart.userData = { velocity: velocity, life: 1.0 };
                scene.add(heart);
                healthParticles.push(heart);
            }
            
            // Animate health particles
            function animateHealthParticles() {
                healthParticles.forEach((particle, index) => {
                    if (particle.userData.life > 0) {
                        particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.016));
                        particle.userData.velocity.y -= 0.3; // Gravity
                        particle.userData.life -= 0.02;
                        particle.material.opacity = particle.userData.life;
                        
                        if (particle.userData.life <= 0) {
                            scene.remove(particle);
                            healthParticles.splice(index, 1);
                        }
                    }
                });
                
                if (healthParticles.length > 0) {
                    requestAnimationFrame(animateHealthParticles);
                }
            }
            
            animateHealthParticles();
        }
        
        // NEW: Update collectible UI for both kiwis and broccolis
        function updateCollectibleUI() {
            const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
            const collectionPercentage = gameState.totalCollectibles > 0 ? 
                (collectedTotal / gameState.totalCollectibles * 100).toFixed(0) : 0;
            
            // Update display with enhanced debugging
            console.log(`📊 COLLECTIBLE UPDATE:`);
            console.log(`   🥝 Kiwis: ${gameState.collectedKiwis} (${gameState.kiwis.length} active)`);
            console.log(`   🥦 Broccolis: ${gameState.collectedBroccolis} (${gameState.broccolis.length} active)`);
            console.log(`   📈 Progress: ${collectedTotal}/${gameState.totalCollectibles} (${collectionPercentage}%)`);
            
            // Update the HTML display - force update
            updateKiwiUI();
            
            // Verify the update actually happened
            const kiwiElement = document.getElementById('kiwiCount');
            const broccoliElement = document.getElementById('broccoliCount');
            if (kiwiElement && broccoliElement) {
                console.log(`   ✅ UI Elements - Kiwi: ${kiwiElement.textContent}, Broccoli: ${broccoliElement.textContent}`);
            }
            
            // Check for tiered collection bonuses
            checkTieredCollectionBonuses();
        }
        
        // NEW: Tiered collection bonus system
        function checkTieredCollectionBonuses() {
            const kiwis = gameState.collectedKiwis;
            const broccolis = gameState.collectedBroccolis;
            const total = kiwis + broccolis;
            
            // Tier 1: 5+ of one type (250 points)
            if ((kiwis >= 5 || broccolis >= 5) && !gameState.collectionBonusAwarded.fiveOfOne) {
                awardTieredBonus('fiveOfOne', 250, `5+ ${kiwis >= 5 ? 'Kiwis' : 'Broccolis'}`);
            }
            
            // Tier 2: All 30 kiwis OR all 7 broccolis (500 points)
            if ((kiwis >= 30 || broccolis >= 7) && !gameState.collectionBonusAwarded.allOfOne) {
                awardTieredBonus('allOfOne', 500, `All ${kiwis >= 30 ? '30 Kiwis' : '7 Broccolis'}`);
            }
            
            // Tier 3: All 37 collectibles (1000 points)
            if (total >= 37 && !gameState.collectionBonusAwarded.allThirtySeven) {
                awardTieredBonus('allThirtySeven', 1000, 'Perfect Collection - All 37!');
            }
            
            // NEW: Broccoli specific bonuses
            // Tier B1: 5 broccolis (200 points)
            if (broccolis >= 5 && !gameState.collectionBonusAwarded.broccoliMaster) {
                awardTieredBonus('broccoliMaster', 200, 'BROCCOLI MASTER! 🥦');
            }
            
            // Tier B2: 7 broccolis (500 points)
            if (broccolis >= 7 && !gameState.collectionBonusAwarded.veggieChampion) {
                awardTieredBonus('veggieChampion', 500, 'VEGGIE CHAMPION! 🏆');
            }
        }
        
        function awardTieredBonus(tier, points, achievement) {
            gameState.collectionBonusAwarded[tier] = true;
            addScore(points, `collection_${tier}`);
            
            // Special celebration effects
            showCollectionAchievement(achievement, points);
            
            // Audio celebration - different tones for each tier
            if (tier === 'fiveOfOne') {
                audioManager.createTone(523, 0.3, 'sine'); // C5
            } else if (tier === 'allOfOne') {
                audioManager.createTone(659, 0.3, 'sine'); // E5
                setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 150); // G5
            } else if (tier === 'allThirtySeven') {
                audioManager.createTone(523, 0.3, 'sine'); // C5
                setTimeout(() => audioManager.createTone(659, 0.3, 'sine'), 150); // E5
                setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 300); // G5
                setTimeout(() => audioManager.createTone(1047, 0.4, 'sine'), 450); // C6
            }
            
            console.log(`🎉 ${achievement.toUpperCase()} BONUS! +${points} points`);
        }
        
        // NEW: Show collection achievement UI
        function showCollectionAchievement(achievement, points) {
            // Create achievement popup (you can enhance this with actual UI)
            const total = gameState.collectedKiwis + gameState.collectedBroccolis;
            
            // For now, show in console - can be enhanced with visual UI later
            console.log(`
🏆 ${achievement.toUpperCase()} ACHIEVED! 🏆
━━━━━━━━━━━━━━━━━━━━
🥝 Kiwis: ${gameState.collectedKiwis} | 🥦 Broccolis: ${gameState.collectedBroccolis}
📊 Total: ${total}/14
💎 Bonus Score: +${points} points
━━━━━━━━━━━━━━━━━━━━
            `);
            
            // Trigger confetti or other celebration effects
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createParticleEffect(
                        new THREE.Vector3(
                            player.position.x + (Math.random() - 0.5) * 4,
                            player.position.y + 3,
                            player.position.z
                        ),
                        [0xFFD700, 0x00FF00, 0xFF69B4][i % 3],
                        'celebration'
                    );
                }, i * 100);
            }
        }
        
        function exitTunnelTransition() {
            console.log('Exiting tunnel...');
            gameState.currentEnvironment = 'tunnel_exit';
            gameState.environmentTransition = true;
            gameState.lastTunnelExit = performance.now();
            
            // Update UI
            updateEnvironmentUI();
            
            // Schedule next tunnel
            const currentTime = performance.now();
            const gameTime = (currentTime - gameState.gameStartTime);
            gameState.nextTunnelTime = gameTime + gameState.tunnelCooldown;
            
            // Audio effect for tunnel exit
            audioManager.createTone(400, 0.3, 'sine');
            
            // Restore ambient lighting gradually
            gameState.ambientLightIntensity = 1.0;
            if (scene.children.find(child => child.type === 'AmbientLight')) {
                scene.children.find(child => child.type === 'AmbientLight').intensity = 1.0;
            }
            
            // Clean up tunnel segments gradually
            setTimeout(() => {
                cleanupTunnelSegments();
                gameState.currentEnvironment = 'street';
                gameState.environmentTransition = false;
                updateEnvironmentUI();
                console.log('Back to street!');
            }, 3000);
        }
        
        function updateBridgeEnvironment(deltaTime) {
            // Move bridge segments
            gameState.tunnelSegments.forEach((segment, index) => {
                segment.position.z += visualSpeed;
                
                // Remove segments that have passed the player
                if (segment.position.z > 15) {
                    scene.remove(segment);
                    gameState.tunnelSegments.splice(index, 1);
                }
            });
            
            // Animate cars on bridges
            gameState.tunnelSegments.forEach(segment => {
                segment.children.forEach(child => {
                    if (child.material && child.material.color && 
                        (child.material.color.r > 0.8 || child.material.color.b > 0.8)) { // Car objects
                        child.position.x += (Math.random() - 0.5) * 0.01; // Slight car movement
                    }
                });
            });
        }
        
        function cleanupTunnelSegments() {
            gameState.tunnelSegments.forEach(segment => {
                scene.remove(segment);
            });
            gameState.tunnelSegments = [];
        }
        
        function getTunnelSpecificObstacles() {
            // Tunnel-specific obstacles that make sense in confined space
            return [
                'lowbarrier', 'duckbeam', 'wallgap', 'spikes',
                'rotatingblade', 'swinginghammer' // Moving obstacles work well in tunnels
            ];
        }
        
        // ==================== END TUNNEL ENVIRONMENT SYSTEM ====================
        
        // ==================== END POWER-UP SYSTEM ====================
        
        // Near-miss detection and bonus system
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            // Prevent multiple near-miss triggers for same obstacle
            if (obstacle.nearMissTriggered) return;
            obstacle.nearMissTriggered = true;
            
            // Calculate how close the call was
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const nearMissBonus = Math.floor((0.3 - distance) * 100); // Closer = more points
            
            addScore(nearMissBonus, 'near_miss_bonus');
            
            // Near-miss audio feedback
            audioManager.play('nearmiss');
            
            // Enhanced visual feedback for near miss
            const effectPos = obstacle.mesh.position.clone();
            
            // Create multiple spark effects
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const sparkPos = effectPos.clone();
                    sparkPos.x += (Math.random() - 0.5);
                    sparkPos.y += Math.random() * 0.5;
                    sparkPos.z += (Math.random() - 0.5) * 0.5;
                    createParticleEffect(sparkPos, 0xFFFF00, 'spark');
                }, i * 30);
            }
            
            // Main near miss effect
            createParticleEffect(effectPos, 0xFFD700, 'nearMiss');
            
            // Camera effect for close calls
            if (distance < 0.1) {
                cameraZoomEffect(1.05, 150);
            }
            
            // Show near-miss popup
            showScorePopup(nearMissBonus, effectPos, distance < 0.1 ? 'SUPER CLOSE!' : 'CLOSE!');
        }
        
        // Update animations for moving obstacles
        function updateMovingObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                obstacle.animationTime += deltaTime * 0.001; // Convert to seconds
                
                switch (obstacle.type) {
                    case 'rotatingblade':
                        // Rotate the blade group
                        const bladeGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (bladeGroup) {
                            bladeGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                            
                            // Add warning sound for fast rotating blades
                            if (obstacle.rotationSpeed > 4 && Math.random() > 0.98) {
                                audioManager.createNoise(0.02, 800 + Math.random() * 400);
                            }
                        }
                        break;
                        
                    case 'swinginghammer':
                        // Swing the hammer arm
                        const hammerGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (hammerGroup) {
                            const armGroup = hammerGroup.children.find(child => child.type === 'Group');
                            if (armGroup) {
                                const swingAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                                armGroup.rotation.z = swingAngle;
                                
                                // Add swoosh sound at swing extremes
                                if (Math.abs(swingAngle) > obstacle.swingAmplitude * 0.8 && Math.random() > 0.95) {
                                    audioManager.createNoise(0.03, 1200 + Math.abs(swingAngle) * 500);
                                }
                            }
                        }
                        break;
                        
                    case 'movingwall':
                        // Move the wall side to side
                        const movingWall = obstacle.mesh.children[0];
                        if (movingWall) {
                            const movement = Math.sin(obstacle.animationTime * obstacle.movementSpeed) * obstacle.movementRange;
                            obstacle.mesh.position.x = obstacle.initialX + movement;
                            
                            // Add mechanical sound when changing direction
                            const prevMovement = Math.sin((obstacle.animationTime - deltaTime * 0.001) * obstacle.movementSpeed) * obstacle.movementRange;
                            if (Math.sign(movement) !== Math.sign(prevMovement) && Math.random() > 0.9) {
                                audioManager.createTone(150, 0.1, 'square');
                            }
                        }
                        break;
                        
                    case 'bouncingball':
                        // Bounce the ball up and down with realistic physics
                        const ballGroup = obstacle.mesh.children[0];
                        if (ballGroup) {
                            const ball = ballGroup.children[0]; // The actual ball
                            const shadow = ballGroup.children[1]; // Ground shadow
                            const ring = ballGroup.children[2]; // Warning ring
                            
                            if (ball && shadow && ring) {
                                // Bouncing motion using sine wave with gravity simulation
                                const bouncePhase = obstacle.animationTime * obstacle.bounceSpeed;
                                const bounceHeight = Math.abs(Math.sin(bouncePhase)) * obstacle.bounceHeight;
                                ball.position.y = 0.6 + bounceHeight; // 0.6 is ball radius
                                
                                // Scale shadow based on height (higher = smaller shadow)
                                const shadowScale = 1 - (bounceHeight / obstacle.bounceHeight) * 0.3;
                                shadow.scale.set(shadowScale, 1, shadowScale);
                                
                                // Pulse warning ring
                                const ringPulse = 1 + Math.sin(obstacle.animationTime * 8) * 0.2;
                                ring.scale.set(ringPulse, 1, ringPulse);
                                
                                // Add bounce sound at impact
                                if (bounceHeight < 0.2 && Math.random() > 0.97) {
                                    audioManager.createTone(200 + Math.random() * 100, 0.1, 'square');
                                }
                            }
                        }
                        break;
                        
                    case 'spinninglaser':
                        // Spin the laser beams and pulse warning lights
                        const laserGroup = obstacle.mesh.children[0];
                        if (laserGroup) {
                            const laserBeamGroup = laserGroup.children.find(child => child.type === 'Group');
                            
                            if (laserBeamGroup) {
                                // Rotate laser beams
                                laserBeamGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                                
                                // Pulse warning lights
                                const pulseFactor = (Math.sin(obstacle.animationTime * obstacle.pulseSpeed) + 1) / 2;
                                laserGroup.children.forEach(child => {
                                    if (child.geometry && child.geometry.type === 'SphereGeometry') {
                                        child.material.emissive.setHex(pulseFactor > 0.5 ? 0x440000 : 0x220000);
                                    }
                                });
                                
                                // Add laser whir sound
                                if (obstacle.rotationSpeed > 2.5 && Math.random() > 0.98) {
                                    audioManager.createNoise(0.02, 1500 + Math.random() * 500);
                                }
                            }
                        }
                        break;
                }
            });
        }

        function showScorePopup(score, position) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#00FF00';
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.fillText(`+${score}`, 64, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            
            sprite.position.copy(position);
            sprite.position.y += 2;
            sprite.scale.set(2, 1, 1);
            scene.add(sprite);
            
            // Animate popup
            const startY = sprite.position.y;
            const animatePopup = () => {
                sprite.position.y += 0.05;
                sprite.material.opacity -= 0.02;
                
                if (sprite.material.opacity > 0) {
                    requestAnimationFrame(animatePopup);
                } else {
                    scene.remove(sprite);
                }
            };
            animatePopup();
        }

        function loseLife() {
            gameState.lives--;
            
            // Make player invulnerable for 2 seconds
            gameState.invulnerable = true;
            gameState.invulnerabilityTime = 2000;
            
            // Visual feedback - make player flash red
            player.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0xFF6B6B);
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            
            if (gameState.lives <= 0) {
                endGame();
            }
        }

        // Smooth linear interpolation function
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        // Enhanced environment movement with parallax and smooth speed
        function updateEnvironmentMovement(deltaTime) {
            // Smooth speed interpolation
            visualSpeed = lerp(visualSpeed, gameState.speed, SPEED_LERP_FACTOR);
            
            // Move all environment objects with parallax effect
            Object.keys(environmentObjects).forEach(category => {
                environmentObjects[category].forEach((obj, index) => {
                    if (obj && obj.userData) {
                        const parallaxSpeed = visualSpeed * obj.userData.parallaxSpeed;
                        obj.position.z += parallaxSpeed;
                        
                        // Reset object position when it goes too far
                        if (obj.position.z > 50) {
                            // Calculate new spawn position based on object type
                            let resetDistance = -150;
                            if (obj.userData.type === 'building') {
                                resetDistance = -200 - Math.random() * 50;
                            } else if (obj.userData.type === 'streetLamp') {
                                resetDistance = -120;
                            } else if (obj.userData.type === 'streetLine') {
                                resetDistance = -120;
                            }
                            
                            obj.position.z = resetDistance;
                            
                            // Add some variation for buildings
                            if (obj.userData.type === 'building') {
                                // Randomize building properties
                                const side = obj.position.x < 0 ? 'left' : 'right';
                                const baseX = side === 'left' ? -15 : 15;
                                obj.position.x = baseX + (Math.random() - 0.5) * 8;
                                
                                // Update parallax speed slightly for variation
                                obj.userData.parallaxSpeed = 0.7 + Math.random() * 0.2;
                            }
                        }
                    }
                });
            });
        }
        
        // Dynamic audio system that responds to speed
        let lastEngineTime = 0;
        function updateDynamicAudio() {
            const currentTime = performance.now();
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Engine sound every 800ms, pitch increases with speed
            if (currentTime - lastEngineTime > 800) {
                audioManager.play('engine');
                lastEngineTime = currentTime;
            }
            
            // High-speed wind effects
            if (speedRatio > 0.7 && Math.random() > 0.95) {
                // Occasional high-speed wind whoosh
                audioManager.createNoise(0.08, 4000 + speedRatio * 2000);
            }
            
            // Master volume adjustment based on speed for intensity
            const baseVolume = 0.3;
            const speedVolume = baseVolume * (0.8 + speedRatio * 0.4);
            if (audioManager.audioContext && audioManager.masterGain) {
                audioManager.masterGain.gain.setValueAtTime(speedVolume, audioManager.audioContext.currentTime);
            }
        }
        
        // Enhanced motion blur effect at high speeds
        function updateVisualEffects() {
            const speedRatio = visualSpeed / gameState.maxSpeed;
            
            // Dynamic fog based on speed
            if (scene.fog) {
                scene.fog.near = 20 - speedRatio * 10; // Closer fog at high speed
                scene.fog.far = 60 + speedRatio * 20; // Extended range
            }
            
            // Camera FOV effect for speed sensation
            const baseFov = 60;
            const speedFov = baseFov + speedRatio * 15; // Wider FOV at high speed
            camera.fov = lerp(camera.fov, speedFov, 0.02);
            camera.updateProjectionMatrix();
            
            // Enhanced camera shake at high speeds
            if (speedRatio > 0.7) {
                const shakeIntensity = (speedRatio - 0.7) * 0.1;
                gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, shakeIntensity);
            }
        }
        
        // 🔧 CRITICAL: 100% Ground Position Validation Function
        function validatePlayerGroundPosition() {
            // Only validate when player should be on ground
            if (gameState.playerAction === 'running' || gameState.playerAction === 'ducking') {
                const tolerance = 0.01;  // Very small tolerance for floating point precision
                
                // Check if player is floating above ground
                if (Math.abs(gameState.playerY) > tolerance) {
                    console.warn(`🚨 [JumpFix] Player floating detected: Y=${gameState.playerY}, forcing to ground`);
                    gameState.playerY = 0;
                    gameState.jumpVelocity = 0;
                    
                    // Also correct the mesh position
                    if (player) {
                        player.position.y = 0;
                    }
                    // playerGroup is local variable, using global player instead
                }
                
                // Double-check mesh positions match gameState
                if (player && Math.abs(player.position.y - gameState.playerY) > tolerance) {
                    console.warn(`🔧 [JumpFix] Player mesh desync: gameState.Y=${gameState.playerY}, mesh.Y=${player.position.y}`);
                    player.position.y = gameState.playerY;
                }
                
                // playerGroup check removed - using global player variable instead
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Calculate delta time for smooth movement
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            if (gameState.isPlaying) {
                // Update player position
                const targetX = LANE_POSITIONS[gameState.playerLane];
                player.position.x += (targetX - player.position.x) * 0.1;
                
                // Handle jumping - FIXED: Use proper deltaTime for frame-independent physics
                if (gameState.playerAction === 'jumping') {
                    const deltaTimeSeconds = deltaTime / 1000; // Convert to seconds
                    gameState.playerY += gameState.jumpVelocity * deltaTimeSeconds;
                    gameState.jumpVelocity -= 30 * deltaTimeSeconds; // Gravity in units/second²
                    
                    // BUGFIX: Maximum jump duration safety check
                    const jumpDuration = Date.now() - gameState.jumpStartTime;
                    if (jumpDuration > gameState.maxJumpDuration) {
                        console.warn('Jump duration exceeded, forcing landing');
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                    }
                    
                    // Landing with 100% Position 0 guarantee
                    if (gameState.playerY <= 0) {
                        gameState.playerY = 0;  // CRITICAL: Force exact position 0
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                        
                        // Additional validation: Ensure mesh position matches gameState
                        if (player && player.position.y !== 0) {
                            player.position.y = 0;
                            console.log('🔧 [JumpFix] Player mesh position corrected to 0');
                        }
                    }
                    
                    // BUGFIX: Enhanced safety check - trigger earlier at Y < -2
                    if (gameState.playerY < -2) {
                        console.warn('Player stuck in air, resetting position');
                        gameState.playerY = 0;  // CRITICAL: Force exact position 0
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                        
                        // Force mesh position to ground
                        if (player) {
                            player.position.y = 0;
                            console.log('🚨 [JumpFix] Emergency landing - Player forced to ground');
                        }
                        
                        // Landing Audio & Visual
                        audioManager.play('land');
                        
                        // Enhanced landing effects
                        const landingPos = new THREE.Vector3(player.position.x, 0.1, player.position.z);
                        
                        // Main landing dust
                        createParticleEffect(landingPos, 0xAAAAAA, 'landing');
                        
                        // Additional dust clouds
                        for (let i = 0; i < 4; i++) {
                            const angle = (i / 4) * Math.PI * 2;
                            const dustPos = landingPos.clone();
                            dustPos.x += Math.cos(angle) * 0.5;
                            dustPos.z += Math.sin(angle) * 0.5;
                            setTimeout(() => {
                                createParticleEffect(dustPos, 0x8B7355, 'dust');
                            }, i * 20);
                        }
                        
                        // Mini screen shake for landing
                        screenShake(0.05, 100);
                    }
                }
                
                // Handle ducking
                if (gameState.playerAction === 'ducking') {
                    player.scale.y = 0.5;
                } else {
                    player.scale.y = 1;
                }
                
                player.position.y = gameState.playerY;
                
                // 🔧 CRITICAL: 100% Position 0 Validation (Post-Jump Landing Check)
                validatePlayerGroundPosition();
                
                // Handle invulnerability
                if (gameState.invulnerable) {
                    gameState.invulnerabilityTime -= 16; // ~16ms per frame at 60fps
                    
                    // Flash effect
                    const flashRate = Math.sin(Date.now() * 0.02) > 0;
                    player.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = flashRate ? 0.3 : 0.7;
                        }
                    });
                    
                    if (gameState.invulnerabilityTime <= 0) {
                        gameState.invulnerable = false;
                        // Restore normal player appearance
                        player.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = 1.0;
                                child.material.transparent = false;
                            }
                        });
                        // Restore original colors
                        if (player.children[0]) player.children[0].material.color.setHex(0x4A90E2); // Body
                        if (player.children[1]) player.children[1].material.color.setHex(0xF5B041); // Head
                    }
                }
                
                // Move track with smooth speed
                track.children.forEach(segment => {
                    segment.position.z += visualSpeed;
                    if (segment.position.z > 10) {
                        segment.position.z -= 100;
                    }
                });
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Move obstacles with smooth speed
                obstacles.forEach((obstacle, index) => {
                    obstacle.mesh.position.z += visualSpeed;
                    obstacle.z = obstacle.mesh.position.z;
                    
                    if (obstacle.z > 10) {
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        addScore(10, 'shield_collision');
                    }
                });
                
                // ==================== BRIDGE SPAWNING CHECK ====================
                checkBridgeSpawning();
                
                // ==================== ENVIRONMENT-SPECIFIC OBSTACLE SPAWNING ====================
                
                // ==================== PROGRESSIVE DIFFICULTY SYSTEM ====================
                
                // Calculate game progress (0 to 1)
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 at start, 1 at end
                
                // Optimized obstacle spawning with better difficulty curve
                let baseSpawnRate, maxSpawnRate;
                
                if (gameProgress < 0.2) {
                    // Phase 1: Very gentle start (0-12s)
                    baseSpawnRate = 0.003;
                    maxSpawnRate = 0.008;
                } else if (gameProgress < 0.5) {
                    // Phase 2: Moderate challenge (12-30s)
                    baseSpawnRate = 0.008;
                    maxSpawnRate = 0.015;
                } else if (gameProgress < 0.8) {
                    // Phase 3: Challenging (30-48s)
                    baseSpawnRate = 0.012;
                    maxSpawnRate = 0.020;
                } else {
                    // Phase 4: Extreme finale (48-60s)
                    baseSpawnRate = 0.015;
                    maxSpawnRate = 0.025;
                }
                
                const phaseProgress = gameProgress < 0.2 ? gameProgress / 0.2 :
                                     gameProgress < 0.5 ? (gameProgress - 0.2) / 0.3 :
                                     gameProgress < 0.8 ? (gameProgress - 0.5) / 0.3 :
                                     (gameProgress - 0.8) / 0.2;
                
                const progressiveSpawnRate = baseSpawnRate + (maxSpawnRate - baseSpawnRate) * phaseProgress;
                
                // Speed multiplier adjusted for combo potential
                const speedRatio = gameState.speed / gameState.maxSpeed;
                const spawnSpeedMultiplier = 1 + speedRatio * 0.2; // Gentler speed scaling
                
                let spawnRate = progressiveSpawnRate * spawnSpeedMultiplier;
                
                // Dynamic adjustment based on player performance
                if (gameState.consecutiveAvoidances > 5) {
                    // Player is doing well, slightly increase challenge
                    spawnRate *= 1.1;
                } else if (gameState.lives === 1) {
                    // Player struggling, reduce difficulty slightly
                    spawnRate *= 0.85;
                }
                
                // Reduce spawn rate during bridge transitions
                if (gameState.environmentTransition) {
                    spawnRate *= 0.3;
                }
                
                if (Math.random() < spawnRate) {
                    // Simplified obstacle spawning
                    const jumpObstacles = ['lowbarrier', 'jumpblock', 'hurdleset'];
                    const duckObstacles = ['highbarrier', 'duckbeam', 'wallgap'];
                    const flexibleObstacles = ['spikes'];
                    const movingObstacles = ['rotatingblade', 'swinginghammer', 'movingwall', 'bouncingball', 'spinninglaser'];
                    
                    let type;
                    const rand = Math.random();
                    
                    // Progressive difficulty for obstacle types
                    // Early game: mostly simple obstacles
                    // Late game: more complex moving obstacles
                    let movingChance, complexChance;
                    
                    if (gameProgress < 0.3) {
                        // First 30% of game: mostly basic obstacles
                        movingChance = 0.02; // Very few moving obstacles
                        complexChance = 0.1; // Few complex obstacles
                    } else if (gameProgress < 0.6) {
                        // Middle 30%: gradually introduce moving obstacles
                        movingChance = 0.02 + (gameProgress - 0.3) * 0.3; // 2% to 11%
                        complexChance = 0.3;
                    } else {
                        // Final 40%: more challenging obstacles
                        movingChance = 0.11 + (gameProgress - 0.6) * 0.225; // 11% to 20%
                        complexChance = 0.5;
                    }
                    
                    if (rand < movingChance) {
                        // Moving obstacles (progressive introduction)
                        type = movingObstacles[Math.floor(Math.random() * movingObstacles.length)];
                    } else if (rand < movingChance + complexChance) {
                        // Complex static obstacles (hurdleset, highbarrier)
                        const complexObstacles = ['hurdleset', 'highbarrier'];
                        type = complexObstacles[Math.floor(Math.random() * complexObstacles.length)];
                    } else if (rand < movingChance + complexChance + 0.3) {
                        // Jump obstacles (basic)
                        type = jumpObstacles[Math.floor(Math.random() * jumpObstacles.length)];
                    } else if (rand < movingChance + complexChance + 0.6) {
                        // Duck obstacles (basic)
                        type = duckObstacles[Math.floor(Math.random() * duckObstacles.length)];
                    } else {
                        // Flexible obstacles (easiest)
                        type = flexibleObstacles[Math.floor(Math.random() * flexibleObstacles.length)];
                    }
                    
                    const lane = Math.floor(Math.random() * 3);
                    createObstacle(type, lane, -30);
                }
                
                // ==================== PROGRESSIVE POWER-UP & COIN SPAWNING ====================
                
                // Progressive Power-Up spawning (rare at start, more frequent later)
                const basePowerUpRate = 0.001; // Very low at start
                const maxPowerUpRate = 0.006; // Higher at end
                const progressivePowerUpRate = basePowerUpRate + (maxPowerUpRate - basePowerUpRate) * Math.pow(gameProgress, 1.5);
                
                if (Math.random() < progressivePowerUpRate && !gameState.activePowerUp) {
                    // Filter out largeMagnet from regular spawning
                    const powerUpTypes = Object.keys(POWER_UP_TYPES).filter(type => type !== 'largeMagnet');
                    let selectedType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    
                    // Special handling for magnet - sometimes spawn large magnet instead
                    if (selectedType === 'magnet' && Math.random() < 0.3) { // 30% chance for large magnet
                        selectedType = 'largeMagnet';
                    }
                    
                    const lane = Math.floor(Math.random() * 3);
                    
                    const powerUp = createSimplePowerUp(selectedType, lane, -35);
                    gameState.powerUps.push(powerUp);
                }
                
                // ENHANCED: Smart Collectible Spawning with Obstacle Avoidance
                // SENIOR DEVELOPER RULE: ANTI-HINDERNISSE-NÄHE-SYSTEM
                // Helper function to check if lane is safe for collectible spawning
                const isLaneClearForCollectible = (lane, zPosition, safeDistance = 40) => {
                    const MINIMUM_DISTANCE = 40; // Erhöht von 12 auf 40
                    const PARALLEL_CHECK_RANGE = 20; // Prüfe 20 Einheiten vor/zurück
                    
                    // Prüfe ALLE Hindernisse in der Nähe
                    for (let obstacle of obstacles) {
                        if (!obstacle || !obstacle.position) continue;
                        
                        const distance = Math.abs(obstacle.position.z - zPosition);
                        const laneDistance = Math.abs(obstacle.position.x - LANE_POSITIONS[lane]);
                        
                        // REGEL: Mindestabstand einhalten
                        if (distance < MINIMUM_DISTANCE && laneDistance < 2) {
                            return false;
                        }
                        
                        // REGEL: Keine parallelen Spawns
                        if (distance < PARALLEL_CHECK_RANGE && laneDistance < 2) {
                            return false;
                        }
                    }
                    
                    return true;
                };
                
                // COLLECTIBLE SYSTEM RULES: 10 Kiwis + 10 Broccolis + unbegrenzt Stars
                // Dynamic spawn rate based on speed (reduce at high speeds)
                const baseCoinRate = 0.015; // Reduziert für exakte Anzahl-Kontrolle
                const maxCoinRate = 0.04; // Reduziert für bessere Kontrolle
                const speedFactor = Math.max(0.4, 1 - (gameState.speed - 100) / 300); // Reduce spawn at high speeds
                const progressiveCoinRate = (baseCoinRate + (maxCoinRate - baseCoinRate) * Math.pow(gameProgress, 1.1)) * speedFactor;
                
                if (Math.random() < progressiveCoinRate) {
                    // Progressive kiwi pattern complexity
                    let pattern;
                    const patternRand = Math.random();
                    
                    if (gameProgress < 0.3) {
                        // Early game: mostly single kiwis
                        pattern = patternRand < 0.8 ? 'single' : 'line';
                    } else if (gameProgress < 0.6) {
                        // Mid game: introduce more patterns
                        if (patternRand < 0.5) {
                            pattern = 'single';
                        } else if (patternRand < 0.8) {
                            pattern = 'line';
                        } else {
                            pattern = 'arc';
                        }
                    } else {
                        // Late game: more complex patterns, more rewards
                        if (patternRand < 0.3) {
                            pattern = 'single';
                        } else if (patternRand < 0.6) {
                            pattern = 'line';
                        } else {
                            pattern = 'arc';
                        }
                    }
                    
                    // SENIOR DEVELOPER RULE: EXAKT 10 Kiwis + 10 Broccolis + unbegrenzt Stars
                    // Check collected items: 10 Kiwis + 10 Broccolis = 20 total
                    const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
                    if (collectedTotal >= 20) {
                        // Max collectibles collected, only spawn stars now
                        // TODO: Implement star spawning after obstacle avoidance
                        return;
                    }
                    
                    // Use collected counts for spawn logic, not active counts
                    const kiwiCount = gameState.collectedKiwis;
                    const broccoliCount = gameState.collectedBroccolis;
                    
                    // Determine what to spawn based on 10:10 target ratio (50:50)
                    let isKiwi;
                    if (kiwiCount >= 10) {
                        isKiwi = false; // Force broccoli if we have 10 kiwis
                    } else if (broccoliCount >= 10) {
                        isKiwi = true; // Force kiwi if we have 10 broccolis
                    } else {
                        // Balanced spawning for 10:10 ratio (50% kiwi, 50% broccoli)
                        const targetRatio = 0.5; // 50:50 ratio
                        const currentRatio = kiwiCount / (kiwiCount + broccoliCount + 1);
                        
                        // Balance towards maintaining 50:50 ratio
                        if (currentRatio < targetRatio) {
                            isKiwi = Math.random() < 0.7; // Slight bias toward kiwis
                        } else {
                            isKiwi = Math.random() < 0.3; // Slight bias toward broccolis
                        }
                    }
                    
                    console.log(`🎯 Spawning ${isKiwi ? 'Kiwi' : 'Broccoli'} - Pattern: ${pattern} (K:${kiwiCount}, B:${broccoliCount})`);
                    
                    if (pattern === 'single') {
                        // ENHANCED: Find safe lanes for spawning
                        const safeLanes = [];
                        const baseSpawnZ = -50 - (gameState.speed - 100) * 0.02; // Weiter weg für bessere Sicherheit
                        
                        for (let lane = 0; lane < 3; lane++) {
                            if (isLaneClearForCollectible(lane, baseSpawnZ)) {
                                safeLanes.push(lane);
                            }
                        }
                        
                        if (safeLanes.length > 0) {
                            const lane = safeLanes[Math.floor(Math.random() * safeLanes.length)];
                            if (isKiwi) {
                                const kiwi = createSimpleKiwi(lane, baseSpawnZ);
                                gameState.kiwis.push(kiwi);
                            } else {
                                const broccoli = createBroccoli(lane, baseSpawnZ, 'single');
                                gameState.broccolis.push(broccoli);
                            }
                        }
                    } else if (pattern === 'line') {
                        // ENHANCED: Smart line spawning with obstacle avoidance
                        const baseSpawnZ = -50 - (gameState.speed - 100) * 0.02;
                        const safeLanes = [];
                        
                        for (let lane = 0; lane < 3; lane++) {
                            if (isLaneClearForCollectible(lane, baseSpawnZ)) {
                                safeLanes.push(lane);
                            }
                        }
                        
                        // FIXED: Maximum 2 collectibles per line, never all 3 simultaneously
                        if (safeLanes.length >= 2) {
                            // Randomly select max 2 lanes from safe lanes to prevent overwhelming patterns
                            const maxLanes = Math.min(2, safeLanes.length);
                            const selectedLanes = [];
                            
                            // Shuffle and select up to 2 lanes
                            const shuffledLanes = [...safeLanes].sort(() => Math.random() - 0.5);
                            for (let i = 0; i < maxLanes; i++) {
                                selectedLanes.push(shuffledLanes[i]);
                            }
                            
                            console.log(`🎯 LINE PATTERN: Spawning in ${selectedLanes.length} lanes (${selectedLanes.join(',')}) out of ${safeLanes.length} safe lanes`);
                            
                            for (const lane of selectedLanes) {
                                // BUGFIX: Check collected counts, not spawned total
                                const currentCollectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
                                if (currentCollectedTotal >= 37) break; // Safety check
                                
                                // FIXED: Use collected counts for proper balance
                                const currentKiwiCount = gameState.collectedKiwis;
                                const currentBroccoliCount = gameState.collectedBroccolis;
                                
                                let spawnKiwi;
                                if (currentKiwiCount >= 30) {
                                    spawnKiwi = false; // Force broccoli if we have 30 kiwis
                                } else if (currentBroccoliCount >= 7) {
                                    spawnKiwi = true; // Force kiwi if we have 7 broccolis
                                } else {
                                    spawnKiwi = Math.random() < 0.5; // 50/50 if both below limits
                                }
                                
                                console.log(`🎯 LINE BALANCE: K:${currentKiwiCount}, B:${currentBroccoliCount}, spawning ${spawnKiwi ? 'Kiwi' : 'Broccoli'}`);
                                
                                if (spawnKiwi) {
                                    const spacing = gameState.speed > 150 ? 4 : 3; // Increased spacing for better collection
                                    const kiwi = createSimpleKiwi(lane, baseSpawnZ - (lane * spacing));
                                    gameState.kiwis.push(kiwi);
                                } else {
                                    const spacing = gameState.speed > 150 ? 4 : 3; // Increased spacing for better collection
                                    const broccoli = createBroccoli(lane, baseSpawnZ - (lane * spacing), 'line');
                                    gameState.broccolis.push(broccoli);
                                }
                            }
                        }
                    } else if (pattern === 'arc') {
                        // FIXED: Smart arc spawning - maximum 2 collectibles, never all 3
                        const baseSpawnZ = -50 - (gameState.speed - 100) * 0.02;
                        const lanes = gameProgress > 0.5 ? [0, 1, 2] : [Math.floor(Math.random() * 2), Math.floor(Math.random() * 2) + 1];
                        const safeLanes = lanes.filter(lane => isLaneClearForCollectible(lane, baseSpawnZ));
                        
                        if (safeLanes.length >= 2) {  // Only spawn arc if at least 2 safe lanes
                            // FIXED: Limit to maximum 2 collectibles in arc pattern
                            const maxArcCollectibles = Math.min(2, safeLanes.length);
                            const selectedLanes = safeLanes.slice(0, maxArcCollectibles);
                            
                            console.log(`🌀 ARC PATTERN: Spawning in ${selectedLanes.length} lanes (${selectedLanes.join(',')}) out of ${safeLanes.length} safe lanes`);
                            
                            selectedLanes.forEach((lane, index) => {
                                // BUGFIX: Check collected counts, not spawned total
                                const currentCollectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
                                if (currentCollectedTotal >= 37) return; // Safety check
                                
                                // FIXED: Use collected counts for proper balance
                                const currentKiwiCount = gameState.collectedKiwis;
                                const currentBroccoliCount = gameState.collectedBroccolis;
                                
                                let spawnKiwi;
                                if (currentKiwiCount >= 30) {
                                    spawnKiwi = false; // Force broccoli if we have 30 kiwis
                                } else if (currentBroccoliCount >= 7) {
                                    spawnKiwi = true; // Force kiwi if we have 7 broccolis
                                } else {
                                    spawnKiwi = Math.random() < 0.5; // 50/50 if both below limits
                                }
                                
                                console.log(`🌀 ARC BALANCE: K:${currentKiwiCount}, B:${currentBroccoliCount}, spawning ${spawnKiwi ? 'Kiwi' : 'Broccoli'}`);
                                
                                const spacing = gameState.speed > 150 ? 3 : 2; // Increased spacing for better collection
                                if (spawnKiwi) {
                                    const kiwi = createSimpleKiwi(lane, baseSpawnZ - (index * spacing));
                                    gameState.kiwis.push(kiwi);
                                } else {
                                    const broccoli = createBroccoli(lane, baseSpawnZ - (index * spacing), 'arc');
                                    gameState.broccolis.push(broccoli);
                                }
                            });
                        }
                    }
                }
                
                // Update Power-Ups
                gameState.powerUps.forEach((powerUp, index) => {
                    powerUp.mesh.position.z += visualSpeed;
                    powerUp.z = powerUp.mesh.position.z;
                    
                    // Remove if passed player
                    if (powerUp.z > 10) {
                        scene.remove(powerUp.mesh);
                        gameState.powerUps.splice(index, 1);
                    }
                    
                    // Animate power-up rotation and floating
                    powerUp.animationTime += deltaTime * 0.001;
                    
                    // Special animation for magnets
                    if (powerUp.type === 'magnet' || powerUp.type === 'largeMagnet') {
                        // Wobble rotation for magnet
                        powerUp.mesh.rotation.y += 0.015;
                        powerUp.mesh.rotation.z = Math.PI / 6 + Math.sin(powerUp.animationTime * 2) * 0.1;
                        
                        // Different floating height for large magnet
                        if (powerUp.type === 'largeMagnet') {
                            powerUp.mesh.position.y = powerUp.baseY + Math.sin(powerUp.animationTime * 3) * 0.4;
                            
                            // Animate the pulsing ring
                            if (powerUp.mesh.ring) {
                                const pulseScale = 1 + Math.sin(powerUp.animationTime * 4) * 0.2;
                                powerUp.mesh.ring.scale.set(pulseScale, pulseScale, 1);
                                powerUp.mesh.ring.material.opacity = 0.3 + Math.sin(powerUp.animationTime * 3) * 0.2;
                            }
                        } else {
                            powerUp.mesh.position.y = powerUp.baseY + Math.sin(powerUp.animationTime * 3) * 0.2;
                        }
                    } else {
                        // Regular rotation for other power-ups
                        powerUp.mesh.rotation.y += 0.02;
                        powerUp.mesh.position.y = powerUp.baseY + Math.sin(powerUp.animationTime * 3) * 0.3;
                    }
                    
                    // Update particle effects
                    if (powerUp.particles) {
                        powerUp.particles.rotation.y += 0.01;
                    }
                });
                
                // Update Kiwis
                gameState.kiwis.forEach((kiwi, index) => {
                    kiwi.mesh.position.z += visualSpeed;
                    kiwi.z = kiwi.mesh.position.z;
                    
                    // Remove if passed player
                    if (kiwi.z > 10) {
                        scene.remove(kiwi.mesh);
                        gameState.kiwis.splice(index, 1);
                    }
                    
                    // Animate kiwi wobble and subtle floating
                    kiwi.animationTime += deltaTime * 0.001;
                    // Wobble rotation instead of spin
                    kiwi.mesh.rotation.z = Math.sin(kiwi.animationTime * 3) * 0.15;
                    kiwi.mesh.rotation.x = Math.cos(kiwi.animationTime * 2) * 0.1;
                    // Subtle bounce
                    const baseY = 1.2;
                    kiwi.mesh.position.y = baseY + Math.sin(kiwi.animationTime * 4) * 0.1;
                });
                
                // Update Broccolis (similar to kiwis)
                gameState.broccolis.forEach((broccoli, index) => {
                    broccoli.mesh.position.z += visualSpeed;
                    broccoli.z = broccoli.mesh.position.z;
                    
                    // Remove if passed player
                    if (broccoli.z > 10) {
                        scene.remove(broccoli.mesh);
                        gameState.broccolis.splice(index, 1);
                    }
                    
                    // Animate broccoli - different pattern than kiwis
                    broccoli.animationTime += deltaTime * 0.001;
                    // Gentle swaying motion for broccoli
                    broccoli.mesh.rotation.y = Math.sin(broccoli.animationTime * 2) * 0.1;
                    broccoli.mesh.rotation.z = Math.cos(broccoli.animationTime * 1.5) * 0.05;
                    // Slight vertical movement
                    const baseY = 1.0;
                    broccoli.mesh.position.y = baseY + Math.sin(broccoli.animationTime * 3) * 0.08;
                });
                
                // Handle Power-Up Time Remaining
                if (gameState.activePowerUp && gameState.powerUpTimeRemaining > 0) {
                    gameState.powerUpTimeRemaining -= deltaTime;
                    if (gameState.powerUpTimeRemaining <= 0) {
                        deactivatePowerUp();
                    }
                    updatePowerUpUI();
                }
                
                // ==================== END POWER-UP & COIN SPAWNING ====================
                
                // ==================== BRIDGE ENVIRONMENT UPDATE ====================
                
                updateBridgeEnvironment(deltaTime);
                
                // ==================== END BRIDGE ENVIRONMENT UPDATE ====================
                
                // Update camera with shake effect
                const baseX = player.position.x * 0.3;
                const baseY = 3 + Math.sin(Date.now() * 0.002) * 0.05;
                const baseZ = 8;
                
                // Apply screen shake
                const shakeX = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeY = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeZ = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 0.5;
                
                camera.position.x += (baseX + shakeX - camera.position.x) * 0.05;
                camera.position.y = baseY + shakeY;
                camera.position.z = baseZ + shakeZ;
                
                camera.lookAt(player.position.x * 0.2, 1, -3);
                
                // Update game timer
                const currentTime = Date.now();
                const elapsedTime = (currentTime - gameState.gameStartTime) / 1000;
                gameState.timeRemaining = Math.max(0, gameState.gameTime - elapsedTime);
                
                // Check for victory (survived 60 seconds!)
                if (gameState.timeRemaining <= 0 && !gameState.isVictory) {
                    victoryGame();
                    return;
                }
                
                // 🎮 SPEED BALANCING: Optimierte Geschwindigkeitskurve für alle Spieler-Levels
                // Base: 0.05 (war 0.08) | Max: 0.25 (war 0.45) | Sanftere Kurve für bessere Spielbarkeit
                // Progressive speed increase - optimized curve for better gameplay
                const timeProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 to 1
                
                // 🎮 BALANCED: Sanftere Geschwindigkeitskurve für bessere Spielbarkeit
                let speedMultiplier;
                if (timeProgress < 0.3) {
                    // Phase 1: Sehr sanfter Start (0-18s) - Mehr Zeit zum Eingewöhnen
                    speedMultiplier = 1 + timeProgress * 1.5; // 1x to 1.45x (sanfter)
                } else if (timeProgress < 0.6) {
                    // Phase 2: Moderate Steigerung (18-36s) - Kontrollierbare Beschleunigung
                    speedMultiplier = 1.45 + (timeProgress - 0.3) * 2; // 1.45x to 2.05x (moderater)
                } else if (timeProgress < 0.85) {
                    // Phase 3: Herausfordernd aber fair (36-51s) - Reduzierte Extreme
                    speedMultiplier = 2.05 + (timeProgress - 0.6) * 2.5; // 2.05x to 2.68x (viel moderater)
                } else {
                    // Phase 4: Finale - Herausfordernd aber nicht unmöglich (51-60s)
                    speedMultiplier = 2.68 + (timeProgress - 0.85) * 2; // 2.68x to 2.98x (deutlich reduziert)
                }
                
                // Apply Speed Boost Power-Up multiplier
                if (gameState.speedBoostActive) {
                    speedMultiplier *= 1.5; // 50% speed increase
                }
                
                gameState.speed = gameState.baseSpeed * speedMultiplier;
                gameState.speed = Math.min(gameState.speed, gameState.maxSpeed);
                
                // Update total distance (for milestones)
                gameState.totalDistance += gameState.speed * deltaTime * 10;
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Update dynamic audio based on speed
                updateDynamicAudio();
                
                // Update moving obstacles animations
                updateMovingObstacles(deltaTime);
                
                // Check collisions
                checkCollisions();
                
                // Check for milestones
                checkMilestones();
                
                // CRITICAL FIX: Process centralized score queue instead of individual updates
                processScoreQueue();
                
                // Keep distance-based scoring (converted to use addScore)
                const timeSinceLastUpdate = (currentTime - (gameState.lastDistanceScore || 0)) / 1000;
                if (timeSinceLastUpdate >= 0.1) { // Every 100ms
                    const distanceScore = Math.floor(gameState.speed * timeSinceLastUpdate * 10);
                    addScore(distanceScore, 'distance');
                    gameState.lastDistanceScore = currentTime;
                }
                
                updateUI();
            }
            
            renderer.render(scene, camera);
        }

        // Handle near miss detection
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            const currentTime = performance.now();
            
            // Prevent multiple near misses for the same obstacle
            if (obstacle.nearMissHandled) return;
            obstacle.nearMissHandled = true;
            
            // Update near miss streak
            if (currentTime - gameState.lastNearMissTime < 5000) { // 5 second window
                gameState.nearMissStreak++;
            } else {
                gameState.nearMissStreak = 1;
            }
            gameState.lastNearMissTime = currentTime;
            
            // Calculate near miss bonus based on distance and streak
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const precision = 1 - (distance / 0.3); // 0.3 is max near miss distance
            let nearMissBonus = Math.floor(50 + (precision * 50)); // 50-100 base points
            
            // Streak multiplier
            nearMissBonus *= Math.min(gameState.nearMissStreak, 5); // Max 5x multiplier
            
            // Add to score
            addScore(nearMissBonus, 'near_miss_bonus');
            
            // Update near miss multiplier
            gameState.nearMissMultiplier = Math.min(gameState.nearMissStreak * 0.2 + 1, 2); // Max 2x
            
            // Show near miss UI
            showNearMissUI(nearMissBonus, gameState.nearMissStreak);
            
            // Audio feedback
            audioManager.createTone(440 + (gameState.nearMissStreak * 110), 0.1, 'sine');
            
            // Visual effect
            createParticleEffect(
                player.position.clone(),
                0xFFD700,
                'nearMiss'
            );
            
            // Camera shake for dramatic effect
            gameState.cameraShakeIntensity = 0.05;
            setTimeout(() => { gameState.cameraShakeIntensity = 0; }, 200);
        }
        
        // Show near miss UI feedback
        function showNearMissUI(bonus, streak) {
            const nearMissDisplay = document.getElementById('nearMissDisplay');
            const nearMissCount = document.getElementById('nearMissCount');
            const nearMissBonus = document.getElementById('nearMissBonus');
            
            if (nearMissDisplay) {
                nearMissDisplay.style.display = 'block';
                nearMissCount.textContent = streak;
                nearMissBonus.textContent = bonus;
                
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    nearMissDisplay.style.display = 'none';
                }, 2000);
            }
        }
        
        // Check and award milestone rewards (FIXED: Based on time, not exploitable score)
        function checkMilestones() {
            const gameTimeElapsed = (performance.now() - gameState.gameStartTime) / 1000;
            // ==================== 10-LEVEL PROGRESSION SYSTEM ====================
            
            // Level progression based on score milestones (every 1000 points)
            const levelThreshold = 1000; // Points needed per level
            const targetLevel = Math.min(10, Math.floor(gameState.score / levelThreshold) + 1);
            
            // Check for level progression
            if (targetLevel > gameState.currentLevel && targetLevel <= 10) {
                const previousLevel = gameState.currentLevel;
                gameState.currentLevel = targetLevel;
                
                console.log(`🎮 [LevelProgression] Advancing from Level ${previousLevel} to Level ${targetLevel}!`);
                
                // Load new level using LevelManagerPro
                if (window.LevelManagerPro) {
                    LevelManagerPro.loadLevel(targetLevel).then(success => {
                        if (success) {
                            console.log(`✅ [LevelProgression] Successfully loaded Level ${targetLevel}`);
                            
                            // Show level progression UI
                            showLevelProgressionUI(targetLevel, previousLevel);
                            
                            // Award level completion bonus
                            const levelBonus = targetLevel * 200; // Increasing bonus per level
                            addScore(levelBonus, `level_${targetLevel}_bonus`);
                            
                            // Update UI
                            updateLevelDisplay(targetLevel);
                            
                        } else {
                            console.error(`❌ [LevelProgression] Failed to load Level ${targetLevel}`);
                            // Fallback to previous level
                            gameState.currentLevel = previousLevel;
                        }
                    }).catch(error => {
                        console.error(`❌ [LevelProgression] Error loading Level ${targetLevel}:`, error);
                        gameState.currentLevel = previousLevel;
                    });
                } else {
                    console.warn('⚠️ [LevelProgression] LevelManagerPro not available, using fallback');
                    showLevelProgressionUI(targetLevel, previousLevel);
                    updateLevelDisplay(targetLevel);
                }
            }
            
            // Original milestone system (now secondary to level progression)
            const milestoneInterval = 10; // Every 10 seconds of actual gameplay
            const currentMilestone = Math.floor(gameTimeElapsed / milestoneInterval) * milestoneInterval;
            
            // Only award milestone if enough time has passed AND we haven't awarded this one yet
            if (currentMilestone > gameState.lastMilestone && currentMilestone > 0 && gameTimeElapsed >= milestoneInterval) {
                gameState.lastMilestone = currentMilestone;
                
                // Calculate milestone bonus (reduced since levels provide main progression)
                const milestoneBonus = Math.min(50, currentMilestone); // Reduced bonus
                addScore(milestoneBonus, 'milestone_bonus');
                
                // Show milestone UI (only if not in level transition)
                if (gameState.currentLevel === Math.floor(gameState.score / levelThreshold) + 1) {
                    showMilestoneUI(currentMilestone, milestoneBonus);
                }
                
                // Audio celebration
                audioManager.play('powerup');
                audioManager.createTone(523, 0.2, 'sine'); // C5
                setTimeout(() => audioManager.createTone(659, 0.2, 'sine'), 100); // E5
                setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 200); // G5
                
                // Visual celebration
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        createParticleEffect(
                            new THREE.Vector3(
                                player.position.x + (Math.random() - 0.5) * 2,
                                player.position.y + 2,
                                player.position.z
                            ),
                            [0x00FF00, 0xFFD700, 0xFF00FF][i],
                            'success'
                        );
                    }, i * 100);
                }
                
                // BUGFIX: Life awards based on actual game time, not score-based milestones
                const gameTimeElapsed = (performance.now() - gameState.gameStartTime) / 1000;
                const lifeAwardInterval = 20; // Award life every 20 seconds
                const expectedLives = Math.min(5, 3 + Math.floor(gameTimeElapsed / lifeAwardInterval));
                
                if (gameState.lives < expectedLives && currentMilestone >= 1500) {
                    gameState.lives = expectedLives;
                    console.log(`Extra life awarded! Lives: ${gameState.lives} (time: ${gameTimeElapsed.toFixed(1)}s)`);
                }
            }
        }
        
        // Show milestone UI feedback
        function showMilestoneUI(distance, bonus) {
            const milestoneDisplay = document.getElementById('milestoneDisplay');
            const milestoneText = document.getElementById('milestoneText');
            const milestoneBonus = document.getElementById('milestoneBonus');
            const milestoneIcon = document.getElementById('milestoneIcon');
            
            if (milestoneDisplay) {
                milestoneDisplay.style.display = 'block';
                milestoneText.textContent = `${distance}m!`;
                milestoneBonus.textContent = bonus;
                
                // Special icons for major milestones
                if (distance >= 3000) {
                    milestoneIcon.textContent = '🏆';
                } else if (distance >= 2000) {
                    milestoneIcon.textContent = '⭐';
                } else if (distance >= 1000) {
                    milestoneIcon.textContent = '🎯';
                } else {
                    milestoneIcon.textContent = '🏁';
                }
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    milestoneDisplay.style.display = 'none';
                }, 3000);
            }
        }
        
        // ==================== LEVEL PROGRESSION UI FUNCTIONS ====================
        
        function showLevelProgressionUI(newLevel, previousLevel) {
            console.log(`🎮 [UI] Showing level progression: ${previousLevel} → ${newLevel}`);
            
            // Use milestone display for level progression (better user experience)
            const milestoneDisplay = document.getElementById('milestoneDisplay');
            const milestoneText = document.getElementById('milestoneText');
            const milestoneBonus = document.getElementById('milestoneBonus');
            const milestoneIcon = document.getElementById('milestoneIcon');
            
            if (milestoneDisplay) {
                milestoneDisplay.style.display = 'block';
                milestoneDisplay.style.color = '#FFD700'; // Gold color for level progression
                milestoneDisplay.style.fontSize = '28px'; // Larger for level progression
                milestoneDisplay.style.background = 'rgba(255, 215, 0, 0.2)'; // Gold background
                milestoneDisplay.style.border = '2px solid #FFD700'; // Gold border
                milestoneDisplay.style.borderRadius = '12px';
                milestoneDisplay.style.padding = '20px';
                milestoneDisplay.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.5)';
                
                milestoneText.textContent = `LEVEL ${newLevel}!`;
                milestoneBonus.textContent = `+${newLevel * 200} Punkte!`;
                
                // Level-specific icons
                const levelIcons = ['🚇', '🌃', '🚀', '🌴', '❄️', '🌊', '🏜️', '🌲', '🌋', '💎'];
                milestoneIcon.textContent = levelIcons[newLevel - 1] || '🎮';
                
                // Special level names
                const levelNames = [
                    'Subway Daylight',
                    'Cyberpunk Night', 
                    'Space Station',
                    'Jungle Adventure',
                    'Ice Crystal',
                    'Underwater',
                    'Desert Storm',
                    'Forest Twilight',
                    'Volcano',
                    'Crystal Dimension'
                ];
                
                // Add level name subtitle
                const subtitle = document.createElement('div');
                subtitle.style.fontSize = '16px';
                subtitle.style.marginTop = '10px';
                subtitle.style.color = '#FFF';
                subtitle.textContent = levelNames[newLevel - 1] || `Level ${newLevel}`;
                milestoneDisplay.appendChild(subtitle);
                
                // Level progression sound effect
                if (window.audioManager) {
                    audioManager.play('powerup');
                    // Level progression chord
                    audioManager.createTone(523, 0.3, 'sine'); // C5
                    setTimeout(() => audioManager.createTone(659, 0.3, 'sine'), 150); // E5
                    setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 300); // G5
                    setTimeout(() => audioManager.createTone(1047, 0.5, 'sine'), 450); // C6
                }
                
                // Auto-hide after 4 seconds (longer for level progression)
                setTimeout(() => {
                    milestoneDisplay.style.display = 'none';
                    // Reset styles
                    milestoneDisplay.style.color = '#00FF00';
                    milestoneDisplay.style.fontSize = '24px';
                    milestoneDisplay.style.background = '';
                    milestoneDisplay.style.border = '';
                    milestoneDisplay.style.borderRadius = '';
                    milestoneDisplay.style.padding = '';
                    milestoneDisplay.style.boxShadow = '';
                    // Remove subtitle
                    if (subtitle.parentNode) {
                        subtitle.parentNode.removeChild(subtitle);
                    }
                }, 4000);
            }
        }
        
        function updateLevelDisplay(currentLevel) {
            // Update UI to show current level
            const ui = document.getElementById('ui');
            if (ui) {
                const levelDisplay = document.getElementById('levelDisplay') || (() => {
                    const div = document.createElement('div');
                    div.id = 'levelDisplay';
                    div.style.fontSize = '18px';
                    div.style.marginTop = '5px';
                    div.style.color = '#FFD700';
                    ui.appendChild(div);
                    return div;
                })();
                
                levelDisplay.textContent = `Level ${currentLevel}/10`;
            }
            
            console.log(`🎮 [UI] Updated level display to Level ${currentLevel}/10`);
        }
        
        // Update visual effects based on speed and game state
        function updateVisualEffects() {
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Update fog density based on speed
            gameState.targetFogDensity = 0.002 + (speedRatio * 0.003);
            gameState.currentFogDensity += (gameState.targetFogDensity - gameState.currentFogDensity) * 0.1;
            if (scene.fog) {
                scene.fog.density = gameState.currentFogDensity;
            }
            
            // Speed lines effect
            if (speedRatio > 0.5) {
                gameState.speedLineIntensity = Math.min((speedRatio - 0.5) * 2, 1);
                createSpeedLines();
            }
            
            // Vignette effect at high speed
            const vignetteOverlay = document.getElementById('vignetteOverlay');
            if (vignetteOverlay) {
                if (speedRatio > 0.7) {
                    vignetteOverlay.classList.add('active');
                } else {
                    vignetteOverlay.classList.remove('active');
                }
            }
            
            // ENHANCED: Magnet vignette effect (blue/magnetic instead of black)
            const magnetVignette = document.getElementById('magnetVignette');
            if (magnetVignette) {
                if (gameState.magnetActive) {
                    magnetVignette.classList.add('active');
                    console.log('🧲 MAGNET VIGNETTE: Activated - Blue magnetic effect active');
                } else {
                    magnetVignette.classList.remove('active');
                }
            }
            
            // Motion blur simulation
            if (speedRatio > 0.8 && !gameState.motionBlurActive) {
                gameState.motionBlurActive = true;
                renderer.domElement.style.filter = `blur(${(speedRatio - 0.8) * 2}px)`;
            } else if (speedRatio <= 0.8 && gameState.motionBlurActive) {
                gameState.motionBlurActive = false;
                renderer.domElement.style.filter = 'none';
            }
            
            // Camera shake at extreme speeds
            if (speedRatio > 0.9) {
                gameState.cameraShakeIntensity = (speedRatio - 0.9) * 0.5;
            }
            
            // Update point lights intensity based on environment
            const lights = scene.children.filter(child => child.type === 'PointLight');
            lights.forEach(light => {
                if (gameState.currentEnvironment === 'tunnel') {
                    light.intensity = 0.8;
                } else {
                    light.intensity = 0.5;
                }
            });
        }
        
        // Create speed lines for high-speed effect
        function createSpeedLines() {
            const speedLinesContainer = document.getElementById('speedLines');
            if (!speedLinesContainer || Math.random() > gameState.speedLineIntensity) return;
            
            const speedLine = document.createElement('div');
            speedLine.className = 'speed-line';
            speedLine.style.left = Math.random() * 100 + '%';
            speedLine.style.opacity = gameState.speedLineIntensity;
            
            speedLinesContainer.appendChild(speedLine);
            
            // Remove after animation
            setTimeout(() => {
                speedLine.remove();
            }, 300);
        }
        
        // Enhanced particle effect for collisions
        function createCollisionParticles(position, obstacleType) {
            // Main collision effect
            createParticleEffect(position, 0xFF4444, 'collision');
            
            // Sparks
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const sparkPos = position.clone();
                    sparkPos.x += (Math.random() - 0.5) * 2;
                    sparkPos.y += Math.random() * 2;
                    createParticleEffect(sparkPos, 0xFFFF00, 'spark');
                }, i * 50);
            }
            
            // Screen effects
            screenShake(0.3, 500);
            flashScreen(0xFF0000, 200);
        }
        
        // Flash screen effect
        function flashScreen(color, duration) {
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = `#${color.toString(16)}`;
            flash.style.opacity = '0.3';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '100';
            
            document.getElementById('gameContainer').appendChild(flash);
            
            setTimeout(() => {
                flash.style.transition = `opacity ${duration}ms`;
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), duration);
            }, 10);
        }
        
        // REMOVED: Old updateScoreWithMultipliers function replaced by centralized score system
        
        // Touch control handlers
        function handleTouchStart(event) {
            if (!gameState.isPlaying) return;
            
            const touch = event.touches[0];
            gameState.touchStartX = touch.clientX;
            gameState.touchStartY = touch.clientY;
        }
        
        function handleTouchEnd(event) {
            if (!gameState.isPlaying) return;
            
            const touch = event.changedTouches[0];
            const deltaX = touch.clientX - gameState.touchStartX;
            const deltaY = touch.clientY - gameState.touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > gameState.touchThreshold) {
                    if (deltaX > 0 && gameState.playerLane < 2) {
                        // Swipe right
                        gameState.playerLane++;
                        audioManager.play('whoosh');
                        trackPlayerMove('right', gameState.playerLane);
                    } else if (deltaX < 0 && gameState.playerLane > 0) {
                        // Swipe left
                        gameState.playerLane--;
                        audioManager.play('whoosh');
                        trackPlayerMove('left', gameState.playerLane);
                    }
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > gameState.touchThreshold) {
                    if (deltaY < 0 && gameState.playerAction === 'running') {
                        // Swipe up - jump
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        audioManager.play('jump');
                        // Sprung-Partikel (nur bei erfolgreichem Obstacle-Avoidance)
                        // Removed automatic jump particles - only success particles when avoiding obstacles
                        trackPlayerMove('jumping');
                    } else if (deltaY > 0 && gameState.playerAction === 'running') {
                        // Swipe down - duck
                        gameState.playerAction = 'ducking';
                        audioManager.play('duck');
                        trackPlayerMove('ducking');
                    }
                }
            }
        }
        
        function handleTouchMove(event) {
            // Prevent scrolling while playing
            if (gameState.isPlaying) {
                event.preventDefault();
            }
        }

        function onWindowResize() {
            const canvas = document.getElementById('gameCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        // Event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        // Touch event listeners
        gameState.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (gameState.isTouchDevice) {
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            
            // Auto-release duck after swipe down
            document.addEventListener('touchend', (event) => {
                if (gameState.playerAction === 'ducking') {
                    setTimeout(() => {
                        if (gameState.playerAction === 'ducking') {
                            gameState.playerAction = 'running';
                        }
                    }, 500); // Auto-release after 500ms
                }
            });
        }

        // Debug function for testing
        window.testFunction = function() {
            console.log('Test function works!');
            console.log('THREE object:', typeof THREE);
            console.log('gameState:', gameState);
            console.log('scene:', scene);
            console.log('camera:', camera);
            console.log('renderer:', renderer);
        };

        // Initialize game
        console.log('Starting game initialization...');
        init().catch(error => {
            console.error('❌ Failed to initialize game:', error);
        });
        
        // ==================== GESTURE CONTROL SYSTEM ====================
        
        // Kalman Filter for smoothing
        class KalmanFilter {
            constructor(processNoise = 0.01, measurementNoise = 1) {
                this.processNoise = processNoise;
                this.measurementNoise = measurementNoise;
                this.value = 0;
                this.uncertainty = 1;
            }
            
            filter(measurement) {
                this.uncertainty += this.processNoise;
                const gain = this.uncertainty / (this.uncertainty + this.measurementNoise);
                this.value += gain * (measurement - this.value);
                this.uncertainty *= (1 - gain);
                return this.value;
            }
        }
        
        // Gesture Controller Class
        class GestureController {
            constructor(options = {}) {
                this.options = {
                    videoElement: options.videoElement || null,
                    canvasElement: options.canvasElement || null,
                    onGestureDetected: options.onGestureDetected || (() => {}),
                    onStatsUpdate: options.onStatsUpdate || (() => {}),
                    onError: options.onError || (() => {}),
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    smoothingFrames: 5,
                    sensitivity: 0.5,
                    debugMode: false
                };
                
                this.isRunning = false;
                this.faceLandmarker = null;
                this.lastVideoTime = -1;
                this.gestureHistory = [];
                this.lastGesture = 'NONE';
                
                this.calibrationData = {
                    neutralYaw: 0,
                    neutralPitch: 0,
                    isCalibrated: false
                };
                
                this.stats = {
                    fps: 0,
                    frameCount: 0,
                    lastFrameTime: performance.now(),
                    faceDetected: false,
                    yaw: 0,
                    pitch: 0
                };
                
                this.kalmanFilter = {
                    yaw: new KalmanFilter(0.01, 1),
                    pitch: new KalmanFilter(0.01, 1)
                };
                
                this.thresholds = {
                    yawLeft: -0.6,
                    yawRight: 0.6,
                    pitchUp: -0.6,
                    pitchDown: 0.6,
                    deadZone: 0.2
                };
                
                this.ctx = this.options.canvasElement ? 
                    this.options.canvasElement.getContext('2d') : null;
                
                this.frameSkipCounter = 0;
                this.frameSkipRate = 2;
            }
            
            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    this.options.videoElement.srcObject = stream;
                    
                    await new Promise((resolve) => {
                        this.options.videoElement.onloadedmetadata = resolve;
                    });
                    
                    try {
                        await this.initializeMediaPipe();
                    } catch (error) {
                        console.error('MediaPipe initialization failed:', error);
                        throw new Error('MediaPipe Vision library not loaded. Please refresh the page.');
                    }
                    
                    this.isRunning = true;
                    this.detectLoop();
                    
                    setTimeout(() => this.calibrate(), 2000);
                    
                } catch (error) {
                    this.options.onError(`Failed to start camera: ${error.message}`);
                    throw error;
                }
            }
            
            stop() {
                this.isRunning = false;
                
                if (this.options.videoElement && this.options.videoElement.srcObject) {
                    const tracks = this.options.videoElement.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    this.options.videoElement.srcObject = null;
                }
                
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.options.canvasElement.width, this.options.canvasElement.height);
                }
            }
            
            async initializeMediaPipe() {
                // BUGFIX: Check if MediaPipe is loaded and handle namespace properly
                if (!window.mediapipe || !window.mediapipe.tasks || !window.mediapipe.tasks.vision) {
                    throw new Error('MediaPipe Vision library not loaded yet');
                }
                
                try {
                    const vision = await window.mediapipe.tasks.vision.FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                    );
                    
                    this.faceLandmarker = await window.mediapipe.tasks.vision.FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker_lite/float16/latest/face_landmarker_lite.task",
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true,
                    runningMode: "VIDEO",
                    numFaces: 1,
                    minFaceDetectionConfidence: this.options.minDetectionConfidence,
                    minFacePresenceConfidence: this.options.minDetectionConfidence,
                    minTrackingConfidence: this.options.minTrackingConfidence
                });
                } catch (error) {
                    console.error('Failed to create FaceLandmarker:', error);
                    throw error;
                }
            }
            
            detectLoop() {
                if (!this.isRunning || !this.faceLandmarker) {
                    return;
                }
                
                this.frameSkipCounter++;
                if (this.frameSkipCounter < this.frameSkipRate) {
                    requestAnimationFrame(() => this.detectLoop());
                    return;
                }
                this.frameSkipCounter = 0;
                
                const video = this.options.videoElement;
                const startTimeMs = performance.now();
                
                if (video.readyState >= 2 && this.lastVideoTime !== video.currentTime) {
                    this.lastVideoTime = video.currentTime;
                    
                    const results = this.faceLandmarker.detectForVideo(video, startTimeMs);
                    
                    this.updateFPS();
                    
                    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                        this.processFaceLandmarks(results);
                        this.stats.faceDetected = true;
                    } else {
                        this.stats.faceDetected = false;
                        this.updateGesture('NONE');
                    }
                    
                    if (this.ctx) {
                        this.drawMinimalVisualization();
                    }
                    
                    this.options.onStatsUpdate(this.stats);
                }
                
                requestAnimationFrame(() => this.detectLoop());
            }
            
            processFaceLandmarks(results) {
                const landmarks = results.faceLandmarks[0];
                
                const nose = landmarks[1];
                const forehead = landmarks[9];
                const chin = landmarks[152];
                const leftEar = landmarks[234];
                const rightEar = landmarks[454];
                
                const earDistance = rightEar.x - leftEar.x;
                const faceCenterX = (leftEar.x + rightEar.x) / 2;
                const noseOffsetX = nose.x - faceCenterX;
                let yaw = (noseOffsetX / earDistance) * 2;
                
                const faceHeight = chin.y - forehead.y;
                const noseCenterY = (forehead.y + chin.y) / 2;
                const noseOffsetY = nose.y - noseCenterY;
                let pitch = (noseOffsetY / faceHeight) * 2;
                
                yaw = this.kalmanFilter.yaw.filter(yaw);
                pitch = this.kalmanFilter.pitch.filter(pitch);
                
                this.stats.yaw = yaw * 45;
                this.stats.pitch = pitch * 45;
                
                if (this.calibrationData.isCalibrated) {
                    yaw -= this.calibrationData.neutralYaw;
                    pitch -= this.calibrationData.neutralPitch;
                }
                
                yaw *= this.options.sensitivity * 2;
                pitch *= this.options.sensitivity * 2;
                
                const gesture = this.detectGesture(yaw, pitch);
                this.updateGesture(gesture);
            }
            
            detectGesture(yaw, pitch) {
                const inDeadZone = Math.abs(yaw) < this.thresholds.deadZone && 
                                  Math.abs(pitch) < this.thresholds.deadZone;
                
                if (pitch > this.thresholds.pitchDown) {
                    return 'DUCK';
                } else if (pitch < this.thresholds.pitchUp) {
                    return 'JUMP';
                } else if (yaw < this.thresholds.yawLeft) {
                    return 'MOVE_LEFT';
                } else if (yaw > this.thresholds.yawRight) {
                    return 'MOVE_RIGHT';
                } else if (inDeadZone || this.lastGesture === 'DUCK') {
                    return 'NONE';
                }
                
                return this.lastGesture;
            }
            
            updateGesture(gesture) {
                this.gestureHistory.push(gesture);
                if (this.gestureHistory.length > this.options.smoothingFrames) {
                    this.gestureHistory.shift();
                }
                
                const gestureCount = {};
                this.gestureHistory.forEach(g => {
                    gestureCount[g] = (gestureCount[g] || 0) + 1;
                });
                
                let maxCount = 0;
                let smoothedGesture = 'NONE';
                for (const [g, count] of Object.entries(gestureCount)) {
                    if (count > maxCount) {
                        maxCount = count;
                        smoothedGesture = g;
                    }
                }
                
                if (smoothedGesture !== this.lastGesture) {
                    this.lastGesture = smoothedGesture;
                    this.options.onGestureDetected(smoothedGesture);
                }
            }
            
            calibrate() {
                this.calibrationData.neutralYaw = this.stats.yaw / 45;
                this.calibrationData.neutralPitch = this.stats.pitch / 45;
                this.calibrationData.isCalibrated = true;
                
                if (this.ctx) {
                    const canvas = this.options.canvasElement;
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('KALIBRIERT!', canvas.width / 2, canvas.height / 2);
                    
                    setTimeout(() => {
                        if (this.ctx) {
                            this.ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }, 1000);
                }
            }
            
            drawMinimalVisualization() {
                const canvas = this.options.canvasElement;
                const video = this.options.videoElement;
                
                canvas.width = 160;
                canvas.height = 120;
                
                this.ctx.save();
                this.ctx.scale(-1, 1);
                this.ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
                this.ctx.restore();
                
                if (this.stats.faceDetected) {
                    this.ctx.strokeStyle = '#00ff88';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                } else {
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                }
                
                if (this.lastGesture !== 'NONE') {
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.lastGesture.replace('_', ' '), canvas.width / 2, canvas.height - 10);
                }
            }
            
            updateFPS() {
                this.stats.frameCount++;
                const now = performance.now();
                const elapsed = now - this.stats.lastFrameTime;
                
                if (elapsed >= 1000) {
                    this.stats.fps = (this.stats.frameCount * 1000) / elapsed;
                    this.stats.frameCount = 0;
                    this.stats.lastFrameTime = now;
                }
            }
            
            setSensitivity(value) {
                this.options.sensitivity = Math.max(0.1, Math.min(1, value));
            }
        }
        
        // Global gesture controller instance
        let gestureController = null;
        let gestureEnabled = false;
        
        // Initialize gesture controller
        function initGestureController() {
            // Wait for MediaPipe to load
            if (!window.mediapipe || !window.mediapipe.tasks || !window.mediapipe.tasks.vision) {
                console.warn('MediaPipe not loaded yet, waiting...');
                setTimeout(initGestureController, 500);
                return;
            }
            
            gestureController = new GestureController({
                videoElement: document.getElementById('gestureVideo'),
                canvasElement: document.getElementById('gestureCanvas'),
                onGestureDetected: handleGestureInput,
                onStatsUpdate: updateGestureStats,
                onError: showGestureError
            });
        }
        
        // Handle gesture input
        function handleGestureInput(gesture) {
            if (!gameState.isPlaying || !gestureEnabled) return;
            
            const feedbackEl = document.getElementById('gestureFeedback');
            
            switch (gesture) {
                case 'MOVE_LEFT':
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        trackPlayerMove('left', gameState.playerLane);
                        
                        // Show feedback
                        feedbackEl.textContent = '⬅️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'MOVE_RIGHT':
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        trackPlayerMove('right', gameState.playerLane);
                        
                        // Show feedback
                        feedbackEl.textContent = '➡️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'JUMP':
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                        audioManager.resume();
                        
                        createParticleEffect(
                            new THREE.Vector3(player.position.x, 0.1, player.position.z),
                            0xFFFF00,
                            'jump'
                        );
                        
                        trackPlayerMove('jumping');
                        
                        // Show feedback
                        feedbackEl.textContent = '⬆️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'DUCK':
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                        trackPlayerMove('ducking');
                        
                        // Show feedback
                        feedbackEl.textContent = '⬇️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'NONE':
                    if (gameState.playerAction === 'ducking') {
                        gameState.playerAction = 'running';
                    }
                    break;
            }
        }
        
        // Update gesture stats display
        function updateGestureStats(stats) {
            // Update status text
            const statusEl = document.getElementById('gestureStatus');
            if (stats.faceDetected) {
                statusEl.textContent = `Gesten: Aktiv (${stats.fps.toFixed(0)} FPS)`;
                statusEl.style.color = '#00ff88';
            } else {
                statusEl.textContent = 'Gesten: Kein Gesicht erkannt';
                statusEl.style.color = '#ff4444';
            }
        }
        
        // Show gesture error
        function showGestureError(message) {
            const statusEl = document.getElementById('gestureStatus');
            statusEl.textContent = `Fehler: ${message}`;
            statusEl.style.color = '#ff4444';
            
            // Disable gesture controls
            gestureEnabled = false;
            document.getElementById('gestureToggle').textContent = '🎥 Gesten aktivieren';
            document.getElementById('gestureToggle').classList.remove('active');
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('gestureCanvas').classList.remove('active');
        }
        
        // Toggle gesture control
        async function toggleGestureControl() {
            const toggleBtn = document.getElementById('gestureToggle');
            const calibrateBtn = document.getElementById('calibrateBtn');
            const canvas = document.getElementById('gestureCanvas');
            
            if (!gestureController) {
                initGestureController();
            }
            
            if (gestureEnabled) {
                // Disable gesture control
                gestureEnabled = false;
                gestureController.stop();
                toggleBtn.textContent = '🎥 Gesten aktivieren';
                toggleBtn.classList.remove('active');
                calibrateBtn.disabled = true;
                canvas.classList.remove('active');
                document.getElementById('gestureStatus').textContent = 'Gesten: Inaktiv';
            } else {
                // Enable gesture control
                try {
                    await gestureController.start();
                    gestureEnabled = true;
                    toggleBtn.textContent = '🎥 Gesten deaktivieren';
                    toggleBtn.classList.add('active');
                    calibrateBtn.disabled = false;
                    canvas.classList.add('active');
                    document.getElementById('gestureStatus').textContent = 'Gesten: Wird initialisiert...';
                } catch (error) {
                    showGestureError(error.message);
                }
            }
        }
        
        // Calibrate gestures
        function calibrateGestures() {
            if (gestureController && gestureEnabled) {
                gestureController.calibrate();
                const statusEl = document.getElementById('gestureStatus');
                statusEl.textContent = 'Kalibrierung erfolgreich!';
                statusEl.style.color = '#4CAF50';
                setTimeout(() => {
                    updateGestureStats(gestureController.stats);
                }, 2000);
            }
        }
        
        // ==================== LINE DRAWING IMPORT SYSTEM ====================
        
        // ==================== ULTRA-ROBUST LINE DRAWING SYSTEM ====================
        
        // Global state management for import operations
        const LineDrawingState = {
            isProcessing: false,
            activeCanvas: null,
            maxFileSize: 50 * 1024 * 1024, // 50MB limit
            maxCanvasSize: 8192, // Most browsers support up to 8192x8192
            timeout: 30000, // 30 second timeout
            
            reset() {
                this.isProcessing = false;
                this.cleanup();
            },
            
            cleanup() {
                if (this.activeCanvas) {
                    const ctx = this.activeCanvas.getContext('2d');
                    if (ctx) {
                        ctx.clearRect(0, 0, this.activeCanvas.width, this.activeCanvas.height);
                    }
                    this.activeCanvas.width = 0;
                    this.activeCanvas.height = 0;
                    this.activeCanvas = null;
                }
                // Force garbage collection if available
                if (window.gc) window.gc();
            }
        };
        
        /**
         * ULTRA-ROBUST: Handle line drawing file import with comprehensive error handling
         * @param {File} file - The image file to process
         * @param {Function} callback - Callback function to handle processed image
         */
        function handleLineDrawingFile(file, callback) {
            console.log('🎨 [LineDrawing] ULTRA-ROBUST processing started for:', file.name);
            
            // PROTECTION 1: Race condition prevention
            if (LineDrawingState.isProcessing) {
                console.warn('⚠️ [LineDrawing] Already processing a file. Please wait.');
                if (callback) callback(null, 'Ein anderer Import läuft bereits. Bitte warten.');
                return;
            }
            LineDrawingState.isProcessing = true;
            
            // PROTECTION 2: Comprehensive file validation
            if (!file) {
                console.error('❌ [LineDrawing] No file provided');
                LineDrawingState.reset();
                if (callback) callback(null, 'Keine Datei ausgewählt');
                return;
            }
            
            if (!file.type || !file.type.startsWith('image/')) {
                console.error('❌ [LineDrawing] Invalid file type:', file.type);
                LineDrawingState.reset();
                if (callback) callback(null, `Ungültiger Dateityp: ${file.type}. Nur Bilder sind erlaubt.`);
                return;
            }
            
            // PROTECTION 3: File size validation (prevent memory bombs)
            if (file.size > LineDrawingState.maxFileSize) {
                console.error('❌ [LineDrawing] File too large:', file.size, 'bytes');
                LineDrawingState.reset();
                if (callback) callback(null, `Datei zu groß: ${Math.round(file.size/1024/1024)}MB. Maximum: ${LineDrawingState.maxFileSize/1024/1024}MB`);
                return;
            }
            
            // PROTECTION 4: Timeout mechanism
            const timeoutId = setTimeout(() => {
                console.error('❌ [LineDrawing] Processing timeout');
                LineDrawingState.reset();
                if (callback) callback(null, 'Verarbeitung dauerte zu lange (>30s). Bitte kleinere Datei verwenden.');
            }, LineDrawingState.timeout);
            
            // PROTECTION 5: Secure FileReader with error handling
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const img = new Image();
                    
                    // PROTECTION 6: Image loading timeout and error handling
                    const imgTimeoutId = setTimeout(() => {
                        console.error('❌ [LineDrawing] Image loading timeout');
                        clearTimeout(timeoutId);
                        LineDrawingState.reset();
                        if (callback) callback(null, 'Bild konnte nicht geladen werden (Timeout)');
                    }, 15000); // 15s timeout for image loading
                    
                    img.onload = function() {
                        try {
                            clearTimeout(imgTimeoutId);
                            console.log('🎨 [LineDrawing] Image loaded:', img.width, 'x', img.height);
                            
                            // PROTECTION 7: Canvas size validation (prevent browser limits)
                            if (img.width > LineDrawingState.maxCanvasSize || img.height > LineDrawingState.maxCanvasSize) {
                                console.error('❌ [LineDrawing] Image too large for canvas:', img.width, 'x', img.height);
                                clearTimeout(timeoutId);
                                LineDrawingState.reset();
                                if (callback) callback(null, `Bild zu groß: ${img.width}x${img.height}. Maximum: ${LineDrawingState.maxCanvasSize}x${LineDrawingState.maxCanvasSize}`);
                                return;
                            }
                            
                            // PROTECTION 8: Memory-aware canvas creation
                            const canvas = document.createElement('canvas');
                            LineDrawingState.activeCanvas = canvas;
                            
                            const ctx = canvas.getContext('2d', {
                                alpha: true,
                                desynchronized: true, // Performance optimization
                                colorSpace: 'srgb' // PROTECTION: Force sRGB color space
                            });
                            
                            if (!ctx) {
                                console.error('❌ [LineDrawing] Failed to get canvas context');
                                clearTimeout(timeoutId);
                                LineDrawingState.reset();
                                if (callback) callback(null, 'Canvas-Kontext konnte nicht erstellt werden');
                                return;
                            }
                            
                            // Set canvas size with error handling
                            try {
                                canvas.width = img.width;
                                canvas.height = img.height;
                            } catch (error) {
                                console.error('❌ [LineDrawing] Canvas size setting failed:', error);
                                clearTimeout(timeoutId);
                                LineDrawingState.reset();
                                if (callback) callback(null, 'Canvas-Größe konnte nicht gesetzt werden');
                                return;
                            }
                            
                            // PROTECTION 9: Secure image drawing with cross-origin handling
                            try {
                                ctx.drawImage(img, 0, 0);
                            } catch (error) {
                                console.error('❌ [LineDrawing] Image drawing failed (CORS?):', error);
                                clearTimeout(timeoutId);
                                LineDrawingState.reset();
                                if (callback) callback(null, 'Bild konnte nicht gezeichnet werden (möglicherweise CORS-Problem)');
                                return;
                            }
                            
                            // PROTECTION 10: Safe image data extraction
                            let imageData;
                            try {
                                imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            } catch (error) {
                                console.error('❌ [LineDrawing] ImageData extraction failed:', error);
                                clearTimeout(timeoutId);
                                LineDrawingState.reset();
                                if (callback) callback(null, 'Bilddaten konnten nicht extrahiert werden');
                                return;
                            }
                            
                            // PROTECTION 11: Performance-optimized processing with progress
                            console.log('🎨 [LineDrawing] Starting pixel processing for', imageData.width * imageData.height, 'pixels');
                            
                            // Use requestAnimationFrame for non-blocking processing
                            requestAnimationFrame(() => {
                                try {
                                    const processedData = processLineDrawingUltraRobust(imageData);
                                    
                                    if (!processedData) {
                                        clearTimeout(timeoutId);
                                        LineDrawingState.reset();
                                        if (callback) callback(null, 'Bildverarbeitung fehlgeschlagen');
                                        return;
                                    }
                                    
                                    // Create new image from processed data
                                    ctx.putImageData(processedData, 0, 0);
                                    
                                    // PROTECTION 12: Safe data URL conversion
                                    let dataURL;
                                    try {
                                        dataURL = canvas.toDataURL('image/png', 0.9); // Slight compression
                                    } catch (error) {
                                        console.error('❌ [LineDrawing] DataURL conversion failed:', error);
                                        clearTimeout(timeoutId);
                                        LineDrawingState.reset();
                                        if (callback) callback(null, 'Bild konnte nicht konvertiert werden');
                                        return;
                                    }
                                    
                                    clearTimeout(timeoutId);
                                    console.log('✅ [LineDrawing] ULTRA-ROBUST processing complete!');
                                    
                                    // Clean up before callback
                                    LineDrawingState.reset();
                                    
                                    if (callback) callback(dataURL, null);
                                    
                                } catch (error) {
                                    console.error('❌ [LineDrawing] Final processing error:', error);
                                    clearTimeout(timeoutId);
                                    LineDrawingState.reset();
                                    if (callback) callback(null, `Verarbeitungsfehler: ${error.message}`);
                                }
                            });
                            
                        } catch (error) {
                            console.error('❌ [LineDrawing] Image processing error:', error);
                            clearTimeout(imgTimeoutId);
                            clearTimeout(timeoutId);
                            LineDrawingState.reset();
                            if (callback) callback(null, `Bildverarbeitung fehlgeschlagen: ${error.message}`);
                        }
                    };
                    
                    img.onerror = function() {
                        console.error('❌ [LineDrawing] Image load error');
                        clearTimeout(imgTimeoutId);
                        clearTimeout(timeoutId);
                        LineDrawingState.reset();
                        if (callback) callback(null, 'Bild konnte nicht geladen werden (ungültiges Format?)');
                    };
                    
                    // PROTECTION 13: CSP-safe image loading
                    try {
                        img.src = e.target.result;
                    } catch (error) {
                        console.error('❌ [LineDrawing] Image src setting failed:', error);
                        clearTimeout(imgTimeoutId);
                        clearTimeout(timeoutId);
                        LineDrawingState.reset();
                        if (callback) callback(null, 'Bild-URL konnte nicht gesetzt werden');
                    }
                    
                } catch (error) {
                    console.error('❌ [LineDrawing] FileReader onload error:', error);
                    clearTimeout(timeoutId);
                    LineDrawingState.reset();
                    if (callback) callback(null, `Datei-Verarbeitung fehlgeschlagen: ${error.message}`);
                }
            };
            
            reader.onerror = function(error) {
                console.error('❌ [LineDrawing] FileReader error:', error);
                clearTimeout(timeoutId);
                LineDrawingState.reset();
                if (callback) callback(null, 'Datei konnte nicht gelesen werden');
            };
            
            reader.onabort = function() {
                console.error('❌ [LineDrawing] FileReader aborted');
                clearTimeout(timeoutId);
                LineDrawingState.reset();
                if (callback) callback(null, 'Datei-Lesung wurde abgebrochen');
            };
            
            // PROTECTION 14: Secure file reading
            try {
                reader.readAsDataURL(file);
            } catch (error) {
                console.error('❌ [LineDrawing] FileReader start failed:', error);
                clearTimeout(timeoutId);
                LineDrawingState.reset();
                if (callback) callback(null, `Datei konnte nicht gelesen werden: ${error.message}`);
            }
        }
        
        /**
         * ULTRA-ROBUST: Process image data for line drawing with comprehensive error handling
         * @param {ImageData} imageData - Canvas image data
         * @returns {ImageData|null} Processed image data or null on error
         */
        function processLineDrawingUltraRobust(imageData) {
            console.log('🎨 [LineDrawing] ULTRA-ROBUST image processing started...');
            
            // PROTECTION 15: Input validation
            if (!imageData || !imageData.data || !imageData.width || !imageData.height) {
                console.error('❌ [LineDrawing] Invalid imageData provided');
                return null;
            }
            
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const totalPixels = width * height;
            
            // PROTECTION 16: Sanity checks
            if (data.length !== totalPixels * 4) {
                console.error('❌ [LineDrawing] ImageData size mismatch:', data.length, 'vs expected', totalPixels * 4);
                return null;
            }
            
            if (totalPixels > 50000000) { // ~7000x7000 pixels
                console.error('❌ [LineDrawing] Image too large for processing:', totalPixels, 'pixels');
                return null;
            }
            
            console.log('🎨 [LineDrawing] Processing', totalPixels, 'pixels...');
            
            // PROTECTION 17: Safe ImageData creation
            let processedData;
            try {
                processedData = new ImageData(width, height);
            } catch (error) {
                console.error('❌ [LineDrawing] Failed to create ImageData:', error);
                return null;
            }
            
            const processed = processedData.data;
            
            // PROTECTION 18: Chunked processing for large images (prevent UI blocking)
            const chunkSize = 10000; // Process 10k pixels at a time
            let processedCount = 0;
            
            try {
                for (let i = 0; i < data.length; i += 4) {
                    // PROTECTION 19: Bounds checking
                    if (i + 3 >= data.length || i + 3 >= processed.length) {
                        console.warn('⚠️ [LineDrawing] Bounds exceeded at pixel', i/4);
                        break;
                    }
                    
                    const r = data[i] || 0;
                    const g = data[i + 1] || 0;
                    const b = data[i + 2] || 0;
                    const a = data[i + 3] || 255;
                    
                    // PROTECTION 20: NaN checking
                    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a)) {
                        console.warn('⚠️ [LineDrawing] NaN values detected at pixel', i/4);
                        processed[i] = 255;     // Default to white
                        processed[i + 1] = 255;
                        processed[i + 2] = 255;
                        processed[i + 3] = 0;   // Transparent
                        continue;
                    }
                    
                    // PROTECTION 21: Enhanced grayscale conversion with alpha consideration
                    let gray;
                    if (a === 0) {
                        // Transparent pixel - treat as background
                        gray = 255;
                    } else {
                        // Standard grayscale conversion (ITU-R BT.709)
                        gray = (r * 0.2126 + g * 0.7152 + b * 0.0722);
                    }
                    
                    // PROTECTION 22: Adaptive threshold based on alpha channel
                    let threshold = 128;
                    if (a < 255) {
                        // Semi-transparent pixels get higher threshold (more likely to be background)
                        threshold = 128 + (255 - a) * 0.2;
                    }
                    
                    const isLine = gray < threshold;
                    
                    // PROTECTION 23: Enhanced color assignment with edge detection
                    if (isLine) {
                        // Line pixels - pure black with full opacity
                        processed[i] = 0;       // R
                        processed[i + 1] = 0;   // G
                        processed[i + 2] = 0;   // B
                        processed[i + 3] = Math.max(a, 200); // Ensure visibility
                    } else {
                        // Background pixels - transparent
                        processed[i] = 255;     // R (white if visible)
                        processed[i + 1] = 255; // G
                        processed[i + 2] = 255; // B
                        processed[i + 3] = 0;   // A (transparent)
                    }
                    
                    processedCount++;
                    
                    // PROTECTION 24: Progress reporting and yielding control
                    if (processedCount % chunkSize === 0) {
                        const progress = (processedCount / totalPixels * 100).toFixed(1);
                        console.log('🎨 [LineDrawing] Progress:', progress + '%');
                        
                        // Yield control to prevent UI blocking (removed await as function is not async)
                        if (processedCount % (chunkSize * 10) === 0) {
                            // Note: Cannot use await in non-async function, but chunked processing still helps
                        }
                    }
                }
                
                console.log('✅ [LineDrawing] ULTRA-ROBUST processing complete!', processedCount, 'pixels processed');
                
                // PROTECTION 25: Validation of processed data
                if (processedCount !== totalPixels) {
                    console.warn('⚠️ [LineDrawing] Pixel count mismatch:', processedCount, 'vs', totalPixels);
                }
                
                return processedData;
                
            } catch (error) {
                console.error('❌ [LineDrawing] Processing error:', error);
                return null;
            }
        }
        
        /**
         * Legacy function for backwards compatibility
         */
        function processLineDrawing(imageData) {
            return processLineDrawingUltraRobust(imageData);
        }
        
        /**
         * ULTRA-ROBUST: Create file input for line drawing import with mobile support
         * @returns {HTMLInputElement} File input element
         */
        function createLineDrawingInputUltraRobust() {
            try {
                const input = document.createElement('input');
                input.type = 'file';
                
                // PROTECTION 26: Enhanced file type restrictions
                input.accept = 'image/png,image/jpeg,image/jpg,image/gif,image/webp,image/svg+xml,image/bmp';
                input.style.display = 'none';
                
                // PROTECTION 27: Mobile compatibility attributes
                if (/Mobi|Android/i.test(navigator.userAgent)) {
                    input.capture = 'environment'; // Use back camera on mobile
                    input.setAttribute('capture', 'environment');
                }
                
                // PROTECTION 28: Enhanced change handler with validation
                input.onchange = function(e) {
                    try {
                        console.log('🎨 [LineDrawing] File input changed');
                        
                        if (!e.target || !e.target.files) {
                            console.error('❌ [LineDrawing] No files in event');
                            return;
                        }
                        
                        const file = e.target.files[0];
                        if (!file) {
                            console.warn('⚠️ [LineDrawing] No file selected');
                            return;
                        }
                        
                        console.log('🎨 [LineDrawing] Processing file:', file.name, file.size, 'bytes');
                        
                        // Show loading indicator
                        showLoadingIndicator('Verarbeite Strichzeichnung...');
                        
                        handleLineDrawingFile(file, function(dataURL, error) {
                            hideLoadingIndicator();
                            
                            if (error) {
                                console.error('❌ [LineDrawing] Import failed:', error);
                                showErrorMessage('Fehler beim Importieren der Strichzeichnung', error);
                            } else {
                                console.log('✅ [LineDrawing] Import successful');
                                showLineDrawingPreviewUltraRobust(dataURL);
                            }
                            
                            // Reset input for next use
                            e.target.value = '';
                        });
                        
                    } catch (error) {
                        hideLoadingIndicator();
                        console.error('❌ [LineDrawing] Input change handler error:', error);
                        showErrorMessage('Unerwarteter Fehler', error.message);
                    }
                };
                
                // PROTECTION 29: Error handling for input events
                input.onerror = function(e) {
                    console.error('❌ [LineDrawing] Input error:', e);
                    hideLoadingIndicator();
                    showErrorMessage('Dateieingabe-Fehler', 'Fehler beim Zugriff auf die Datei');
                };
                
                return input;
                
            } catch (error) {
                console.error('❌ [LineDrawing] Failed to create input:', error);
                return null;
            }
        }
        
        /**
         * Legacy function for backwards compatibility
         */
        function createLineDrawingInput() {
            return createLineDrawingInputUltraRobust();
        }
        
        /**
         * ULTRA-ROBUST: Show line drawing preview with mobile optimization
         * @param {string} dataURL - Processed image data URL
         */
        function showLineDrawingPreviewUltraRobust(dataURL) {
            try {
                console.log('🎨 [LineDrawing] Showing preview...');
                
                // PROTECTION 30: Input validation
                if (!dataURL || typeof dataURL !== 'string') {
                    console.error('❌ [LineDrawing] Invalid dataURL for preview');
                    showErrorMessage('Vorschau-Fehler', 'Ungültige Bilddaten');
                    return;
                }
                
                // PROTECTION 31: Remove existing previews
                const existingPreviews = document.querySelectorAll('.line-drawing-preview');
                existingPreviews.forEach(preview => {
                    try {
                        document.body.removeChild(preview);
                    } catch (e) {
                        console.warn('⚠️ [LineDrawing] Could not remove existing preview:', e);
                    }
                });
                
                // PROTECTION 32: Mobile-responsive preview creation
                const preview = document.createElement('div');
                preview.className = 'line-drawing-preview';
                
                // PROTECTION 33: Mobile-optimized styling
                const isMobile = /Mobi|Android/i.test(navigator.userAgent);
                const styles = {
                    position: 'fixed',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    background: 'white',
                    border: '2px solid #333',
                    borderRadius: '8px',
                    padding: isMobile ? '15px' : '20px',
                    zIndex: '10000',
                    maxWidth: isMobile ? '95%' : '80%',
                    maxHeight: isMobile ? '95%' : '80%',
                    overflow: 'auto',
                    boxShadow: '0 4px 20px rgba(0,0,0,0.3)',
                    fontFamily: 'Arial, sans-serif',
                    textAlign: 'center'
                };
                
                Object.assign(preview.style, styles);
                
                // PROTECTION 34: Safe HTML generation
                const title = document.createElement('h3');
                title.textContent = 'Strichzeichnung importiert!';
                title.style.margin = '0 0 15px 0';
                title.style.color = '#333';
                preview.appendChild(title);
                
                // PROTECTION 35: Safe image creation with error handling
                const img = document.createElement('img');
                img.style.maxWidth = '100%';
                img.style.maxHeight = isMobile ? '300px' : '400px';
                img.style.border = '1px solid #ccc';
                img.style.borderRadius = '4px';
                img.style.display = 'block';
                img.style.margin = '0 auto 15px auto';
                
                img.onload = function() {
                    console.log('✅ [LineDrawing] Preview image loaded successfully');
                };
                
                img.onerror = function() {
                    console.error('❌ [LineDrawing] Preview image failed to load');
                    img.style.display = 'none';
                    const errorText = document.createElement('p');
                    errorText.textContent = 'Fehler beim Laden des Vorschaubildes';
                    errorText.style.color = 'red';
                    preview.appendChild(errorText);
                };
                
                try {
                    img.src = dataURL;
                } catch (error) {
                    console.error('❌ [LineDrawing] Failed to set image src:', error);
                    showErrorMessage('Vorschau-Fehler', 'Konnte Bild nicht anzeigen');
                    return;
                }
                
                preview.appendChild(img);
                
                // PROTECTION 36: Button container with multiple options
                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.justifyContent = 'center';
                buttonContainer.style.gap = '10px';
                buttonContainer.style.flexWrap = 'wrap';
                
                // Close button
                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Schließen';
                closeBtn.style.padding = '8px 16px';
                closeBtn.style.background = '#666';
                closeBtn.style.color = 'white';
                closeBtn.style.border = 'none';
                closeBtn.style.borderRadius = '4px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.fontSize = isMobile ? '16px' : '14px';
                
                closeBtn.onclick = function() {
                    try {
                        document.body.removeChild(preview);
                    } catch (error) {
                        console.error('❌ [LineDrawing] Failed to close preview:', error);
                    }
                };
                
                // Download button
                const downloadBtn = document.createElement('button');
                downloadBtn.textContent = 'Download';
                downloadBtn.style.padding = '8px 16px';
                downloadBtn.style.background = '#007bff';
                downloadBtn.style.color = 'white';
                downloadBtn.style.border = 'none';
                downloadBtn.style.borderRadius = '4px';
                downloadBtn.style.cursor = 'pointer';
                downloadBtn.style.fontSize = isMobile ? '16px' : '14px';
                
                downloadBtn.onclick = function() {
                    try {
                        const link = document.createElement('a');
                        link.download = 'strichzeichnung-processed.png';
                        link.href = dataURL;
                        link.click();
                    } catch (error) {
                        console.error('❌ [LineDrawing] Download failed:', error);
                        showErrorMessage('Download-Fehler', 'Konnte Datei nicht herunterladen');
                    }
                };
                
                buttonContainer.appendChild(closeBtn);
                buttonContainer.appendChild(downloadBtn);
                preview.appendChild(buttonContainer);
                
                // PROTECTION 37: Safe DOM insertion
                try {
                    document.body.appendChild(preview);
                    
                    // PROTECTION 38: Escape key handling
                    const escapeHandler = function(e) {
                        if (e.key === 'Escape') {
                            try {
                                document.body.removeChild(preview);
                                document.removeEventListener('keydown', escapeHandler);
                            } catch (error) {
                                console.warn('⚠️ [LineDrawing] Escape handler cleanup failed:', error);
                            }
                        }
                    };
                    document.addEventListener('keydown', escapeHandler);
                    
                } catch (error) {
                    console.error('❌ [LineDrawing] Failed to show preview:', error);
                    showErrorMessage('Vorschau-Fehler', 'Konnte Vorschau nicht anzeigen');
                }
                
            } catch (error) {
                console.error('❌ [LineDrawing] Preview creation failed:', error);
                showErrorMessage('Vorschau-Fehler', error.message);
            }
        }
        
        /**
         * Legacy function for backwards compatibility
         */
        function showLineDrawingPreview(dataURL) {
            return showLineDrawingPreviewUltraRobust(dataURL);
        }
        
        // PROTECTION 39: Helper functions for UI feedback
        function showLoadingIndicator(message = 'Verarbeitung läuft...') {
            try {
                hideLoadingIndicator(); // Remove any existing indicator
                
                const indicator = document.createElement('div');
                indicator.id = 'lineDrawingLoadingIndicator';
                indicator.style.position = 'fixed';
                indicator.style.top = '50%';
                indicator.style.left = '50%';
                indicator.style.transform = 'translate(-50%, -50%)';
                indicator.style.background = 'rgba(0,0,0,0.8)';
                indicator.style.color = 'white';
                indicator.style.padding = '20px';
                indicator.style.borderRadius = '8px';
                indicator.style.zIndex = '10001';
                indicator.style.textAlign = 'center';
                indicator.style.fontFamily = 'Arial, sans-serif';
                indicator.innerHTML = `
                    <div style="font-size: 16px; margin-bottom: 10px;">${message}</div>
                    <div style="border: 3px solid #f3f3f3; border-top: 3px solid #3498db; border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                    <style>
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    </style>
                `;
                
                document.body.appendChild(indicator);
            } catch (error) {
                console.error('❌ [LineDrawing] Failed to show loading indicator:', error);
            }
        }
        
        function hideLoadingIndicator() {
            try {
                const indicator = document.getElementById('lineDrawingLoadingIndicator');
                if (indicator) {
                    document.body.removeChild(indicator);
                }
            } catch (error) {
                console.warn('⚠️ [LineDrawing] Failed to hide loading indicator:', error);
            }
        }
        
        function showErrorMessage(title, message) {
            try {
                const errorDialog = document.createElement('div');
                errorDialog.style.position = 'fixed';
                errorDialog.style.top = '50%';
                errorDialog.style.left = '50%';
                errorDialog.style.transform = 'translate(-50%, -50%)';
                errorDialog.style.background = 'white';
                errorDialog.style.border = '2px solid #ff4444';
                errorDialog.style.borderRadius = '8px';
                errorDialog.style.padding = '20px';
                errorDialog.style.zIndex = '10002';
                errorDialog.style.maxWidth = '80%';
                errorDialog.style.textAlign = 'center';
                errorDialog.style.fontFamily = 'Arial, sans-serif';
                errorDialog.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
                
                errorDialog.innerHTML = `
                    <h3 style="color: #ff4444; margin: 0 0 10px 0;">${title}</h3>
                    <p style="margin: 0 0 15px 0; color: #333;">${message}</p>
                    <button onclick="document.body.removeChild(this.parentElement)" style="
                        padding: 8px 16px;
                        background: #ff4444;
                        color: white;
                        border: none;
                        border-radius: 4px;
                        cursor: pointer;
                        font-size: 14px;
                    ">OK</button>
                `;
                
                document.body.appendChild(errorDialog);
                
                // Auto-remove after 10 seconds
                setTimeout(() => {
                    try {
                        if (document.body.contains(errorDialog)) {
                            document.body.removeChild(errorDialog);
                        }
                    } catch (e) {
                        console.warn('⚠️ [LineDrawing] Auto-removal failed:', e);
                    }
                }, 10000);
                
            } catch (error) {
                console.error('❌ [LineDrawing] Failed to show error message:', error);
                // Fallback to alert
                alert(`${title}: ${message}`);
            }
        }
        
        // PROTECTION 40: Initialize line drawing system with error handling
        let lineDrawingInput;
        try {
            lineDrawingInput = createLineDrawingInput();
            if (lineDrawingInput) {
                document.body.appendChild(lineDrawingInput);
                console.log('✅ [LineDrawing] System initialized successfully');
            } else {
                console.error('❌ [LineDrawing] Failed to create input element');
            }
        } catch (error) {
            console.error('❌ [LineDrawing] System initialization failed:', error);
        }
        
        /**
         * ULTRA-ROBUST: Function to trigger line drawing import with comprehensive validation
         */
        function importLineDrawingUltraRobust() {
            try {
                console.log('🎨 [LineDrawing] Import triggered');
                
                // PROTECTION 41: Check if system is ready
                if (!lineDrawingInput) {
                    console.error('❌ [LineDrawing] Input not initialized');
                    showErrorMessage('System-Fehler', 'Strichzeichnungs-System nicht initialisiert');
                    return;
                }
                
                // PROTECTION 42: Check if already processing
                if (LineDrawingState.isProcessing) {
                    console.warn('⚠️ [LineDrawing] Already processing, ignoring trigger');
                    showErrorMessage('Import läuft bereits', 'Bitte warten Sie, bis der aktuelle Import abgeschlossen ist');
                    return;
                }
                
                // PROTECTION 43: Check browser compatibility
                if (!window.FileReader) {
                    console.error('❌ [LineDrawing] FileReader not supported');
                    showErrorMessage('Browser nicht unterstützt', 'Ihr Browser unterstützt keine Datei-Uploads');
                    return;
                }
                
                if (!document.createElement('canvas').getContext) {
                    console.error('❌ [LineDrawing] Canvas not supported');
                    showErrorMessage('Browser nicht unterstützt', 'Ihr Browser unterstützt kein Canvas');
                    return;
                }
                
                // PROTECTION 44: Mobile optimization check
                const isMobile = /Mobi|Android/i.test(navigator.userAgent);
                if (isMobile) {
                    console.log('📱 [LineDrawing] Mobile device detected, optimizing...');
                }
                
                // PROTECTION 45: Trigger file input with error handling
                try {
                    lineDrawingInput.click();
                } catch (error) {
                    console.error('❌ [LineDrawing] Failed to trigger file input:', error);
                    showErrorMessage('Import-Fehler', 'Konnte Dateiauswahl nicht öffnen');
                }
                
            } catch (error) {
                console.error('❌ [LineDrawing] Import trigger failed:', error);
                showErrorMessage('Unerwarteter Fehler', error.message);
            }
        }
        
        /**
         * Legacy function for backwards compatibility
         */
        function importLineDrawing() {
            return importLineDrawingUltraRobust();
        }
        
        // ==================== END LINE DRAWING IMPORT SYSTEM ====================

        // Make functions globally available
        window.toggleGestureControl = toggleGestureControl;
        window.calibrateGestures = calibrateGestures;
        window.submitHighscore = submitHighscoreInternal;
        window.skipHighscore = skipHighscoreInternal;
        window.handleLineDrawingFile = handleLineDrawingFile;
        window.importLineDrawing = importLineDrawing;
        
        // ==================== END GESTURE CONTROL SYSTEM ====================
    </script>
</body>
</html>