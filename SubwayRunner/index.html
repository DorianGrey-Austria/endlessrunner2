<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subway Runner 3D - Challenge</title>
    <!-- BUGFIX: CSP headers to allow MediaPipe and other external resources -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdn.jsdelivr.net https://storage.googleapis.com; connect-src 'self' https://umvrurelsxpxmyzcvrcd.supabase.co https://storage.googleapis.com; worker-src 'self' blob:; img-src 'self' data: blob:; media-src 'self' blob:;">
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <!-- MediaPipe CDN for Gesture Control -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(to bottom, #87CEEB 0%, #98FB98 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #gameCanvas {
            width: 100%;
            height: 100%;
            max-width: 133.33vh; /* 4:3 aspect ratio */
            max-height: 75vw;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        #versionInfo {
            position: fixed;
            bottom: 10px;
            left: 10px;
            color: #FFD700;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 999;
            background: rgba(0,0,0,0.8);
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid rgba(255,215,0,0.5);
            font-family: monospace;
            line-height: 1.2;
        }
        
        /* Visual Enhancement Styles */
        .speed-lines {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 50;
        }
        
        .speed-line {
            position: absolute;
            width: 2px;
            height: 100px;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0.6), rgba(255,255,255,0));
            animation: speedLineMove 0.3s linear;
        }
        
        @keyframes speedLineMove {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            to {
                transform: translateY(100vh);
                opacity: 0;
            }
        }
        
        .vignette-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%);
            z-index: 60;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .vignette-overlay.active {
            opacity: 1;
        }
        
        /* UI Element Animations */
        .ui-glow {
            animation: uiGlow 2s ease-in-out infinite;
        }
        
        @keyframes uiGlow {
            0%, 100% {
                filter: drop-shadow(0 0 5px rgba(255,215,0,0.5));
            }
            50% {
                filter: drop-shadow(0 0 15px rgba(255,215,0,0.8));
            }
        }
        
        .ui-bounce {
            animation: uiBounce 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }
        
        @keyframes uiBounce {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }
        
        /* Motion Blur Effect */
        .motion-blur {
            filter: blur(0px);
            transition: filter 0.2s;
        }
        
        .motion-blur.active {
            filter: blur(2px);
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            text-align: right;
            z-index: 100;
        }
        
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        #menu h1 {
            margin-bottom: 20px;
            font-size: 32px;
        }
        
        #menu button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        #menu button:hover {
            background: #45a049;
        }
        
        #timer {
            font-size: 20px;
            margin-top: 5px;
        }
        
        .timer-warning {
            color: #FF4444 !important;
            animation: pulse 0.5s infinite;
        }
        
        .timer-critical {
            color: #FF0000 !important;
            animation: fastPulse 0.2s infinite;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes fastPulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.1); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-20px); }
            60% { transform: translateY(-10px); }
        }
        
        /* Near Miss and Milestone displays positioning */
        #nearMissDisplay {
            position: absolute;
            top: 150px;
            right: 20px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: pulse 0.5s ease-in-out;
        }
        
        #milestoneDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
        }
        
        #multiplierDisplay {
            opacity: 0.8;
        }
        
        .name-input-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 16px;
            z-index: 300;
            text-align: center;
            min-width: 350px;
            border: 2px solid #4CAF50;
        }
        
        .name-input-dialog input {
            width: 200px;
            padding: 10px;
            margin: 15px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
        }
        
        .name-input-dialog button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .name-input-dialog button:hover {
            background: #45a049;
        }
        
        .name-input-dialog button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .highscore-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
            min-width: 200px;
            font-size: 12px;
        }
        
        .highscore-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .highscore-entry.current-player {
            color: #4CAF50;
            font-weight: bold;
        }
        
        /* Gesture Control UI */
        #gestureControls {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 8px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 200;
        }
        
        #gestureToggle {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #gestureToggle:hover {
            background: #00cc70;
            transform: translateY(-2px);
        }
        
        #gestureToggle.active {
            background: #ff4444;
            color: white;
        }
        
        #calibrateBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        #calibrateBtn:hover {
            background: #45a049;
        }
        
        #calibrateBtn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #gestureStatus {
            color: #00ff88;
            font-weight: bold;
        }
        
        /* Video preview for gesture control */
        #gestureCanvas {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 2px solid #00ff88;
            border-radius: 8px;
            background: #000;
            z-index: 150;
            display: none;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
        }
        
        #gestureCanvas.active {
            display: block;
        }
        
        /* Gesture indicator */
        .gesture-feedback {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 48px;
            font-weight: bold;
            color: #00ff88;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 250;
        }
        
        .gesture-feedback.show {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Version Info Display -->
        <div id="versionInfo">
            🚀 V3.4.2-GAMIFICATION<br>
            📅 07.07.2025
        </div>
        
        <!-- Visual Effects Overlays -->
        <div id="speedLines" class="speed-lines"></div>
        <div id="vignetteOverlay" class="vignette-overlay"></div>
        
        <!-- Gesture Control UI -->
        <div id="gestureControls">
            <button id="gestureToggle" onclick="toggleGestureControl()">🎥 Gesten aktivieren</button>
            <button id="calibrateBtn" onclick="calibrateGestures()" disabled>🎯 Kalibrieren</button>
            <span id="gestureStatus">Gesten: Inaktiv</span>
        </div>
        
        <!-- Gesture Feedback -->
        <div class="gesture-feedback" id="gestureFeedback"></div>
        
        <!-- Hidden video element for camera -->
        <video id="gestureVideo" style="display: none;" autoplay playsinline></video>
        
        <!-- Canvas for gesture preview -->
        <canvas id="gestureCanvas"></canvas>
        
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Speed: <span id="speed">100</span></div>
            <div>❤️ Leben: <span id="lives">3</span></div>
            <div id="timer">⏱️ Zeit: <span id="timeRemaining">60</span>s</div>
            
            <!-- NEW: Power-Up & Coins UI -->
            <div id="kiwiCounter" style="color: #8BC34A; font-weight: bold;">
                🥝 <span id="kiwiCount">0</span>
            </div>
            <div id="comboDisplay" style="color: #FF6B35; display: none; font-size: 20px; animation: pulse 0.5s infinite;">
                COMBO x<span id="comboMultiplier">1</span>!
            </div>
            
            <!-- NEW: Near Miss Display -->
            <div id="nearMissDisplay" style="color: #FFD700; display: none; font-size: 18px; font-weight: bold;">
                NEAR MISS! x<span id="nearMissCount">1</span>
                <div style="font-size: 14px;">+<span id="nearMissBonus">50</span> Bonus!</div>
            </div>
            
            <!-- NEW: Milestone Display -->
            <div id="milestoneDisplay" style="color: #00FF00; display: none; font-size: 24px; font-weight: bold; animation: bounce 1s;">
                <span id="milestoneIcon">🏁</span> <span id="milestoneText">500m!</span>
                <div style="font-size: 16px;">+<span id="milestoneBonus">500</span> Punkte!</div>
            </div>
            
            <!-- NEW: Score Multiplier Display -->
            <div id="multiplierDisplay" style="color: #FF1493; font-size: 16px; font-weight: bold; margin-top: 5px;">
                Multiplikator: x<span id="currentMultiplier">1.0</span>
            </div>
            <div id="powerUpDisplay" style="color: #4ECDC4; display: none; font-weight: bold;">
                <span id="powerUpIcon">⚡</span> <span id="powerUpName">Speed</span>: <span id="powerUpTime">8</span>s
            </div>
            
            <!-- NEW: Skill Combo UI -->
            <div id="skillComboDisplay" style="color: #FF4500; display: none; font-size: 22px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8);">
                <span id="skillComboIcon">🔥</span> SKILL COMBO x<span id="skillComboCount">1</span>! 
                <div style="font-size: 14px; color: #FFD700;"><span id="skillComboBonus">+100</span> Punkte!</div>
            </div>
            
            <!-- NEW: Environment Display -->
            <div id="environmentDisplay" style="color: #87CEEB; font-weight: bold; margin-top: 10px;">
                🏙️ <span id="currentEnvironment">Straße</span>
            </div>
            
            <!-- NEW: Difficulty Progress Display -->
            <div id="difficultyDisplay" style="color: #FFB347; font-weight: bold; margin-top: 5px; font-size: 14px;">
                📈 Schwierigkeit: <span id="difficultyLevel">Leicht</span>
            </div>
        </div>
        
        <div id="instructions">
            <div><strong>🎮 Steuerung:</strong></div>
            <div>A/D: Spurwechsel</div>
            <div>Leertaste/W: Springen 🦘</div>
            <div>S: Ducken 🦆</div>
            <div><strong>📱 Touch-Steuerung:</strong></div>
            <div>← → Wischen: Spurwechsel</div>
            <div>↑ Wischen: Springen</div>
            <div>↓ Wischen: Ducken</div>
            <div><strong>💡 Tipps:</strong></div>
            <div>🟠 Orange/Braun: Überspringen!</div>
            <div>🔵 Blau/Grau oben: Ducken!</div>
            <div>🔴 Stacheln: Beides möglich!</div>
            <div><strong>🎯 Neue Features:</strong></div>
            <div>⚡ Near-Miss Bonus!</div>
            <div>🏁 Meilenstein-Belohnungen!</div>
            <div>🔥 Combo-Multiplikator!</div>
        </div>
        
        <div id="menu">
            <h1>🚇 Subway Runner 3D</h1>
            <h2>⏱️ 60-Sekunden Challenge!</h2>
            <p>Überlebe 60 Sekunden bei stetig steigender Geschwindigkeit!</p>
            <p><strong>🎯 Ziel:</strong> 60 Sekunden überleben</p>
            <p><strong>⚡ Warnung:</strong> Wird sehr schnell!</p>
            <p><strong>🎮 Steuerung:</strong></p>
            <p>A/D: Spurwechsel | W/Space: Springen | S: Ducken</p>
            <button onclick="startGame()">🎮 Challenge starten!</button>
        </div>
        
        <div id="highscorePanel" class="highscore-panel">
            <div style="font-weight: bold; margin-bottom: 10px;">🏆 TOP 10</div>
            <div id="highscoreList">Lade Bestenliste...</div>
        </div>
        
        <div id="nameInputDialog" class="name-input-dialog" style="display: none;">
            <h2>🎉 Neuer Highscore!</h2>
            <p>Gib deinen Namen ein:</p>
            <input type="text" id="playerNameInput" placeholder="Dein Name" maxlength="20">
            <br>
            <button onclick="submitHighscore()">💾 Speichern</button>
            <button onclick="skipHighscore()">⏭️ Überspringen</button>
        </div>
    </div>

    <script>
        // Audio System
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.sounds = {};
                this.masterVolume = 0.3;
                this.backgroundMusic = null;
                this.musicVolume = 0.15; // Lower volume for background music
                this.musicGain = null;
                this.musicLoaded = false;
                this.musicPlaying = false;
                this.initAudio();
            }

            async initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.gain.value = this.masterVolume;
                    this.masterGain.connect(this.audioContext.destination);
                    
                    // Create separate gain node for background music
                    this.musicGain = this.audioContext.createGain();
                    this.musicGain.gain.value = this.musicVolume;
                    this.musicGain.connect(this.audioContext.destination);
                    
                    this.createAdvancedSounds();
                    
                    // Preload background music (but don't play yet)
                    this.preloadBackgroundMusic();
                } catch (error) {
                    console.log('Audio not supported');
                }
            }

            async preloadBackgroundMusic() {
                try {
                    console.log('🎵 Starting background music preload...');
                    // Try to load background music file (multiple formats)
                    const musicPaths = [
                        'sounds/background/background.mp3',
                        'sounds/background/background.wav',
                        'sounds/background/game-music.mp3',
                        'sounds/background/game-music.wav',
                        'sounds/background/subway-theme.mp3',
                        'sounds/background/subway-theme.wav'
                    ];
                    
                    for (let path of musicPaths) {
                        try {
                            console.log(`🎵 Trying to load background music: ${path}`);
                            const audio = new Audio(path);
                            audio.preload = 'metadata'; // Changed from 'auto' for large files
                            audio.loop = true;
                            audio.volume = 0; // Start silent
                            audio.crossOrigin = 'anonymous'; // Fix CORS issues
                            
                            // Test if file exists by trying to load it
                            await new Promise((resolve, reject) => {
                                const timeout = setTimeout(() => {
                                    console.log(`⏰ Timeout loading: ${path}`);
                                    reject(new Error('Timeout'));
                                }, 10000); // 10 second timeout for large files
                                
                                audio.addEventListener('canplaythrough', () => {
                                    clearTimeout(timeout);
                                    console.log(`✅ Background music loaded: ${path}`);
                                    this.backgroundMusic = audio;
                                    this.musicLoaded = true;
                                    resolve();
                                });
                                audio.addEventListener('loadedmetadata', () => {
                                    console.log(`📊 Music metadata loaded: ${path} (${audio.duration}s)`);
                                });
                                audio.addEventListener('error', (e) => {
                                    clearTimeout(timeout);
                                    console.log(`❌ Audio error for ${path}:`, e);
                                    reject(e);
                                });
                                audio.load();
                            });
                            break; // If successful, stop trying other files
                        } catch (error) {
                            console.log(`❌ Failed to load: ${path}`);
                            continue; // Try next file
                        }
                    }
                    
                    if (!this.musicLoaded) {
                        console.log('🎵 No background music found - running without music');
                    }
                } catch (error) {
                    console.log('Background music preload failed:', error);
                }
            }

            startBackgroundMusic() {
                if (!this.backgroundMusic || !this.musicLoaded || this.musicPlaying) return;
                
                try {
                    this.backgroundMusic.currentTime = 0;
                    this.backgroundMusic.volume = this.musicVolume;
                    this.backgroundMusic.play();
                    this.musicPlaying = true;
                    
                    // Fade in effect
                    this.fadeInMusic();
                    console.log('🎵 Background music started');
                } catch (error) {
                    console.log('Failed to start background music:', error);
                }
            }

            stopBackgroundMusic() {
                if (!this.backgroundMusic || !this.musicPlaying) return;
                
                try {
                    this.fadeOutMusic(() => {
                        this.backgroundMusic.pause();
                        this.backgroundMusic.currentTime = 0;
                        this.musicPlaying = false;
                        console.log('🎵 Background music stopped');
                    });
                } catch (error) {
                    console.log('Failed to stop background music:', error);
                }
            }

            fadeInMusic(duration = 2000) {
                if (!this.backgroundMusic) return;
                
                const startVolume = 0;
                const endVolume = this.musicVolume;
                const steps = 20;
                const stepDuration = duration / steps;
                const volumeStep = (endVolume - startVolume) / steps;
                
                this.backgroundMusic.volume = startVolume;
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        if (this.backgroundMusic && this.musicPlaying) {
                            this.backgroundMusic.volume = Math.min(startVolume + (volumeStep * i), endVolume);
                        }
                    }, stepDuration * i);
                }
            }

            fadeOutMusic(callback, duration = 1000) {
                if (!this.backgroundMusic) return;
                
                const startVolume = this.backgroundMusic.volume;
                const steps = 20;
                const stepDuration = duration / steps;
                const volumeStep = startVolume / steps;
                
                for (let i = 0; i <= steps; i++) {
                    setTimeout(() => {
                        if (this.backgroundMusic) {
                            this.backgroundMusic.volume = Math.max(startVolume - (volumeStep * i), 0);
                            if (i === steps && callback) {
                                callback();
                            }
                        }
                    }, stepDuration * i);
                }
            }

            setMusicVolume(volume) {
                this.musicVolume = Math.max(0, Math.min(1, volume));
                if (this.backgroundMusic) {
                    this.backgroundMusic.volume = this.musicVolume;
                }
            }

            createTone(frequency, duration, type = 'sine', fadeOut = true) {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                if (fadeOut) {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                } else {
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                }
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }

            createNoise(duration, filterFreq = 1000) {
                if (!this.audioContext) return;
                
                const bufferSize = this.audioContext.sampleRate * duration;
                const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const source = this.audioContext.createBufferSource();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();
                
                source.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;
                
                source.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                source.start();
            }

            createAdvancedSounds() {
                // Enhanced realistic sounds using multiple layers
                this.sounds = {
                    jump: () => {
                        // Multi-layered jump sound: impact + whoosh + landing prep
                        this.createTone(180, 0.08, 'sine'); // Base thump
                        setTimeout(() => this.createTone(320, 0.12, 'triangle'), 20); // Whoosh up
                        setTimeout(() => this.createNoise(0.06, 4000), 40); // Air resistance
                        this.createReverbEffect(240, 0.15, 0.3); // Echo for depth
                    },
                    
                    land: () => {
                        // Heavy landing with ground impact and dust
                        this.createTone(80, 0.15, 'square'); // Deep thud
                        this.createNoise(0.12, 800); // Ground crunch
                        setTimeout(() => this.createNoise(0.08, 1500), 50); // Dust settle
                        this.createReverbEffect(120, 0.2, 0.4); // Ground echo
                    },
                    
                    duck: () => {
                        // Quick duck sound with fabric/wind
                        this.createTone(140, 0.15, 'sawtooth');
                        this.createNoise(0.1, 3500); // Wind resistance
                        setTimeout(() => this.createTone(110, 0.1, 'sine'), 80); // Body movement
                    },
                    
                    success: () => {
                        // Triumphant success with harmonic progression
                        const notes = [400, 500, 630, 800, 1000];
                        notes.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.2, 'sine');
                                this.createReverbEffect(freq, 0.15, 0.6); // Rich reverb
                            }, i * 80);
                        });
                        // Add sparkle effect
                        setTimeout(() => {
                            for (let j = 0; j < 8; j++) {
                                setTimeout(() => this.createTone(1200 + j * 100, 0.05, 'sine'), j * 25);
                            }
                        }, 400);
                    },
                    
                    collision: () => {
                        // Dramatic collision with multiple impact layers
                        this.createNoise(0.4, 1200); // Main crash
                        this.createTone(60, 0.6, 'sawtooth', false); // Low rumble
                        setTimeout(() => this.createNoise(0.25, 2500), 100); // Glass/debris
                        setTimeout(() => this.createTone(200, 0.3, 'square'), 150); // Metal impact
                        this.createReverbEffect(150, 0.8, 0.7); // Long echo
                        
                        // Add screen shake intensity based on collision
                        if (window.gameState) {
                            gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, 0.3);
                        }
                    },
                    
                    coin: () => {
                        // Magical kiwi collection with sparkle
                        this.createTone(800, 0.12, 'sine');
                        setTimeout(() => this.createTone(1200, 0.1, 'sine'), 40);
                        setTimeout(() => this.createTone(1600, 0.08, 'triangle'), 80);
                        this.createReverbEffect(1000, 0.2, 0.5); // Magical echo
                        // Add subtle high-frequency shimmer
                        setTimeout(() => {
                            for (let k = 0; k < 4; k++) {
                                setTimeout(() => this.createTone(2000 + k * 200, 0.03, 'sine'), k * 15);
                            }
                        }, 120);
                    },
                    
                    whoosh: () => {
                        // Enhanced lane change with speed-dependent pitch
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.5;
                        const baseFreq = 2000 + speedMultiplier * 2000;
                        this.createNoise(0.15 + speedMultiplier * 0.1, baseFreq);
                        this.createTone(250 + speedMultiplier * 100, 0.1, 'triangle');
                    },
                    
                    powerup: () => {
                        // Epic power-up activation sequence
                        const powerChord = [400, 500, 600, 750, 900];
                        powerChord.forEach((freq, i) => {
                            setTimeout(() => {
                                this.createTone(freq, 0.25, 'sine');
                                this.createReverbEffect(freq, 0.2, 0.8);
                            }, i * 60);
                        });
                        
                        // Add ascending energy effect
                        setTimeout(() => {
                            for (let m = 0; m < 12; m++) {
                                setTimeout(() => {
                                    this.createTone(1000 + m * 50, 0.04, 'triangle');
                                }, m * 30);
                            }
                        }, 300);
                    },
                    
                    // NEW: Ambient city sounds
                    ambient: () => {
                        if (!this.ambientPlaying) {
                            this.ambientPlaying = true;
                            this.playAmbientLoop();
                        }
                    },
                    
                    // NEW: Speed-based engine sound
                    engine: () => {
                        const speedMultiplier = window.gameState ? (gameState.speed / gameState.maxSpeed) : 0.3;
                        const engineFreq = 40 + speedMultiplier * 60;
                        this.createTone(engineFreq, 0.2, 'sawtooth', false);
                    },
                    
                    // NEW: Near miss bonus sound
                    nearmiss: () => {
                        this.createTone(600, 0.08, 'sine');
                        setTimeout(() => this.createTone(800, 0.06, 'triangle'), 30);
                        this.createNoise(0.05, 5000); // Subtle whoosh
                    }
                };
            }

            // Enhanced reverb effect for depth
            createReverbEffect(frequency, duration, intensity) {
                if (!this.audioContext) return;
                
                const delay = this.audioContext.createDelay(0.3);
                const feedback = this.audioContext.createGain();
                const wetGain = this.audioContext.createGain();
                
                delay.delayTime.value = 0.1;
                feedback.gain.value = intensity * 0.4;
                wetGain.gain.value = intensity * 0.3;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(delay);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(wetGain);
                wetGain.connect(this.masterGain);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            // Ambient city soundscape
            playAmbientLoop() {
                if (!this.audioContext || !this.ambientPlaying) return;
                
                // Distant traffic rumble
                const trafficFreq = 60 + Math.random() * 20;
                this.createTone(trafficFreq, 2.0, 'sawtooth', false);
                
                // Occasional distant sounds
                if (Math.random() > 0.7) {
                    setTimeout(() => {
                        this.createNoise(0.05, 800 + Math.random() * 1000);
                    }, Math.random() * 1000);
                }
                
                // Continue ambient loop
                setTimeout(() => this.playAmbientLoop(), 2000);
            }
            
            stopAmbient() {
                this.ambientPlaying = false;
            }
            
            // Dynamic sound based on game speed
            playSpeedDependentSound(soundName, speedMultiplier = 1) {
                const originalVolume = this.masterGain.gain.value;
                const speedVolume = Math.min(originalVolume * (0.8 + speedMultiplier * 0.4), 1.0);
                
                this.masterGain.gain.value = speedVolume;
                this.play(soundName);
                
                // Restore original volume
                setTimeout(() => {
                    this.masterGain.gain.value = originalVolume;
                }, 200);
            }
            
            play(soundName) {
                if (this.sounds[soundName]) {
                    try {
                        this.sounds[soundName]();
                    } catch (error) {
                        console.warn('Audio playback error:', error);
                    }
                } else {
                    // BUGFIX: Silently ignore missing sound effects to prevent console spam
                    // console.log(`Sound effect '${soundName}' not available`);
                }
            }

            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            }
        }

        const audioManager = new AudioManager();
        audioManager.ambientPlaying = false;
        
        // CRITICAL FIX: Centralized score management to prevent explosion
        function addScore(amount, source = 'unknown') {
            // Add to queue instead of directly to score
            gameState.scoreQueue += Math.max(0, Math.floor(amount));
            
            // Debug logging for score tracking
            if (amount > 0) {
                console.log(`🎯 Score queued: +${amount} from ${source} (queue: ${gameState.scoreQueue})`);
            }
        }
        
        function processScoreQueue() {
            const currentTime = performance.now();
            
            // Only process queue every scoreUpdateInterval
            if (currentTime - gameState.lastScoreUpdate < gameState.scoreUpdateInterval) {
                return;
            }
            
            if (gameState.scoreQueue > 0) {
                // Apply limited amount from queue
                const scoreToAdd = Math.min(gameState.scoreQueue, gameState.maxScorePerUpdate);
                gameState.score += scoreToAdd;
                gameState.scoreQueue -= scoreToAdd;
                
                gameState.lastScoreUpdate = currentTime;
                
                console.log(`📊 Score processed: +${scoreToAdd} (total: ${gameState.score}, remaining queue: ${gameState.scoreQueue})`);
            }
        }
        
        // Auto-start ambient sounds when game starts
        let ambientStarted = false;

        // Supabase Configuration - Using working credentials
        const SUPABASE_URL = 'https://umvrurelsxpxmyzcvrcd.supabase.co'
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVtdnJ1cmVsc3hweG15emN2cmNkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MzUzMzQ5OTYsImV4cCI6MjA1MDkxMDk5Nn0.xpBgJ0BQN86JqhNtKzKNl1kchO1IU_oXI7SYpgfLBJU'
        
        // Initialize Supabase client
        let supabase = null;
        let highscores = [];
        let currentScore = 0;
        let currentSurvivalTime = 0;

        // Initialize Supabase connection
        try {
            if (window.supabase) {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('✅ Supabase initialized successfully');
                console.log('🔗 Database URL:', SUPABASE_URL);
                console.log('🔑 Using API Key:', SUPABASE_ANON_KEY.substring(0, 20) + '...');
            } else {
                throw new Error('Supabase library not loaded');
            }
        } catch (error) {
            console.log('⚠️ Supabase initialization failed, using offline mode:', error);
            supabase = null;
        }

        // Highscore Management System
        class HighscoreManager {
            constructor() {
                this.localStorageKey = 'subwayRunner_highscores';
                this.loadHighscores();
            }

            async loadHighscores() {
                console.log('📊 Loading highscores...');
                try {
                    if (supabase) {
                        console.log('🔄 Fetching from Supabase...');
                        
                        // BUGFIX: Add timeout and better error handling for DNS issues
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Request timeout - possible DNS/network issue')), 5000)
                        );
                        
                        const supabasePromise = supabase
                            .from('subway_runner_scores')
                            .select('*')
                            .order('score', { ascending: false })
                            .limit(10);
                            
                        const { data, error } = await Promise.race([supabasePromise, timeoutPromise]);
                        
                        if (!error && data) {
                            console.log(`✅ Loaded ${data.length} scores from Supabase:`, data);
                            highscores = data;
                        } else {
                            console.log('❌ Supabase error:', error);
                            throw new Error('Supabase error: ' + (error?.message || 'Unknown'));
                        }
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    console.log('⚠️ Network/DNS error, falling back to localStorage:', error.message);
                    // Fallback to localStorage
                    const localScores = localStorage.getItem(this.localStorageKey);
                    highscores = localScores ? JSON.parse(localScores) : [];
                    console.log(`📱 Loaded ${highscores.length} local scores:`, highscores);
                }
                this.displayHighscores();
            }

            async submitScore(playerName, score, survivalTime, isVictory) {
                const scoreEntry = {
                    player_name: playerName,
                    score: score,
                    survival_time: survivalTime,
                    is_victory: isVictory,
                    created_at: new Date().toISOString()
                };

                console.log('💾 Submitting score:', scoreEntry);

                try {
                    if (supabase) {
                        console.log('🔄 Inserting to Supabase...');
                        const { data, error } = await supabase
                            .from('subway_runner_scores')
                            .insert([scoreEntry])
                            .select();
                        
                        if (error) {
                            console.log('❌ Supabase insert error:', error);
                            throw error;
                        }
                        
                        console.log('✅ Score submitted to Supabase:', data);
                    } else {
                        throw new Error('No Supabase connection');
                    }
                } catch (error) {
                    console.log('⚠️ Supabase submit failed, using localStorage:', error.message);
                    // Fallback to localStorage
                    highscores.push(scoreEntry);
                    highscores.sort((a, b) => b.score - a.score);
                    highscores = highscores.slice(0, 10); // Keep only top 10
                    localStorage.setItem(this.localStorageKey, JSON.stringify(highscores));
                    console.log('📱 Score saved locally');
                }

                await this.loadHighscores();
            }

            isHighscore(score) {
                if (highscores.length < 10) return true;
                return score > highscores[9].score;
            }

            displayHighscores() {
                const list = document.getElementById('highscoreList');
                if (highscores.length === 0) {
                    list.innerHTML = 'Keine Scores vorhanden';
                    return;
                }

                let html = '';
                highscores.forEach((score, index) => {
                    const rank = index + 1;
                    const victoryIcon = score.is_victory ? '🏆' : '';
                    const timeText = score.is_victory ? '60s' : `${score.survival_time}s`;
                    
                    html += `<div class="highscore-entry">
                        ${rank}. ${score.player_name} ${victoryIcon}<br>
                        <small>${score.score} pts - ${timeText}</small>
                    </div>`;
                });
                list.innerHTML = html;
            }
        }

        const highscoreManager = new HighscoreManager();

        // Make functions globally available for onclick handlers
        window.startGame = function() {
            console.log('startGame called');
            try {
                startGameInternal();
            } catch (error) {
                console.error('Error in startGame:', error);
            }
        };

        window.submitHighscore = function() {
            console.log('submitHighscore called');
            submitHighscoreInternal();
        };

        window.skipHighscore = function() {
            console.log('skipHighscore called');
            skipHighscoreInternal();
        };

        // Game state
        let gameState = {
            isPlaying: false,
            isGameOver: false,
            isVictory: false,
            score: 0,
            speed: 0.08, // Langsamerer Start
            baseSpeed: 0.08,
            maxSpeed: 0.45, // Sehr schnell am Ende!
            lives: 3,
            gameTime: 60, // 60 Sekunden
            timeRemaining: 60,
            gameStartTime: 0,
            playerLane: 1, // 0=left, 1=center, 2=right
            playerAction: 'running', // running, jumping, ducking
            playerY: 0,
            jumpVelocity: 0,
            jumpStartTime: 0,  // BUGFIX: Track jump start time for safety
            maxJumpDuration: 2000, // Maximum 2 seconds jump duration
            obstacles: [],
            invulnerable: false,
            invulnerabilityTime: 0,
            timeScale: 1.0,
            cameraShakeIntensity: 0,
            cameraZoom: 1.0,
            slowMotionActive: false,
            
            // NEW: Power-Up & Collectibles System
            powerUps: [],              // Spawned power-ups in world
            kiwis: [],                 // Spawned kiwis in world
            broccolis: [],             // Spawned broccolis in world  
            collectedKiwis: 0,         // Current session kiwis
            collectedBroccolis: 0,     // Current session broccolis
            totalKiwis: 0,             // Lifetime kiwis
            totalBroccolis: 0,         // Lifetime broccolis
            totalCollectibles: 0,      // Total spawned this session
            collectionGoal: 10,        // Target collectibles for bonus (80% of max ~12-15)
            collectionBonusAwarded: false, // Track if 80% collection bonus was awarded
            activePowerUp: null,       // Currently active power-up
            powerUpTimeRemaining: 0,   // Time left for active power-up
            magnetActive: false,       // Magnet power-up state
            shieldActive: false,       // Shield power-up state
            speedBoostActive: false,   // Speed boost power-up state
            kiwiCombo: 0,              // Current kiwi collection combo
            comboMultiplier: 1,        // Score multiplier from combos
            lastKiwiTime: 0,           // For combo timeout
            
            // NEW: Advanced Skill & Combo System
            skillCombo: 0,             // Current skill move combo (dodge sequences)
            lastSkillTime: 0,          // Time of last skill move
            moveSequence: [],          // Track recent moves for combo detection
            consecutiveAvoidances: 0,  // Count of consecutive obstacle avoidances
            lastAvoidanceTime: 0,      // Time of last successful avoidance
            lastAction: 'running',     // Track last player action for sequences
            rapidMoveBonus: 0,         // Bonus for rapid direction changes
            perfectTimingCount: 0,     // Count of perfect timing moves
            skillMultiplier: 1,        // Score multiplier for skill moves
            comboActive: false,        // Visual indicator for active combo
            
            // NEW: Enhanced Gameplay Features
            nearMissStreak: 0,         // Consecutive near misses
            lastNearMissTime: 0,       // Time of last near miss
            nearMissMultiplier: 1,     // Bonus multiplier for near misses
            milestoneReached: 0,       // Track distance milestones
            lastMilestone: 0,          // Last milestone distance
            scoreMultiplier: 1,        // Combined score multiplier
            maxCombo: 0,               // Highest combo achieved
            perfectRun: true,          // No hits taken
            totalDistance: 0,          // Total distance travelled
            
            // Touch Controls
            touchStartX: 0,
            touchStartY: 0,
            touchThreshold: 50,        // Swipe distance threshold
            isTouchDevice: false,      // Auto-detect touch support
            
            // Environment state
            currentEnvironment: 'street', // 'street', 'tunnel', 'tunnel_entrance', 'tunnel_exit'
            environmentTransition: false,
            tunnelProgress: 0,
            tunnelStartTime: 0,
            tunnelDuration: 15000, // 15 seconds in tunnel
            nextTunnelTime: 20000, // First tunnel after 20 seconds
            tunnelCooldown: 30000, // 30 seconds between tunnels
            lastTunnelExit: 0,
            tunnelSegments: [], // Tunnel wall/ceiling segments
            tunnelLights: [], // Tunnel lighting
            ambientLightIntensity: 1.0, // For tunnel dimming effect
            
            // Visual Effects State
            speedLineIntensity: 0,
            currentFogDensity: 0.002,
            targetFogDensity: 0.002,
            motionBlurActive: false,
            vignetteIntensity: 0,
            particleEffects: [],
            
            // Score update throttling (FIX: Prevent 60FPS score updates)
            lastScoreUpdate: 0,
            scoreUpdateInterval: 100, // Update score every 100ms (10 times per second)
            
            // Centralized score queue for throttling ALL score additions
            scoreQueue: 0,
            maxScorePerUpdate: 100 // Maximum score increase per throttled update
        };

        // Three.js setup
        let scene, camera, renderer, player, track, obstacles = [];
        const LANE_POSITIONS = [-2, 0, 2];
        
        // Power-Up and Collectible arrays for tracking
        let powerUps = [];
        let kiwis = [];
        let broccolis = [];  // NEW: Brokkoli tracking
        
        // Power-Up configuration
        const POWER_UP_TYPES = {
            magnet: {
                name: 'Magnet',
                icon: '🧲',
                color: 0xFFD700,
                duration: 15000, // 15 seconds
                effect: 'magnetActive'
            },
            shield: {
                name: 'Shield', 
                icon: '🛡️',
                color: 0x4ECDC4,
                duration: 10000, // 10 seconds
                effect: 'shieldActive'
            },
            speedboost: {
                name: 'Speed Boost',
                icon: '⚡',
                color: 0xFF6B35,
                duration: 8000, // 8 seconds
                effect: 'speedBoostActive'
            }
        };
        
        // Environment object tracking for parallax movement
        let environmentObjects = {
            buildings: [],
            streetLamps: [],
            trafficSigns: [],
            streetLines: [],
            sidewalks: []
        };
        
        // Smooth speed system
        let visualSpeed = 0.08;
        let lastFrameTime = 0;
        const SPEED_LERP_FACTOR = 0.05;

        function init() {
            console.log('Initializing Three.js scene...');
            try {
                // Scene with enhanced fog
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x87CEEB, gameState.currentFogDensity);

            // Camera (Subway Surfers perspective)
            camera = new THREE.PerspectiveCamera(60, 4/3, 0.1, 1000);
            camera.position.set(0, 3, 8);

            // Renderer
            const canvas = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Modern lighting system
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0x404080, 0.4);
            scene.add(ambientLight);

            // Main directional light (sun)
            const directionalLight = new THREE.DirectionalLight(0xFFE4B5, 1.2);
            directionalLight.position.set(10, 15, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            directionalLight.shadow.bias = -0.0005;
            scene.add(directionalLight);

            // Atmospheric hemisphere light for sky gradient
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x228B22, 0.6);
            scene.add(hemisphereLight);

            // Rim lighting for urban atmosphere
            const rimLight = new THREE.DirectionalLight(0x4A90E2, 0.3);
            rimLight.position.set(-5, 8, -10);
            scene.add(rimLight);

            // Enhance renderer for better visuals
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.outputColorSpace = THREE.SRGBColorSpace;

            // Create player
            createPlayer();
            
            // Create track
            createTrack();
            
            // Create environment
            createEnvironment();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
                // Start render loop
                animate();
                console.log('Three.js initialization complete');
            } catch (error) {
                console.error('Error initializing Three.js:', error);
            }
        }

        function createPlayer() {
            const playerGroup = new THREE.Group();
            
            // Player body (torso)
            const bodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A90E2
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.7;
            body.castShadow = true;
            playerGroup.add(body);

            // Player head
            const headGeometry = new THREE.SphereGeometry(0.25);
            const headMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF5B041
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.35;
            head.castShadow = true;
            playerGroup.add(head);

            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05);
            const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 1.4, 0.2);
            playerGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 1.4, 0.2);
            playerGroup.add(rightEye);

            // Arms
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
            const armMaterial = new THREE.MeshLambertMaterial({ color: 0xF5B041 });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.4, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            playerGroup.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.4, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            // Legs
            const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.6);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x2C3E50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.15, 0.0, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.15, 0.0, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            // Shoes
            const shoeGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
            const shoeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            
            const leftShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            leftShoe.position.set(-0.15, -0.35, 0.1);
            leftShoe.castShadow = true;
            playerGroup.add(leftShoe);
            
            const rightShoe = new THREE.Mesh(shoeGeometry, shoeMaterial);
            rightShoe.position.set(0.15, -0.35, 0.1);
            rightShoe.castShadow = true;
            playerGroup.add(rightShoe);

            // Backpack
            const backpackGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.2);
            const backpackMaterial = new THREE.MeshLambertMaterial({ color: 0xE74C3C });
            const backpack = new THREE.Mesh(backpackGeometry, backpackMaterial);
            backpack.position.set(0, 0.7, -0.25);
            backpack.castShadow = true;
            playerGroup.add(backpack);

            // Cap
            const capGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1);
            const capMaterial = new THREE.MeshLambertMaterial({ color: 0xFF6B35 });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.55;
            cap.castShadow = true;
            playerGroup.add(cap);

            // Cap visor
            const visorGeometry = new THREE.CylinderGeometry(0.35, 0.4, 0.02);
            const visorMaterial = new THREE.MeshLambertMaterial({ color: 0xFF4500 });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 1.48, 0.2);
            visor.rotation.x = -0.3;
            visor.castShadow = true;
            playerGroup.add(visor);

            playerGroup.position.set(LANE_POSITIONS[gameState.playerLane], 0, 0);
            
            // FIX: Player should look forward (negative Z direction)
            playerGroup.rotation.y = Math.PI;
            
            scene.add(playerGroup);
            player = playerGroup;
        }

        function createTrack() {
            const trackGroup = new THREE.Group();
            
            // Create track segments
            for (let i = 0; i < 10; i++) {
                const segmentGroup = new THREE.Group();
                segmentGroup.position.z = -i * 10;
                
                // Main track
                const trackGeometry = new THREE.BoxGeometry(8, 0.1, 10);
                const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
                trackMesh.receiveShadow = true;
                segmentGroup.add(trackMesh);
                
                // Lane dividers
                const dividerGeometry = new THREE.BoxGeometry(0.1, 0.05, 10);
                const dividerMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
                
                const leftDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                leftDivider.position.x = -1;
                segmentGroup.add(leftDivider);
                
                const rightDivider = new THREE.Mesh(dividerGeometry, dividerMaterial);
                rightDivider.position.x = 1;
                segmentGroup.add(rightDivider);
                
                trackGroup.add(segmentGroup);
            }
            
            scene.add(trackGroup);
            track = trackGroup;
        }

        function createEnvironment() {
            // Urban ground with asphalt texture
            const groundGeometry = new THREE.PlaneGeometry(80, 120);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.set(0, -1, -30);
            ground.receiveShadow = true;
            scene.add(ground);

            // Sidewalks
            const sidewalkGeometry = new THREE.PlaneGeometry(8, 120);
            const sidewalkMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x999999
            });
            
            const leftSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            leftSidewalk.rotation.x = -Math.PI / 2;
            leftSidewalk.position.set(-10, -0.98, -30);
            leftSidewalk.receiveShadow = true;
            leftSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(leftSidewalk);
            environmentObjects.sidewalks.push(leftSidewalk);
            
            const rightSidewalk = new THREE.Mesh(sidewalkGeometry, sidewalkMaterial);
            rightSidewalk.rotation.x = -Math.PI / 2;
            rightSidewalk.position.set(10, -0.98, -30);
            rightSidewalk.receiveShadow = true;
            rightSidewalk.userData = { 
                type: 'sidewalk', 
                initialZ: -30,
                parallaxSpeed: 0.6 // 60% of game speed (background)
            };
            scene.add(rightSidewalk);
            environmentObjects.sidewalks.push(rightSidewalk);

            // Street lines
            for (let i = 0; i < 20; i++) {
                const lineGeometry = new THREE.PlaneGeometry(0.3, 2);
                const lineMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFFFF });
                const streetLine = new THREE.Mesh(lineGeometry, lineMaterial);
                streetLine.rotation.x = -Math.PI / 2;
                streetLine.position.set(0, -0.95, -i * 6);
                streetLine.userData = { 
                    type: 'streetLine', 
                    initialZ: -i * 6,
                    parallaxSpeed: 0.95 // 95% of game speed (close to track)
                };
                scene.add(streetLine);
                environmentObjects.streetLines.push(streetLine);
            }

            // Realistic city buildings
            for (let i = 0; i < 15; i++) {
                createRealisticBuilding(-15 - Math.random() * 8, -i * 8 - Math.random() * 4, 'left');
                createRealisticBuilding(15 + Math.random() * 8, -i * 8 - Math.random() * 4, 'right');
            }

            // Street lamps
            for (let i = 0; i < 12; i++) {
                createStreetLamp(-6, -i * 10);
                createStreetLamp(6, -i * 10);
            }

            // Traffic signs and urban details
            for (let i = 0; i < 8; i++) {
                if (Math.random() > 0.5) {
                    createTrafficSign(-7, -i * 12 - 5);
                    createTrafficSign(7, -i * 12 - 5);
                }
            }
        }

        function createRealisticBuilding(x, z, side) {
            const buildingGroup = new THREE.Group();
            
            // Building dimensions
            const width = 4 + Math.random() * 3;
            const depth = 4 + Math.random() * 3;
            const height = 8 + Math.random() * 12;
            
            // Main building structure
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            
            // Create building materials with windows
            const buildingMaterial = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.2, 0.3 + Math.random() * 0.4)
            });
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2 - 1; // Ground level
            building.castShadow = true;
            building.receiveShadow = true;
            buildingGroup.add(building);

            // Windows
            const windowsPerFloor = Math.floor(width / 1.5);
            const floors = Math.floor(height / 3);
            
            for (let floor = 0; floor < floors; floor++) {
                for (let w = 0; w < windowsPerFloor; w++) {
                    // Window facing the street
                    const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                    const isLit = Math.random() > 0.4;
                    const windowMaterial = new THREE.MeshLambertMaterial({ 
                        color: isLit ? 0xFFFF88 : 0x222244,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const window = new THREE.Mesh(windowGeometry, windowMaterial);
                    const windowX = -width/2 + 0.7 + w * 1.5;
                    const windowY = floor * 3 + 1.5;
                    const windowZ = side === 'left' ? depth/2 + 0.01 : -depth/2 - 0.01;
                    
                    window.position.set(windowX, windowY, windowZ);
                    if (side === 'right') window.rotation.y = Math.PI;
                    
                    buildingGroup.add(window);
                }
            }

            // Rooftop details
            if (Math.random() > 0.6) {
                // Air conditioning units
                const acGeometry = new THREE.BoxGeometry(1, 0.5, 1);
                const acMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                const ac = new THREE.Mesh(acGeometry, acMaterial);
                ac.position.set(0, height/2 + 0.25, 0);
                ac.castShadow = true;
                buildingGroup.add(ac);
            }

            if (Math.random() > 0.7) {
                // Antenna
                const antennaGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2);
                const antennaMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
                antenna.position.set(0, height/2 + 1, 0);
                buildingGroup.add(antenna);
            }

            buildingGroup.position.set(x, 0, z);
            buildingGroup.userData = { 
                type: 'building', 
                initialZ: z,
                parallaxSpeed: 0.7 + Math.random() * 0.2 // 70-90% of game speed
            };
            scene.add(buildingGroup);
            environmentObjects.buildings.push(buildingGroup);
        }

        function createStreetLamp(x, z) {
            const lampGroup = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 1;
            pole.castShadow = true;
            lampGroup.add(pole);
            
            // Light fixture
            const lightGeometry = new THREE.SphereGeometry(0.3);
            const lightMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFF88,
                emissive: 0x444400
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = 3;
            lampGroup.add(light);
            
            // Add point light
            const pointLight = new THREE.PointLight(0xFFFF88, 0.5, 10);
            pointLight.position.y = 3;
            lampGroup.add(pointLight);
            
            lampGroup.position.set(x, 0, z);
            lampGroup.userData = { 
                type: 'streetLamp', 
                initialZ: z,
                parallaxSpeed: 0.85 // 85% of game speed
            };
            scene.add(lampGroup);
            environmentObjects.streetLamps.push(lampGroup);
        }

        function createTrafficSign(x, z) {
            const signGroup = new THREE.Group();
            
            // Sign post
            const postGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2.5);
            const postMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const post = new THREE.Mesh(postGeometry, postMaterial);
            post.position.y = 0.25;
            signGroup.add(post);
            
            // Sign board
            const signGeometry = new THREE.PlaneGeometry(1, 1);
            const signMaterial = new THREE.MeshLambertMaterial({ 
                color: Math.random() > 0.5 ? 0xFF4444 : 0x4444FF
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.y = 2;
            sign.rotation.y = x < 0 ? Math.PI/4 : -Math.PI/4;
            signGroup.add(sign);
            
            signGroup.position.set(x, 0, z);
            signGroup.userData = { 
                type: 'trafficSign', 
                initialZ: z,
                parallaxSpeed: 0.8 // 80% of game speed
            };
            scene.add(signGroup);
            environmentObjects.trafficSigns.push(signGroup);
        }

        function createObstacle(type, lane, z) {
            const obstacleGroup = new THREE.Group();
            obstacleGroup.position.set(LANE_POSITIONS[lane], 0, z);
            
            let obstacleGeometry, obstacleMaterial, height;
            
            switch (type) {
                case 'lowbarrier':
                    // Niedrige Barriere - muss übersprungen werden
                    obstacleGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35
                    });
                    height = 0.8;
                    break;
                case 'highbarrier':
                    // Hohe Barriere - muss unterduckt werden
                    obstacleGeometry = new THREE.BoxGeometry(1.8, 0.4, 0.3);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B0000
                    });
                    height = 0.4;
                    break;
                case 'spikes':
                    // Stacheln - überspringen oder ducken
                    obstacleGeometry = new THREE.ConeGeometry(0.25, 0.6, 6);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF4500,
                        emissive: 0x221100
                    });
                    height = 0.6;
                    break;
                case 'jumpblock':
                    // Block zum Überspringen - Concrete texture
                    obstacleGeometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x8B8B8B
                    });
                    height = 1.2;
                    // Add concrete details
                    const detailGeom = new THREE.BoxGeometry(0.1, 0.1, 1.3);
                    const detailMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
                    for (let i = 0; i < 4; i++) {
                        const detail = new THREE.Mesh(detailGeom, detailMat);
                        detail.position.set(
                            (i % 2 - 0.5) * 1.2, 
                            (Math.floor(i / 2) - 0.5) * 1.2, 
                            0
                        );
                        detail.castShadow = true;
                        obstacleGroup.add(detail);
                    }
                    break;
                case 'duckbeam':
                    // Balken zum Unterducken - Metal beam
                    obstacleGeometry = new THREE.BoxGeometry(2.2, 0.3, 0.8);
                    obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x4682B4
                    });
                    height = 0.3;
                    // Add support struts
                    const strutGeom = new THREE.CylinderGeometry(0.05, 0.05, 1.8);
                    const strutMat = new THREE.MeshLambertMaterial({ color: 0x334455 });
                    for (let i = 0; i < 2; i++) {
                        const strut = new THREE.Mesh(strutGeom, strutMat);
                        strut.position.set((i - 0.5) * 1.5, -0.75, 0);
                        strut.castShadow = true;
                        obstacleGroup.add(strut);
                    }
                    break;
                case 'hurdleset':
                    // Hürden-Set - mehrere niedrige Hürden
                    for (let i = 0; i < 3; i++) {
                        const hurdleGeometry = new THREE.BoxGeometry(1.4, 0.7, 0.2);
                        const hurdleMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x228B22
                        });
                        const hurdle = new THREE.Mesh(hurdleGeometry, hurdleMaterial);
                        hurdle.position.set(0, 0.35, -0.5 + i * 0.5);
                        hurdle.castShadow = true;
                        hurdle.receiveShadow = true;
                        obstacleGroup.add(hurdle);
                        
                        // Add warning stripes
                        const stripeGeom = new THREE.PlaneGeometry(1.5, 0.1);
                        const stripeMat = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFF00,
                            transparent: true,
                            opacity: 0.8
                        });
                        const stripe = new THREE.Mesh(stripeGeom, stripeMat);
                        stripe.position.set(0, 0.6, -0.5 + i * 0.5 + 0.11);
                        obstacleGroup.add(stripe);
                    }
                    height = 0.7;
                    break;
                case 'wallgap':
                    // Wand mit Lücke zum Ducken - Industrial wall
                    const wallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090
                    });
                    
                    const wallLeft = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallLeft.position.set(-0.5, 1.25, 0);
                    wallLeft.castShadow = true;
                    wallLeft.receiveShadow = true;
                    obstacleGroup.add(wallLeft);
                    
                    const wallRight = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 2.5, 0.4),
                        wallMaterial
                    );
                    wallRight.position.set(0.5, 1.25, 0);
                    wallRight.castShadow = true;
                    wallRight.receiveShadow = true;
                    obstacleGroup.add(wallRight);
                    
                    const wallTop = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.8, 0.4),
                        wallMaterial
                    );
                    wallTop.position.set(0, 2.1, 0);
                    wallTop.castShadow = true;
                    wallTop.receiveShadow = true;
                    obstacleGroup.add(wallTop);
                    
                    // Add hazard warning lights
                    const lightGeom = new THREE.SphereGeometry(0.08);
                    const lightMat = new THREE.MeshLambertMaterial({ 
                        color: 0xFF0000,
                        emissive: 0x440000
                    });
                    const warningLight = new THREE.Mesh(lightGeom, lightMat);
                    warningLight.position.set(0, 1.3, 0.25);
                    obstacleGroup.add(warningLight);
                    
                    height = 1.3; // Höhe der Lücke
                    break;
                    
                case 'rotatingblade':
                    // NEW: Rotating blade obstacle
                    const bladeGroup = new THREE.Group();
                    
                    // Central hub
                    const hubGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.4);
                    const hubMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hub = new THREE.Mesh(hubGeometry, hubMaterial);
                    hub.position.y = 1;
                    bladeGroup.add(hub);
                    
                    // Rotating blades
                    for (let i = 0; i < 3; i++) {
                        const bladeGeometry = new THREE.BoxGeometry(2, 0.1, 0.2);
                        const bladeMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0x8B0000,
                            emissive: 0x220000
                        });
                        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                        blade.position.y = 1;
                        blade.rotation.y = (i * Math.PI * 2) / 3;
                        blade.castShadow = true;
                        bladeGroup.add(blade);
                    }
                    
                    // Add warning lights
                    for (let j = 0; j < 2; j++) {
                        const warnLight = new THREE.Mesh(
                            new THREE.SphereGeometry(0.06),
                            new THREE.MeshLambertMaterial({ 
                                color: 0xFF0000,
                                emissive: 0x330000
                            })
                        );
                        warnLight.position.set(j === 0 ? -1.2 : 1.2, 1.5, 0);
                        bladeGroup.add(warnLight);
                    }
                    
                    obstacleGroup.add(bladeGroup);
                    height = 2;
                    break;
                    
                case 'swinginghammer':
                    // NEW: Swinging hammer obstacle
                    const hammerGroup = new THREE.Group();
                    
                    // Support structure
                    const supportGeometry = new THREE.BoxGeometry(0.2, 3, 0.2);
                    const supportMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const support = new THREE.Mesh(supportGeometry, supportMaterial);
                    support.position.y = 1.5;
                    support.castShadow = true;
                    hammerGroup.add(support);
                    
                    // Swinging arm
                    const armGroup = new THREE.Group();
                    const armGeometry = new THREE.BoxGeometry(0.1, 1.5, 0.1);
                    const armMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
                    const arm = new THREE.Mesh(armGeometry, armMaterial);
                    arm.position.y = -0.75;
                    arm.castShadow = true;
                    armGroup.add(arm);
                    
                    // Hammer head
                    const hammerGeometry = new THREE.BoxGeometry(0.8, 0.4, 0.6);
                    const hammerMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
                    const hammerHead = new THREE.Mesh(hammerGeometry, hammerMaterial);
                    hammerHead.position.y = -1.4;
                    hammerHead.castShadow = true;
                    armGroup.add(hammerHead);
                    
                    armGroup.position.y = 3;
                    hammerGroup.add(armGroup);
                    obstacleGroup.add(hammerGroup);
                    height = 1.8;
                    break;
                    
                case 'movingwall':
                    // NEW: Side-to-side moving wall
                    const movingWallGeometry = new THREE.BoxGeometry(0.3, 2, 1);
                    const movingWallMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x708090,
                        transparent: true,
                        opacity: 0.9
                    });
                    const movingWall = new THREE.Mesh(movingWallGeometry, movingWallMaterial);
                    movingWall.position.y = 1;
                    movingWall.castShadow = true;
                    
                    // Add warning stripes
                    for (let k = 0; k < 4; k++) {
                        const stripeGeometry = new THREE.PlaneGeometry(0.35, 0.2);
                        const stripeMaterial = new THREE.MeshLambertMaterial({ 
                            color: k % 2 === 0 ? 0xFFFF00 : 0xFF0000
                        });
                        const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                        stripe.position.set(0.16, 0.5 + k * 0.4, 0);
                        movingWall.add(stripe);
                    }
                    
                    obstacleGroup.add(movingWall);
                    height = 2;
                    break;
                    
                case 'bouncingball':
                    // NEW: Bouncing ball obstacle - bounces up and down
                    const ballGroup = new THREE.Group();
                    
                    // Main bouncing ball
                    const ballGeometry = new THREE.SphereGeometry(0.6);
                    const ballMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFF6B35,
                        emissive: 0x331100
                    });
                    const bouncingBall = new THREE.Mesh(ballGeometry, ballMaterial);
                    bouncingBall.position.y = 1.5; // Starting height
                    bouncingBall.castShadow = true;
                    ballGroup.add(bouncingBall);
                    
                    // Shadow indicator on ground
                    const shadowGeometry = new THREE.CircleGeometry(0.4);
                    const shadowMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.3
                    });
                    const ballShadow = new THREE.Mesh(shadowGeometry, shadowMaterial);
                    ballShadow.rotation.x = -Math.PI / 2;
                    ballShadow.position.y = 0.01; // Just above ground
                    ballGroup.add(ballShadow);
                    
                    // Warning ring around bounce area
                    const ringGeometry = new THREE.RingGeometry(0.8, 1.0);
                    const ringMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0xFFFF00,
                        transparent: true,
                        opacity: 0.6
                    });
                    const warningRing = new THREE.Mesh(ringGeometry, ringMaterial);
                    warningRing.rotation.x = -Math.PI / 2;
                    warningRing.position.y = 0.02;
                    ballGroup.add(warningRing);
                    
                    obstacleGroup.add(ballGroup);
                    height = 3; // Max bounce height
                    break;
                    
                case 'spinninglaser':
                    // NEW: Spinning laser beam obstacle
                    const laserGroup = new THREE.Group();
                    
                    // Central hub
                    const laserHubGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.6);
                    const laserHubMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x333333,
                        emissive: 0x110011
                    });
                    const laserHub = new THREE.Mesh(laserHubGeometry, laserHubMaterial);
                    laserHub.position.y = 1.2;
                    laserHub.castShadow = true;
                    laserGroup.add(laserHub);
                    
                    // Spinning laser beam (multiple segments for effect)
                    const laserBeamGroup = new THREE.Group();
                    for (let i = 0; i < 2; i++) {
                        const beamGeometry = new THREE.BoxGeometry(3, 0.1, 0.1);
                        const beamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0044,
                            emissive: 0x660022,
                            transparent: true,
                            opacity: 0.8
                        });
                        const laserBeam = new THREE.Mesh(beamGeometry, beamMaterial);
                        laserBeam.position.y = 1.2;
                        laserBeam.rotation.y = i * Math.PI; // 180 degrees apart
                        laserBeam.castShadow = true;
                        laserBeamGroup.add(laserBeam);
                        
                        // Add glowing effect with smaller inner beam
                        const innerBeamGeometry = new THREE.BoxGeometry(3, 0.05, 0.05);
                        const innerBeamMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFFFFFF,
                            emissive: 0xFF0044
                        });
                        const innerBeam = new THREE.Mesh(innerBeamGeometry, innerBeamMaterial);
                        innerBeam.position.copy(laserBeam.position);
                        innerBeam.rotation.copy(laserBeam.rotation);
                        laserBeamGroup.add(innerBeam);
                    }
                    
                    laserGroup.add(laserBeamGroup);
                    
                    // Warning lights at corners
                    for (let j = 0; j < 4; j++) {
                        const angle = (j * Math.PI) / 2;
                        const lightGeometry = new THREE.SphereGeometry(0.08);
                        const lightMaterial = new THREE.MeshLambertMaterial({ 
                            color: 0xFF0000,
                            emissive: 0x440000
                        });
                        const warningLight = new THREE.Mesh(lightGeometry, lightMaterial);
                        warningLight.position.set(
                            Math.cos(angle) * 1.8,
                            0.2,
                            Math.sin(angle) * 1.8
                        );
                        laserGroup.add(warningLight);
                    }
                    
                    obstacleGroup.add(laserGroup);
                    height = 1.4; // Laser height
                    break;
            }
            
            // Für einfache Hindernisse (nicht die komplexen oder neuen Typen)
            if (type !== 'hurdleset' && type !== 'wallgap' && 
                type !== 'rotatingblade' && type !== 'swinginghammer' && type !== 'movingwall' &&
                type !== 'bouncingball' && type !== 'spinninglaser') {
                const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                obstacle.castShadow = true;
                
                if (type === 'spikes') {
                    obstacle.position.y = height / 2;
                } else if (type === 'duckbeam') {
                    obstacle.position.y = 1.8; // Hoch positioniert zum Ducken
                } else if (type === 'highbarrier') {
                    obstacle.position.y = 1.8; // Hoch positioniert zum Ducken
                } else {
                    obstacle.position.y = height / 2;
                }
                
                obstacleGroup.add(obstacle);
            }
            
            scene.add(obstacleGroup);
            
            // Enhanced obstacle data with animation properties
            const obstacleData = {
                mesh: obstacleGroup,
                type: type,
                lane: lane,
                z: z,
                height: height,
                animationTime: 0,
                rotationSpeed: 0,
                swingAmplitude: 0,
                swingSpeed: 0,
                movementRange: 0,
                movementSpeed: 0,
                initialX: LANE_POSITIONS[lane]
            };
            
            // Set animation properties for moving obstacles
            switch (type) {
                case 'rotatingblade':
                    obstacleData.rotationSpeed = 3 + Math.random() * 2; // Random rotation speed
                    break;
                case 'swinginghammer':
                    obstacleData.swingAmplitude = Math.PI / 3; // 60 degree swing
                    obstacleData.swingSpeed = 2 + Math.random(); // Random swing speed
                    break;
                case 'movingwall':
                    obstacleData.movementRange = 3; // Movement range across lanes
                    obstacleData.movementSpeed = 1.5 + Math.random() * 0.5;
                    break;
                case 'bouncingball':
                    obstacleData.bounceHeight = 2.5; // Max bounce height
                    obstacleData.bounceSpeed = 3 + Math.random() * 1.5; // Bounce frequency
                    break;
                case 'spinninglaser':
                    obstacleData.rotationSpeed = 2 + Math.random() * 1.5; // Laser spin speed
                    obstacleData.pulseSpeed = 4; // Warning light pulse
                    break;
            }
            
            obstacles.push(obstacleData);
        }

        function startGameInternal() {
            // Resume audio context
            audioManager.resume();
            
            // Start background music
            audioManager.startBackgroundMusic();
            
            // Start ambient city sounds
            if (!ambientStarted) {
                audioManager.play('ambient');
                ambientStarted = true;
            }
            
            gameState.isPlaying = true;
            gameState.isGameOver = false;
            gameState.isVictory = false;
            gameState.score = 0;
            gameState.speed = gameState.baseSpeed;
            gameState.lives = 3;
            gameState.timeRemaining = gameState.gameTime;
            gameState.gameStartTime = Date.now();
            gameState.playerLane = 1;
            gameState.playerAction = 'running';
            gameState.playerY = 0;
            gameState.jumpVelocity = 0;
            gameState.invulnerable = false;
            gameState.invulnerabilityTime = 0;
            gameState.timeScale = 1.0;
            gameState.cameraShakeIntensity = 0;
            gameState.slowMotionActive = false;
            
            // BUGFIX: Reset milestone tracking to prevent constant confetti
            gameState.lastMilestone = 0;
            gameState.milestoneReached = 0;
            gameState.totalDistance = 0;
            
            // BUGFIX: Initialize centralized score system
            gameState.lastScoreUpdate = performance.now();
            gameState.scoreQueue = 0;
            gameState.lastDistanceScore = performance.now();
            
            // Reset all multipliers and combos
            gameState.comboMultiplier = 1;
            gameState.nearMissMultiplier = 1;
            gameState.skillMultiplier = 1;
            gameState.scoreMultiplier = 1;
            gameState.nearMissStreak = 0;
            gameState.kiwiCombo = 0;
            
            // Reset collectible system
            gameState.collectedKiwis = 0;
            gameState.collectedBroccolis = 0;
            gameState.totalCollectibles = 0;
            gameState.collectionBonusAwarded = false;
            
            // Clear obstacles and collectibles
            obstacles.forEach(obs => scene.remove(obs.mesh));
            obstacles = [];
            
            // Clear existing collectibles
            gameState.kiwis.forEach(kiwi => scene.remove(kiwi.mesh));
            gameState.kiwis = [];
            gameState.broccolis.forEach(broccoli => scene.remove(broccoli.mesh));
            gameState.broccolis = [];
            
            // Start sound
            audioManager.play('powerup');
            
            document.getElementById('menu').style.display = 'none';
            updateUI();
        }

        function endGame() {
            gameState.isPlaying = false;
            gameState.isGameOver = true;
            
            // Stop background music and ambient sounds
            audioManager.stopBackgroundMusic();
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = Math.max(0, gameState.gameTime - Math.ceil(gameState.timeRemaining));
            
            // Check for highscore
            console.log('Game ended. Checking highscore:', currentScore, 'isHighscore:', highscoreManager.isHighscore(currentScore));
            if (highscoreManager.isHighscore(currentScore)) {
                console.log('New highscore achieved! Showing name input dialog.');
                showNameInputDialog(false);
            } else {
                showGameOverMenu(false);
            }
        }

        function victoryGame() {
            gameState.isPlaying = false;
            gameState.isVictory = true;
            
            // Stop ambient sounds
            audioManager.stopAmbient();
            ambientStarted = false;
            
            currentScore = gameState.score;
            currentSurvivalTime = 60; // Full 60 seconds survived!
            
            // Victory celebration!
            audioManager.play('powerup');
            
            // Fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createParticleEffect(
                        new THREE.Vector3((Math.random() - 0.5) * 10, 5, -5),
                        [0xFF6B35, 0x4ECDC4, 0x45B7D1, 0x96CEB4, 0xFEDE57][i],
                        'success'
                    );
                }, i * 300);
            }
            
            // Always show name input for victory (it's always a highscore achievement!)
            showNameInputDialog(true);
        }

        function updateUI() {
            // Animate score changes
            const scoreElement = document.getElementById('score');
            const currentDisplayScore = parseInt(scoreElement.textContent) || 0;
            const targetScore = Math.floor(gameState.score);
            
            if (targetScore > currentDisplayScore) {
                scoreElement.classList.add('ui-bounce');
                setTimeout(() => scoreElement.classList.remove('ui-bounce'), 500);
            }
            scoreElement.textContent = targetScore;
            
            // Speed display with color coding
            const speedElement = document.getElementById('speed');
            speedElement.textContent = Math.floor(gameState.speed * 1000);
            const speedRatio = gameState.speed / gameState.maxSpeed;
            if (speedRatio > 0.8) {
                speedElement.style.color = '#FF4444';
            } else if (speedRatio > 0.6) {
                speedElement.style.color = '#FFA500';
            } else if (speedRatio > 0.4) {
                speedElement.style.color = '#FFD700';
            } else {
                speedElement.style.color = 'white';
            }
            
            // Lives with pulse animation on change
            const livesElement = document.getElementById('lives');
            const currentLives = parseInt(livesElement.textContent) || 3;
            if (gameState.lives < currentLives) {
                livesElement.classList.add('ui-bounce');
                livesElement.style.color = '#FF4444';
                setTimeout(() => {
                    livesElement.classList.remove('ui-bounce');
                    livesElement.style.color = 'white';
                }, 1000);
            }
            livesElement.textContent = gameState.lives;
            
            // Update timer with visual warnings
            const timeElement = document.getElementById('timeRemaining');
            const timerElement = document.getElementById('timer');
            timeElement.textContent = Math.max(0, Math.ceil(gameState.timeRemaining));
            
            // Timer visual states with audio warnings
            const timeLeft = Math.ceil(gameState.timeRemaining);
            if (timeLeft <= 10) {
                timerElement.className = 'timer-critical';
                // Final countdown beeps
                if (timeLeft <= 5 && timeLeft > 0 && Math.ceil(gameState.timeRemaining) !== Math.ceil(gameState.timeRemaining + 0.016)) {
                    audioManager.play('coin'); // High pitched beep
                }
            } else if (timeLeft <= 20) {
                timerElement.className = 'timer-warning';
                // Warning at 20 seconds
                if (timeLeft === 20 && Math.abs(gameState.timeRemaining - 20) < 0.1) {
                    audioManager.play('duck'); // Warning sound
                }
            } else {
                timerElement.className = '';
            }
            
            // Update multiplier display with glow effect
            const multiplierElement = document.getElementById('currentMultiplier');
            if (multiplierElement) {
                const newMultiplier = gameState.scoreMultiplier.toFixed(1);
                if (parseFloat(newMultiplier) > 1.0) {
                    multiplierElement.parentElement.classList.add('ui-glow');
                } else {
                    multiplierElement.parentElement.classList.remove('ui-glow');
                }
                multiplierElement.textContent = newMultiplier;
            }
            
            // Update difficulty progress display
            updateDifficultyUI();
        }

        function showNameInputDialog(isVictory) {
            const dialog = document.getElementById('nameInputDialog');
            const title = dialog.querySelector('h2');
            
            if (isVictory) {
                title.innerHTML = '🎉 VICTORY + HIGHSCORE! 🎉';
            } else {
                title.innerHTML = '🎉 Neuer Highscore! 🎉';
            }
            
            dialog.style.display = 'block';
            document.getElementById('playerNameInput').focus();
        }

        function showGameOverMenu(isVictory) {
            const menu = document.getElementById('menu');
            
            if (isVictory) {
                menu.innerHTML = `
                    <h1>🎉 VICTORY! 🎉</h1>
                    <h2>Du hast 60 Sekunden überlebt!</h2>
                    <p>Final Score: ${currentScore}</p>
                    <p>Du bist ein Subway Runner Champion! 🏆</p>
                    <button onclick="startGame()">🎮 Nochmal versuchen</button>
                `;
            } else {
                menu.innerHTML = `
                    <h1>Game Over!</h1>
                    <p>Final Score: ${currentScore}</p>
                    <p>Zeit überlebt: ${currentSurvivalTime}s</p>
                    <button onclick="startGame()">🎮 Nochmal spielen</button>
                `;
            }
            
            menu.style.display = 'block';
        }

        async function submitHighscoreInternal() {
            const nameInput = document.getElementById('playerNameInput');
            let playerName = nameInput.value.trim();
            
            if (!playerName) {
                playerName = 'Anonymous';
            }
            
            // Disable button while submitting
            const submitBtn = document.querySelector('#nameInputDialog button');
            submitBtn.disabled = true;
            submitBtn.textContent = '💾 Speichere...';
            
            try {
                await highscoreManager.submitScore(
                    playerName, 
                    currentScore, 
                    currentSurvivalTime, 
                    gameState.isVictory
                );
                
                // Hide dialog and show game over menu
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
                
                // Clear input for next time
                nameInput.value = '';
                
            } catch (error) {
                console.error('Error submitting highscore:', error);
                // Still hide dialog and continue
                document.getElementById('nameInputDialog').style.display = 'none';
                showGameOverMenu(gameState.isVictory);
            }
            
            // Re-enable button
            submitBtn.disabled = false;
            submitBtn.textContent = '💾 Speichern';
        }

        function skipHighscoreInternal() {
            document.getElementById('nameInputDialog').style.display = 'none';
            showGameOverMenu(gameState.isVictory);
            document.getElementById('playerNameInput').value = '';
        }

        // Handle Enter key in name input
        document.addEventListener('DOMContentLoaded', () => {
            const nameInput = document.getElementById('playerNameInput');
            nameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    submitHighscoreInternal();
                }
            });
        });

        function handleKeyDown(event) {
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowLeft':
                case 'KeyA':
                    event.preventDefault();
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        
                        // Track lane movement for skill combos
                        trackPlayerMove('left', gameState.playerLane);
                    }
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    event.preventDefault();
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        
                        // Track lane movement for skill combos
                        trackPlayerMove('right', gameState.playerLane);
                    }
                    break;
                case 'ArrowUp':
                case 'KeyW':
                case 'Space':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time // Höherer Sprung
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        
                        // Audio & Visual Feedback with speed dynamics
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                        audioManager.resume(); // Resume audio context if needed
                        
                        // Sprung-Partikel
                        createParticleEffect(
                            new THREE.Vector3(player.position.x, 0.1, player.position.z),
                            0xFFFF00,
                            'jump'
                        );
                        
                        // Track jump for skill combos
                        trackPlayerMove('jumping');
                    }
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                        
                        // Track duck for skill combos
                        trackPlayerMove('ducking');
                    }
                    break;
            }
        }

        function handleKeyUp(event) {
            if (!gameState.isPlaying) return;
            
            switch (event.code) {
                case 'ArrowDown':
                case 'KeyS':
                    event.preventDefault();
                    gameState.playerAction = 'running';
                    break;
            }
        }

        function createParticleEffect(position, color, type) {
            let particleCount, spreadRange, speed, size;
            
            switch (type) {
                case 'success':
                    particleCount = 25;
                    spreadRange = 3;
                    speed = 4;
                    size = 0.06;
                    break;
                case 'explosion':
                    particleCount = 40;
                    spreadRange = 5;
                    speed = 6;
                    size = 0.08;
                    break;
                case 'jump':
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.04;
                    break;
                case 'landing':
                    particleCount = 20;
                    spreadRange = 3;
                    speed = 2;
                    size = 0.05;
                    break;
                case 'nearMiss':
                    particleCount = 10;
                    spreadRange = 1.5;
                    speed = 2;
                    size = 0.03;
                    break;
                case 'collision':
                    particleCount = 30;
                    spreadRange = 4;
                    speed = 5;
                    size = 0.06;
                    break;
                case 'spark':
                    particleCount = 8;
                    spreadRange = 1;
                    speed = 6;
                    size = 0.02;
                    break;
                case 'dust':
                    particleCount = 12;
                    spreadRange = 2.5;
                    speed = 1;
                    size = 0.04;
                    break;
                default:
                    particleCount = 15;
                    spreadRange = 2;
                    speed = 3;
                    size = 0.05;
            }
            
            const particles = new THREE.Group();
            
            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(size, 6, 6),
                    new THREE.MeshBasicMaterial({ 
                        color: color,
                        transparent: true
                    })
                );
                
                particle.position.copy(position);
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * spreadRange,
                    Math.random() * speed + 0.5,
                    (Math.random() - 0.5) * spreadRange
                );
                particle.life = 1.0;
                particle.originalSize = size;
                particles.add(particle);
            }
            
            scene.add(particles);
            
            // Enhanced particle animation
            const animateParticles = () => {
                particles.children.forEach((particle, index) => {
                    particle.position.add(particle.velocity.clone().multiplyScalar(gameState.timeScale));
                    particle.velocity.y -= 0.15 * gameState.timeScale; // Gravity
                    particle.life -= 0.015 * gameState.timeScale;
                    
                    // Fancy effects based on type
                    if (type === 'explosion') {
                        particle.material.opacity = particle.life * 0.8;
                        particle.scale.setScalar(1 + (1 - particle.life) * 2);
                        particle.rotation.x += 0.1 * gameState.timeScale;
                        particle.rotation.y += 0.1 * gameState.timeScale;
                    } else if (type === 'success') {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(1 + Math.sin(Date.now() * 0.01 + index) * 0.3);
                    } else {
                        particle.material.opacity = particle.life;
                        particle.scale.setScalar(particle.life);
                    }
                    
                    if (particle.life <= 0) {
                        particles.remove(particle);
                    }
                });
                
                if (particles.children.length > 0) {
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            animateParticles();
        }

        function startSlowMotion(duration = 800) {
            gameState.slowMotionActive = true;
            gameState.timeScale = 0.3;
            
            // Camera zoom effect
            const originalFov = camera.fov;
            camera.fov = originalFov * 0.8;
            camera.updateProjectionMatrix();
            
            setTimeout(() => {
                gameState.slowMotionActive = false;
                gameState.timeScale = 1.0;
                camera.fov = originalFov;
                camera.updateProjectionMatrix();
            }, duration);
        }

        function screenShake(intensity = 0.1, duration = 300) {
            gameState.cameraShakeIntensity = intensity;
            
            setTimeout(() => {
                gameState.cameraShakeIntensity = 0;
            }, duration);
        }

        function cameraZoomEffect(targetZoom = 1.2, duration = 500) {
            const originalFov = camera.fov;
            const targetFov = originalFov / targetZoom;
            
            const startTime = Date.now();
            const zoomAnimation = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                if (progress < 0.5) {
                    // Zoom in
                    const zoomProgress = progress * 2;
                    camera.fov = originalFov - (originalFov - targetFov) * zoomProgress;
                } else {
                    // Zoom out
                    const zoomProgress = (progress - 0.5) * 2;
                    camera.fov = targetFov + (originalFov - targetFov) * zoomProgress;
                }
                
                camera.updateProjectionMatrix();
                
                if (progress < 1) {
                    requestAnimationFrame(zoomAnimation);
                }
            };
            zoomAnimation();
        }

        function createExplosionRing(position, color = 0xFF6644) {
            const ringGeometry = new THREE.RingGeometry(0.1, 0.2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: color, 
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            
            ring.position.copy(position);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);
            
            // Animate ring expansion
            const animateRing = () => {
                ring.scale.x += 0.3;
                ring.scale.y += 0.3;
                ring.material.opacity -= 0.02;
                
                if (ring.material.opacity > 0) {
                    requestAnimationFrame(animateRing);
                } else {
                    scene.remove(ring);
                }
            };
            animateRing();
        }

        // Enhanced collision detection with precise bounding boxes and near-miss system
        function checkCollisions() {
            if (gameState.invulnerable) return;
            
            // Player bounding box calculation
            const playerBBox = calculatePlayerBoundingBox();
            
            obstacles.forEach((obstacle, index) => {
                // Calculate obstacle bounding box
                const obstacleBBox = calculateObstacleBoundingBox(obstacle);
                
                // Check for actual collision using 3D bounding box intersection
                const isColliding = boundingBoxIntersection(playerBBox, obstacleBBox);
                
                // ENHANCED DUCK COLLISION DETECTION
                if (obstacle.type === 'duckbeam' || obstacle.type === 'highbarrier' || obstacle.type === 'wallgap') {
                    console.log(`🔍 DUCK OBSTACLE CHECK:
                        Type: ${obstacle.type}
                        Action: ${gameState.playerAction}
                        Player Y: ${gameState.playerY}
                        Player BBox: min(${playerBBox.min.x.toFixed(2)}, ${playerBBox.min.y.toFixed(2)}, ${playerBBox.min.z.toFixed(2)}) max(${playerBBox.max.x.toFixed(2)}, ${playerBBox.max.y.toFixed(2)}, ${playerBBox.max.z.toFixed(2)})
                        Obstacle BBox: min(${obstacleBBox.min.x.toFixed(2)}, ${obstacleBBox.min.y.toFixed(2)}, ${obstacleBBox.min.z.toFixed(2)}) max(${obstacleBBox.max.x.toFixed(2)}, ${obstacleBBox.max.y.toFixed(2)}, ${obstacleBBox.max.z.toFixed(2)})
                        isColliding: ${isColliding}`);
                    
                    // FORCE collision detection for duck obstacles using simplified logic
                    const playerX = LANE_POSITIONS[gameState.playerLane];
                    const obstacleX = obstacle.mesh.position.x;
                    const obstacleZ = obstacle.mesh.position.z;
                    
                    // Check if player is in same lane (X axis)
                    const inSameLane = Math.abs(playerX - obstacleX) < 1.0;
                    
                    // Check if obstacle is close enough in Z direction (approaching or passing)
                    const inCollisionZone = obstacleZ > -2 && obstacleZ < 2;
                    
                    // Check if player is too high (not ducking properly)
                    // BUGFIX: Reduced duck height from 0.6 to 0.4 for better collision avoidance
                    const playerHeight = gameState.playerAction === 'ducking' ? 0.4 : 1.5;
                    let obstacleHeight = 1.8; // Default duck obstacles height
                    
                    // Adjust for wallgap (gap bottom is at 1.3)
                    // FIXED: For wallgap, the obstacleHeight should be the bottom of the gap (1.3), not the gap size
                    // Player must be below this height to pass through
                    if (obstacle.type === 'wallgap') {
                        obstacleHeight = 1.3;
                    }
                    
                    // FIXED: Player needs to duck if their height exceeds the obstacle clearance height
                    const needsToDuck = playerHeight > obstacleHeight; // Must duck to fit under obstacle
                    
                    console.log(`🎯 Duck Logic: type=${obstacle.type}, inSameLane=${inSameLane}, inCollisionZone=${inCollisionZone}, needsToDuck=${needsToDuck}, playerHeight=${playerHeight}, obstacleHeight=${obstacleHeight}`);
                    
                    if (inSameLane && inCollisionZone && needsToDuck) {
                        console.log(`💥 DUCK COLLISION TRIGGERED! Player failed to duck.`);
                        handleCollision(obstacle, obstacleBBox);
                        return; // Exit after collision
                    } else if (inSameLane && inCollisionZone && !needsToDuck) {
                        console.log(`✅ DUCK SUCCESS! Player ducked properly.`);
                        // Give bonus points for successful ducking (handled in avoidance logic)
                    }
                }
                
                // Near-miss detection (close but not colliding)
                const nearMissDistance = 0.3; // Units for near-miss threshold
                const isNearMiss = !isColliding && boundingBoxDistance(playerBBox, obstacleBBox) < nearMissDistance;
                
                if (isColliding) {
                    // Check if player can avoid this collision
                    let canAvoid = false;
                    let avoidanceType = '';
                    
                    // Enhanced avoidance logic with precise hitbox checking
                    switch (obstacle.type) {
                        case 'lowbarrier':
                        case 'jumpblock':
                        case 'hurdleset':
                            // Must be jumped - check if player is high enough to clear
                            if (gameState.playerAction === 'jumping' && 
                                playerBBox.min.y > obstacleBBox.max.y - 0.2) {
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'highbarrier':
                        case 'duckbeam':
                        case 'wallgap':
                            // CRITICAL FIX: Overhead obstacles require ducking to avoid collision
                            // Player can ONLY avoid collision if they are ducking AND low enough
                            if (gameState.playerAction === 'ducking' && 
                                playerBBox.max.y < obstacleBBox.min.y + 0.2) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else {
                                // FORCE collision if not ducking or not low enough
                                canAvoid = false;
                                console.log(`🚨 OVERHEAD COLLISION: Player must duck! action=${gameState.playerAction}, playerMaxY=${playerBBox.max.y}, obstacleMinY=${obstacleBBox.min.y}`);
                            }
                            console.log(`🎯 Overhead obstacle: action=${gameState.playerAction}, playerMaxY=${playerBBox.max.y}, obstacleMinY=${obstacleBBox.min.y}, canAvoid=${canAvoid}`);
                            break;
                            
                        case 'spikes':
                            // Flexible - can jump over or duck under
                            if ((gameState.playerAction === 'jumping' && playerBBox.min.y > obstacleBBox.max.y - 0.2) ||
                                (gameState.playerAction === 'ducking' && playerBBox.max.y < obstacleBBox.min.y + 0.2)) {
                                canAvoid = true;
                                avoidanceType = gameState.playerAction === 'jumping' ? 'jump' : 'duck';
                            }
                            break;
                            
                        case 'rotatingblade':
                            // Rotating blades - can only be ducked under
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 0.8) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'swinginghammer':
                            // Swinging hammer - timing-based avoidance
                            // Check if hammer is in safe position
                            const hammerAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                            const isSafePosition = Math.abs(hammerAngle) < obstacle.swingAmplitude * 0.3; // Safe zone
                            
                            if (isSafePosition) {
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && Math.abs(hammerAngle) > obstacle.swingAmplitude * 0.7) {
                                // Can duck under when hammer is at extreme positions
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                            
                        case 'movingwall':
                            // Moving wall - must time movement or jump
                            const wallPosition = obstacle.mesh.position.x;
                            const playerPosition = LANE_POSITIONS[gameState.playerLane];
                            const wallDistance = Math.abs(wallPosition - playerPosition);
                            
                            if (wallDistance > 1.0) {
                                // Wall is far enough away
                                canAvoid = true;
                                avoidanceType = 'dodge';
                            } else if (gameState.playerAction === 'jumping' && playerBBox.min.y > 1.5) {
                                // Can jump over the wall
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'bouncingball':
                            // Bouncing ball - timing-based avoidance or ducking
                            const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                            
                            if (ballHeight < 0.8) {
                                // Ball is low - can run through
                                canAvoid = true;
                                avoidanceType = 'timing';
                            } else if (gameState.playerAction === 'ducking' && ballHeight > 1.5) {
                                // Ball is high, player is ducking
                                canAvoid = true;
                                avoidanceType = 'duck';
                            } else if (gameState.playerAction === 'jumping' && ballHeight < 1.2 && playerBBox.min.y > ballHeight + 0.3) {
                                // Ball is medium height, player jumps over
                                canAvoid = true;
                                avoidanceType = 'jump';
                            }
                            break;
                            
                        case 'spinninglaser':
                            // Spinning laser - only ducking helps
                            if (gameState.playerAction === 'ducking' && playerBBox.max.y < 1.1) {
                                canAvoid = true;
                                avoidanceType = 'duck';
                            }
                            break;
                    }
                    
                    if (canAvoid) {
                        // SUCCESSFUL AVOIDANCE! - ENHANCED SKILL SYSTEM
                        let bonusScore = 50;
                        
                        // Precision bonus - closer calls get more points
                        const precision = 1 - (boundingBoxDistance(playerBBox, obstacleBBox) / nearMissDistance);
                        bonusScore += Math.floor(precision * 25);
                        
                        if (avoidanceType === 'jump') bonusScore += 25; // Jump bonus
                        
                        // ==================== ADVANCED SKILL TRACKING ====================
                        
                        const currentTime = performance.now();
                        
                        // Track consecutive avoidances for combo system
                        if (currentTime - gameState.lastAvoidanceTime < 3000) { // 3 second window
                            gameState.consecutiveAvoidances++;
                        } else {
                            gameState.consecutiveAvoidances = 1;
                        }
                        gameState.lastAvoidanceTime = currentTime;
                        
                        // Record this move in sequence for combo detection
                        const currentMove = `${avoidanceType}_${gameState.playerLane}`;
                        gameState.moveSequence.push({
                            move: currentMove,
                            action: avoidanceType,
                            lane: gameState.playerLane,
                            time: currentTime,
                            precision: precision
                        });
                        
                        // Keep only last 5 moves for combo detection
                        if (gameState.moveSequence.length > 5) {
                            gameState.moveSequence.shift();
                        }
                        
                        // ==================== COMBO DETECTION & REWARDS ====================
                        
                        let skillBonus = 0;
                        let comboMessage = '';
                        
                        // RAPID SEQUENCE BONUS (quick consecutive moves)
                        if (gameState.consecutiveAvoidances >= 2) {
                            const timeSinceLastMove = currentTime - gameState.lastSkillTime;
                            if (timeSinceLastMove < 1500) { // Less than 1.5 seconds = rapid!
                                skillBonus += gameState.consecutiveAvoidances * 30;
                                comboMessage = `RAPID x${gameState.consecutiveAvoidances}!`;
                                
                                // Extra bonus for very fast sequences
                                if (timeSinceLastMove < 800) {
                                    skillBonus += 50;
                                    comboMessage = `LIGHTNING FAST x${gameState.consecutiveAvoidances}!`;
                                }
                            }
                        }
                        
                        // LANE SWITCHING COMBO (left-right-left sequences)
                        if (gameState.moveSequence.length >= 3) {
                            const lastThree = gameState.moveSequence.slice(-3);
                            const lanes = lastThree.map(m => m.lane);
                            const actions = lastThree.map(m => m.action);
                            
                            // Check for lane switching patterns
                            if (lanes[0] !== lanes[1] && lanes[1] !== lanes[2] && lanes[0] !== lanes[2]) {
                                // Perfect zigzag pattern!
                                skillBonus += 100;
                                comboMessage = 'ZIGZAG MASTER!';
                                
                                // Check if it includes different actions (jump + duck + lane switch)
                                const uniqueActions = [...new Set(actions)];
                                if (uniqueActions.length >= 2) {
                                    skillBonus += 75;
                                    comboMessage = 'MIXED STYLE COMBO!';
                                }
                            }
                        }
                        
                        // PERFECT TIMING BONUS (high precision sequences)
                        if (precision > 0.85) {
                            gameState.perfectTimingCount++;
                            if (gameState.perfectTimingCount >= 3) {
                                skillBonus += 150;
                                comboMessage = 'PERFECT TIMING STREAK!';
                                gameState.perfectTimingCount = 0; // Reset for next streak
                            }
                        } else {
                            gameState.perfectTimingCount = 0; // Reset on imperfect timing
                        }
                        
                        // HIGH DIFFICULTY OBSTACLE BONUS
                        const difficultyBonus = {
                            'rotatingblade': 40,
                            'swinginghammer': 50,
                            'movingwall': 45,
                            'bouncingball': 35,
                            'spinninglaser': 60
                        };
                        
                        if (difficultyBonus[obstacle.type]) {
                            skillBonus += difficultyBonus[obstacle.type];
                            if (!comboMessage) comboMessage = 'SKILL MOVE!';
                        }
                        
                        // SPEED-BASED DIFFICULTY MULTIPLIER
                        const speedRatio = gameState.speed / gameState.maxSpeed;
                        if (speedRatio > 0.7) { // High speed bonus
                            const speedMultiplier = 1 + speedRatio;
                            skillBonus = Math.floor(skillBonus * speedMultiplier);
                            bonusScore = Math.floor(bonusScore * speedMultiplier);
                            if (comboMessage) comboMessage += ' @HIGH SPEED!';
                        }
                        
                        // Apply skill combo multiplier
                        if (gameState.consecutiveAvoidances >= 3) {
                            gameState.skillMultiplier = Math.min(3, 1 + (gameState.consecutiveAvoidances - 2) * 0.5);
                            skillBonus = Math.floor(skillBonus * gameState.skillMultiplier);
                        }
                        
                        gameState.lastSkillTime = currentTime;
                        
                        // ==================== APPLY REWARDS ====================
                        
                        const totalBonus = bonusScore + skillBonus;
                        addScore(totalBonus, 'avoidance_bonus');
                        
                        // Show skill combo UI if we got a bonus
                        if (skillBonus > 0) {
                            showSkillCombo(skillBonus, comboMessage);
                        }
                        
                        // Enhanced audio feedback with precision
                        if (precision > 0.8) {
                            audioManager.play('success'); // Perfect avoidance
                        } else {
                            audioManager.playSpeedDependentSound('coin', gameState.speed / gameState.maxSpeed);
                        }
                        
                        // Spectacular success particle effects
                        const effectPos = obstacle.mesh.position.clone();
                        const effectColor = avoidanceType === 'jump' ? 0x00FF00 : 0x00FFFF;
                        
                        createParticleEffect(effectPos, effectColor, 'success');
                        
                        // Precision-based additional effects
                        if (precision > 0.8) {
                            // Perfect execution - extra sparkles
                            createParticleEffect(
                                effectPos.clone().add(new THREE.Vector3(0, 1, 0)),
                                0xFFD700,
                                'success'
                            );
                            // Mini camera zoom for perfect execution
                            cameraZoomEffect(1.1, 200);
                        }
                        
                        // Score popup with precision indicator
                        showScorePopup(bonusScore, effectPos, precision > 0.8 ? 'PERFECT!' : 'NICE!');
                        
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        
                    } else {
                        // COLLISION DETECTED!
                        handleCollision(obstacle, obstacleBBox);
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                    }
                    
                } else if (isNearMiss && obstacle.z > -1 && obstacle.z < 1) {
                    // NEAR MISS BONUS! (only when very close)
                    handleNearMiss(obstacle, playerBBox, obstacleBBox);
                }
            });
            
            // ==================== POWER-UP COLLISION DETECTION ====================
            
            gameState.powerUps.forEach((powerUp, index) => {
                const powerUpBBox = {
                    min: {
                        x: powerUp.mesh.position.x - 0.4,
                        y: powerUp.mesh.position.y - 0.4,
                        z: powerUp.mesh.position.z - 0.4
                    },
                    max: {
                        x: powerUp.mesh.position.x + 0.4,
                        y: powerUp.mesh.position.y + 0.4,
                        z: powerUp.mesh.position.z + 0.4
                    }
                };
                
                const isCollecting = boundingBoxIntersection(playerBBox, powerUpBBox);
                
                if (isCollecting && !powerUp.collected) {
                    powerUp.collected = true;
                    scene.remove(powerUp.mesh);
                    gameState.powerUps.splice(index, 1);
                    
                    // Activate the power-up
                    activatePowerUp(powerUp.type);
                }
            });
            
            // ==================== KIWI COLLISION DETECTION ====================
            
            gameState.kiwis.forEach((kiwi, index) => {
                const kiwiBBox = {
                    min: {
                        x: kiwi.mesh.position.x - 0.35,
                        y: kiwi.mesh.position.y - 0.35,
                        z: kiwi.mesh.position.z - 0.35
                    },
                    max: {
                        x: kiwi.mesh.position.x + 0.35,
                        y: kiwi.mesh.position.y + 0.35,
                        z: kiwi.mesh.position.z + 0.35
                    }
                };
                
                // Magnet Power-Up Effect
                if (gameState.magnetActive) {
                    const magnetRange = 2.5; // Magnet attraction range
                    const distance = Math.sqrt(
                        Math.pow(kiwi.mesh.position.x - player.position.x, 2) +
                        Math.pow(kiwi.mesh.position.y - player.position.y, 2) +
                        Math.pow(kiwi.mesh.position.z - player.position.z, 2)
                    );
                    
                    if (distance < magnetRange && !kiwi.collected) {
                        // Attract kiwi towards player
                        const attractionSpeed = 0.15;
                        const direction = new THREE.Vector3()
                            .subVectors(player.position, kiwi.mesh.position)
                            .normalize()
                            .multiplyScalar(attractionSpeed);
                        
                        kiwi.mesh.position.add(direction);
                        
                        // Visual effect for magnet attraction
                        if (Math.random() > 0.8) {
                            createParticleEffect(
                                kiwi.mesh.position.clone(),
                                0x00FFFF,
                                'magnet'
                            );
                        }
                    }
                }
                
                const isCollecting = boundingBoxIntersection(playerBBox, kiwiBBox);
                
                if (isCollecting && !kiwi.collected) {
                    collectKiwi(kiwi);
                    gameState.kiwis.splice(index, 1);
                }
            });
            
            // ==================== BROCCOLI COLLISION DETECTION ====================
            
            gameState.broccolis.forEach((broccoli, index) => {
                const broccoliBBox = {
                    min: {
                        x: broccoli.mesh.position.x - 0.4,
                        y: broccoli.mesh.position.y - 0.4,
                        z: broccoli.mesh.position.z - 0.4
                    },
                    max: {
                        x: broccoli.mesh.position.x + 0.4,
                        y: broccoli.mesh.position.y + 0.4,
                        z: broccoli.mesh.position.z + 0.4
                    }
                };
                
                // Magnet Power-Up Effect (same as kiwis)
                if (gameState.magnetActive) {
                    const magnetRange = 2.5;
                    const distance = Math.sqrt(
                        Math.pow(broccoli.mesh.position.x - player.position.x, 2) +
                        Math.pow(broccoli.mesh.position.y - player.position.y, 2) +
                        Math.pow(broccoli.mesh.position.z - player.position.z, 2)
                    );
                    
                    if (distance < magnetRange && !broccoli.collected) {
                        const attractionSpeed = 0.15;
                        const direction = new THREE.Vector3()
                            .subVectors(player.position, broccoli.mesh.position)
                            .normalize()
                            .multiplyScalar(attractionSpeed);
                        
                        broccoli.mesh.position.add(direction);
                        broccoli.z = broccoli.mesh.position.z;
                    }
                }
                
                const isCollecting = boundingBoxIntersection(playerBBox, broccoliBBox);
                
                if (isCollecting && !broccoli.collected) {
                    collectBroccoli(broccoli);
                    gameState.broccolis.splice(index, 1);
                }
            });
        }
        
        // Calculate precise player bounding box based on current action
        function calculatePlayerBoundingBox() {
            const playerX = LANE_POSITIONS[gameState.playerLane];
            const playerY = gameState.playerY;
            
            let width = 0.8;  // Player width
            let height = 1.5; // Player height
            let depth = 0.6;  // Player depth
            
            // Adjust hitbox based on action
            if (gameState.playerAction === 'ducking') {
                height = 0.4; // Reduced from 0.6 to 0.4 for better obstacle clearance
                depth = 0.8; // Slightly larger depth when ducking
            } else if (gameState.playerAction === 'jumping') {
                // Tighter hitbox when jumping for more precise collision
                width = 0.7;
                depth = 0.5;
            }
            
            return {
                min: new THREE.Vector3(
                    playerX - width/2,
                    playerY,
                    -depth/2
                ),
                max: new THREE.Vector3(
                    playerX + width/2,
                    playerY + height,
                    depth/2
                )
            };
        }
        
        // Calculate obstacle bounding box based on type and mesh
        function calculateObstacleBoundingBox(obstacle) {
            const pos = obstacle.mesh.position;
            let width, height, depth;
            
            // Obstacle-specific bounding box dimensions
            switch (obstacle.type) {
                case 'lowbarrier':
                    width = 1.5; height = 0.8; depth = 0.3;
                    break;
                case 'highbarrier':
                    width = 1.8; height = 0.4; depth = 0.3;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.8, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.8 + height, pos.z + depth/2)
                    };
                case 'jumpblock':
                    width = 1.2; height = 1.2; depth = 1.2;
                    break;
                case 'spikes':
                    width = 0.5; height = 0.6; depth = 0.5;
                    break;
                case 'duckbeam':
                    width = 2.2; height = 0.3; depth = 0.8;
                    // Position is higher up
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.8, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.8 + height, pos.z + depth/2)
                    };
                case 'hurdleset':
                    width = 1.4; height = 0.7; depth = 1.5; // Covers multiple hurdles
                    break;
                case 'wallgap':
                    width = 1.8; height = 1.3; depth = 0.4;
                    // Gap height consideration
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.3, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 2.5, pos.z + depth/2)
                    };
                case 'rotatingblade':
                    // Dynamic hitbox based on rotation - always dangerous
                    width = 2.2; height = 2; depth = 0.4;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'swinginghammer':
                    // Dynamic hitbox for swinging hammer - wider danger zone
                    width = 2.5; height = 1.8; depth = 0.8;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'movingwall':
                    // Moving wall uses actual position
                    width = 0.4; height = 2; depth = 1;
                    break;
                case 'bouncingball':
                    // Dynamic hitbox based on ball position
                    const ballHeight = 0.6 + Math.abs(Math.sin(obstacle.animationTime * obstacle.bounceSpeed)) * obstacle.bounceHeight;
                    width = 1.2; height = ballHeight + 0.6; depth = 1.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 0, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, height, pos.z + depth/2)
                    };
                case 'spinninglaser':
                    // Laser beam danger zone - wider when spinning
                    width = 3.2; height = 1.4; depth = 3.2;
                    return {
                        min: new THREE.Vector3(pos.x - width/2, 1.1, pos.z - depth/2),
                        max: new THREE.Vector3(pos.x + width/2, 1.3, pos.z + depth/2)
                    };
                default:
                    width = 1.0; height = 1.0; depth = 1.0;
            }
            
            return {
                min: new THREE.Vector3(
                    pos.x - width/2,
                    pos.y,
                    pos.z - depth/2
                ),
                max: new THREE.Vector3(
                    pos.x + width/2,
                    pos.y + height,
                    pos.z + depth/2
                )
            };
        }
        
        // Check if two 3D bounding boxes intersect
        function boundingBoxIntersection(bbox1, bbox2) {
            return (bbox1.min.x <= bbox2.max.x && bbox1.max.x >= bbox2.min.x) &&
                   (bbox1.min.y <= bbox2.max.y && bbox1.max.y >= bbox2.min.y) &&
                   (bbox1.min.z <= bbox2.max.z && bbox1.max.z >= bbox2.min.z);
        }
        
        // Calculate minimum distance between two bounding boxes
        function boundingBoxDistance(bbox1, bbox2) {
            const dx = Math.max(0, Math.max(bbox1.min.x - bbox2.max.x, bbox2.min.x - bbox1.max.x));
            const dy = Math.max(0, Math.max(bbox1.min.y - bbox2.max.y, bbox2.min.y - bbox1.max.y));
            const dz = Math.max(0, Math.max(bbox1.min.z - bbox2.max.z, bbox2.min.z - bbox1.max.z));
            
            return Math.sqrt(dx*dx + dy*dy + dz*dz);
        }
        
        // Enhanced collision handling with type-specific effects
        function handleCollision(obstacle, obstacleBBox) {
            // Check if shield is active
            if (gameState.shieldActive) {
                // Shield absorbs the hit!
                deactivatePowerUp(); // Remove shield after one hit
                
                // Shield absorption effects
                const shieldPos = player.position.clone();
                createParticleEffect(shieldPos, 0x00AAFF, 'shield');
                
                // Shield audio feedback
                audioManager.createTone(600, 0.2, 'square');
                audioManager.createTone(400, 0.3, 'square');
                
                // Mild screen flash for shield activation
                screenShake(0.1, 200);
                
                // Show protection message
                showScorePopup(0, shieldPos, 'PROTECTED!');
                
                console.log('Shield absorbed collision!');
                return; // Exit early - no damage taken
            }
            
            // Slow motion for dramatic effect
            startSlowMotion(1000);
            
            // Type-specific collision audio
            audioManager.play('collision');
            
            // Lose life
            loseLife();
            
            // Enhanced collision effects based on obstacle material
            const collisionPos = obstacle.mesh.position.clone();
            let effectColor = 0xFF4444;
            
            switch (obstacle.type) {
                case 'jumpblock':
                case 'wallgap':
                    effectColor = 0x888888; // Concrete dust
                    break;
                case 'duckbeam':
                    effectColor = 0x4682B4; // Metal sparks
                    break;
                case 'spikes':
                    effectColor = 0xFF4500; // Fire/sparks
                    break;
            }
            
            // Use new enhanced collision particle system
            createCollisionParticles(collisionPos, obstacle.type);
            
            // Additional dust clouds at ground level
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const dustPos = new THREE.Vector3(
                        player.position.x + (Math.random() - 0.5) * 2,
                        0.1,
                        player.position.z + (Math.random() - 0.5)
                    );
                    createParticleEffect(dustPos, 0x8B7355, 'dust');
                }, i * 100);
            }
            
            // Screen shake intensity based on obstacle size
            const shakeIntensity = Math.min(0.5, (obstacleBBox.max.y - obstacleBBox.min.y) * 0.3);
            screenShake(shakeIntensity, 600);
            
            // Camera zoom for impact
            cameraZoomEffect(1.25, 400);
        }
        
        // ==================== POWER-UP SYSTEM ====================
        
        function createPowerUp(type, lane, z) {
            const powerUpConfig = POWER_UP_TYPES[type];
            const powerUpGroup = new THREE.Group();
            
            // Main power-up body - rotating cube
            const powerUpGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const powerUpMaterial = new THREE.MeshLambertMaterial({ 
                color: powerUpConfig.color,
                emissive: powerUpConfig.color,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.9
            });
            const powerUpMesh = new THREE.Mesh(powerUpGeometry, powerUpMaterial);
            powerUpMesh.position.y = 1.5; // Floating height
            powerUpMesh.castShadow = true;
            powerUpGroup.add(powerUpMesh);
            
            // Glowing ring around power-up
            const ringGeometry = new THREE.RingGeometry(0.6, 0.8);
            const ringMaterial = new THREE.MeshLambertMaterial({ 
                color: powerUpConfig.color,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.1;
            powerUpGroup.add(ring);
            
            // Particle effect (simulated with small spheres)
            for (let i = 0; i < 8; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.05);
                const particleMaterial = new THREE.MeshLambertMaterial({ 
                    color: powerUpConfig.color,
                    emissive: powerUpConfig.color,
                    emissiveIntensity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                particle.position.set(
                    Math.cos(angle) * 1.2,
                    1.5 + Math.sin(i) * 0.3,
                    Math.sin(angle) * 1.2
                );
                powerUpGroup.add(particle);
            }
            
            powerUpGroup.position.set(LANE_POSITIONS[lane], 0, z);
            scene.add(powerUpGroup);
            
            // Store power-up data
            const powerUpData = {
                mesh: powerUpGroup,
                type: type,
                lane: lane,
                z: z,
                animationTime: 0,
                collected: false
            };
            
            powerUps.push(powerUpData);
            return powerUpData;
        }
        
        function createKiwi(lane, z, pattern = 'single') {
            const kiwiGroup = new THREE.Group();
            
            // Halbierte Kiwi Geometrie (flache Seite unten)
            const kiwiRadius = 0.35;
            const kiwiHeight = 0.35;
            
            // Haupt-Kiwi-Körper (Halbkugel)
            const kiwiGeometry = new THREE.SphereGeometry(kiwiRadius, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            
            // ENHANCED: Verbesserte Braune Außenhaut mit Glow-Effekt
            const skinMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xA0751A,  // Heller für bessere Sichtbarkeit
                emissive: 0x2A1F0A,  // Leichtes Glühen
                roughness: 0.6
            });
            const kiwiSkin = new THREE.Mesh(kiwiGeometry, skinMaterial);
            kiwiSkin.rotation.x = -Math.PI / 2;
            kiwiSkin.position.y = 1.2;
            kiwiSkin.castShadow = true;
            kiwiGroup.add(kiwiSkin);
            
            // Grünes Fruchtfleisch (flache Unterseite)
            const fleshGeometry = new THREE.CircleGeometry(kiwiRadius * 0.95, 32);
            const fleshMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8FBC8F,
                emissive: 0x2F5F2F,
                emissiveIntensity: 0.2
            });
            const kiwiFlesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
            kiwiFlesh.rotation.x = -Math.PI / 2;
            kiwiFlesh.position.y = 1.2;
            kiwiGroup.add(kiwiFlesh);
            
            // Weißer Kern in der Mitte
            const coreGeometry = new THREE.CircleGeometry(kiwiRadius * 0.3, 16);
            const coreMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xF5F5DC,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.1
            });
            const kiwiCore = new THREE.Mesh(coreGeometry, coreMaterial);
            kiwiCore.rotation.x = -Math.PI / 2;
            kiwiCore.position.y = 1.201;
            kiwiGroup.add(kiwiCore);
            
            // Schwarze Kerne/Samen
            const seedCount = 12;
            for (let i = 0; i < seedCount; i++) {
                const angle = (i / seedCount) * Math.PI * 2;
                const distance = kiwiRadius * 0.5 + Math.random() * kiwiRadius * 0.3;
                
                const seedGeometry = new THREE.CircleGeometry(0.02, 4);
                const seedMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x000000
                });
                const seed = new THREE.Mesh(seedGeometry, seedMaterial);
                seed.rotation.x = -Math.PI / 2;
                seed.position.set(
                    Math.cos(angle) * distance,
                    1.202,
                    Math.sin(angle) * distance
                );
                kiwiGroup.add(seed);
            }
            
            // Glanz-Effekt für Frische
            const glintGeometry = new THREE.CircleGeometry(0.08, 8);
            const glintMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xFFFFFF,
                emissive: 0xFFFFFF,
                emissiveIntensity: 0.6,
                transparent: true,
                opacity: 0.7
            });
            const glint = new THREE.Mesh(glintGeometry, glintMaterial);
            glint.rotation.x = -Math.PI / 2;
            glint.position.set(kiwiRadius * 0.4, 1.203, kiwiRadius * 0.3);
            kiwiGroup.add(glint);
            
            kiwiGroup.position.set(LANE_POSITIONS[lane], 0, z);
            scene.add(kiwiGroup);
            
            // Store kiwi data
            const kiwiData = {
                mesh: kiwiGroup,
                lane: lane,
                z: z,
                pattern: pattern,
                animationTime: 0,
                collected: false
            };
            
            kiwis.push(kiwiData);
            gameState.totalCollectibles++;  // Track total spawned collectibles
            return kiwiData;
        }
        
        // NEW: Brokkoli creation function for variety
        function createBroccoli(lane, z, pattern = 'single') {
            const broccoliGroup = new THREE.Group();
            
            // Brokkoli Geometrie - Baum-ähnliche Form
            const stemRadius = 0.15;
            const stemHeight = 0.4;
            const headRadius = 0.4;
            
            // Stiel (Stamm)
            const stemGeometry = new THREE.CylinderGeometry(stemRadius, stemRadius * 1.2, stemHeight, 8);
            const stemMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A6741,  // Dunkles Grün für Stiel
                emissive: 0x1A241A
            });
            const broccoliStem = new THREE.Mesh(stemGeometry, stemMaterial);
            broccoliStem.position.y = 1.0;
            broccoliStem.castShadow = true;
            broccoliGroup.add(broccoliStem);
            
            // Kopf (florettes) - mehrere kleine Kugeln
            for (let i = 0; i < 8; i++) {
                const floretGeometry = new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 8, 6);
                const floretMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x228B22,  // Helleres Grün für Florettes
                    emissive: 0x0F3F0F,  // Grünes Glühen
                    roughness: 0.7
                });
                const floret = new THREE.Mesh(floretGeometry, floretMaterial);
                
                // Zufällige Position um den Kopf
                const angle = (i / 8) * Math.PI * 2;
                const radius = 0.2 + Math.random() * 0.15;
                floret.position.set(
                    Math.cos(angle) * radius,
                    1.25 + Math.random() * 0.2,
                    Math.sin(angle) * radius
                );
                floret.castShadow = true;
                broccoliGroup.add(floret);
            }
            
            // Position and add to scene
            broccoliGroup.position.set(LANE_POSITIONS[lane], 0, z);
            broccoliGroup.userData = { type: 'broccoli', lane: lane };
            scene.add(broccoliGroup);
            
            // Brokkoli data object
            const broccoliData = {
                mesh: broccoliGroup,
                lane: lane,
                z: z,
                pattern: pattern,
                animationTime: 0,
                collected: false
            };
            
            broccolis.push(broccoliData);
            gameState.totalCollectibles++;
            return broccoliData;
        }
        
        function createKiwiPattern(type, baseZ) {
            switch (type) {
                case 'line':
                    // 3 kiwis in a horizontal line
                    for (let i = 0; i < 3; i++) {
                        createKiwi(i, baseZ, 'line');
                    }
                    break;
                case 'arc':
                    // 5 kiwis in a vertical arc
                    for (let i = 0; i < 5; i++) {
                        const lane = Math.floor(Math.random() * 3);
                        createKiwi(lane, baseZ - i * 2, 'arc');
                    }
                    break;
                case 'single':
                default:
                    // Single kiwi
                    const lane = Math.floor(Math.random() * 3);
                    createKiwi(lane, baseZ, 'single');
                    break;
            }
        }
        
        function activatePowerUp(type) {
            const config = POWER_UP_TYPES[type];
            
            // Deactivate any existing power-up
            if (gameState.activePowerUp) {
                deactivatePowerUp();
            }
            
            // Activate new power-up
            gameState.activePowerUp = type;
            gameState.powerUpTimeRemaining = config.duration;
            gameState[config.effect] = true;
            
            // Visual feedback
            createParticleEffect(
                player.position.clone(),
                config.color,
                'powerup'
            );
            
            // Audio feedback
            audioManager.play('powerup');
            
            // Screen flash effect
            screenShake(0.15, 200);
            
            // Update UI
            updatePowerUpUI();
            
            console.log(`Activated ${config.name} for ${config.duration/1000} seconds`);
        }
        
        function deactivatePowerUp() {
            if (!gameState.activePowerUp) return;
            
            const config = POWER_UP_TYPES[gameState.activePowerUp];
            gameState[config.effect] = false;
            gameState.activePowerUp = null;
            gameState.powerUpTimeRemaining = 0;
            
            // Update UI
            updatePowerUpUI();
            
            console.log(`Deactivated ${config.name}`);
        }
        
        function updatePowerUpUI() {
            const powerUpDisplay = document.getElementById('powerUpDisplay');
            const powerUpIcon = document.getElementById('powerUpIcon');
            const powerUpName = document.getElementById('powerUpName');
            const powerUpTime = document.getElementById('powerUpTime');
            
            if (gameState.activePowerUp) {
                const config = POWER_UP_TYPES[gameState.activePowerUp];
                powerUpDisplay.style.display = 'block';
                powerUpIcon.textContent = config.icon;
                powerUpName.textContent = config.name;
                powerUpTime.textContent = Math.ceil(gameState.powerUpTimeRemaining / 1000);
            } else {
                powerUpDisplay.style.display = 'none';
            }
        }
        
        function collectKiwi(kiwiData) {
            if (kiwiData.collected) return;
            
            kiwiData.collected = true;
            scene.remove(kiwiData.mesh);
            
            // Update kiwi count
            gameState.collectedKiwis++;
            gameState.totalKiwis++;
            
            // Handle combo system
            const currentTime = performance.now();
            if (currentTime - gameState.lastKiwiTime < 2000) { // 2 second combo window
                gameState.kiwiCombo++;
            } else {
                gameState.kiwiCombo = 1;
            }
            gameState.lastKiwiTime = currentTime;
            
            // Calculate score with combo multiplier
            const baseScore = 10;
            const comboBonus = gameState.kiwiCombo > 1 ? (gameState.kiwiCombo - 1) * 5 : 0;
            const totalScore = baseScore + comboBonus;
            
            addScore(totalScore, 'kiwi_collection');
            
            // Show combo UI
            updateComboUI();
            
            // Audio feedback with pitch variation (squish sound)
            const pitchVariation = 1 + (gameState.kiwiCombo * 0.1);
            audioManager.createTone(600 * pitchVariation, 0.15, 'sine');
            
            // Kiwi-Saft-Splash-Effekt
            createKiwiSplashEffect(kiwiData.mesh.position.clone());
            
            // Update UI
            updateKiwiUI();
            
            console.log(`Collected kiwi! Combo: ${gameState.kiwiCombo}, Score: +${totalScore}`);
        }
        
        // NEW: Brokkoli collection function
        function collectBroccoli(broccoliData) {
            if (broccoliData.collected) return;
            
            broccoliData.collected = true;
            scene.remove(broccoliData.mesh);
            
            // Update broccoli count
            gameState.collectedBroccolis++;
            gameState.totalBroccolis++;
            
            // Broccolis give slightly more points than kiwis (health food bonus!)
            const baseScore = 15;
            const totalScore = baseScore;
            
            addScore(totalScore, 'broccoli_collection');
            
            // Green healthy effects
            createBroccoliHealthEffect(broccoliData.mesh.position.clone());
            
            // Audio feedback with lower pitch (different from kiwi)
            audioManager.createTone(400, 0.2, 'sine');
            
            // Update UI
            updateCollectibleUI();
            
            console.log(`Collected broccoli! Health bonus: +${totalScore} points`);
        }
        
        // Kiwi-Saft-Splash-Effekt
        function createKiwiSplashEffect(position) {
            const splashParticles = [];
            const particleCount = 20;
            
            for (let i = 0; i < particleCount; i++) {
                // Safttropfen-Geometrie
                const dropSize = 0.05 + Math.random() * 0.1;
                const dropGeometry = new THREE.SphereGeometry(dropSize, 4, 4);
                
                // Grüne Farbe mit Variation
                const greenVariation = Math.random() * 0.3;
                const dropMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.5 + greenVariation, 0.8 + greenVariation * 0.5, 0.3),
                    transparent: true,
                    opacity: 0.8
                });
                
                const drop = new THREE.Mesh(dropGeometry, dropMaterial);
                drop.position.copy(position);
                
                // Zufällige Geschwindigkeit in alle Richtungen
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    Math.random() * 0.4 + 0.2,
                    (Math.random() - 0.5) * 0.3
                );
                
                scene.add(drop);
                splashParticles.push({ mesh: drop, velocity: velocity, life: 1.0 });
            }
            
            // Animate splash particles
            const animateSplash = () => {
                splashParticles.forEach((particle, index) => {
                    if (particle.life > 0) {
                        // Update position
                        particle.mesh.position.add(particle.velocity);
                        
                        // Apply gravity
                        particle.velocity.y -= 0.02;
                        
                        // Fade out
                        particle.life -= 0.05;
                        particle.mesh.material.opacity = particle.life * 0.8;
                        
                        // Scale down
                        const scale = particle.life;
                        particle.mesh.scale.set(scale, scale, scale);
                        
                        if (particle.life <= 0) {
                            scene.remove(particle.mesh);
                            splashParticles.splice(index, 1);
                        }
                    }
                });
                
                if (splashParticles.length > 0) {
                    requestAnimationFrame(animateSplash);
                }
            };
            
            animateSplash();
        }
        
        function updateComboUI() {
            const comboDisplay = document.getElementById('comboDisplay');
            const comboMultiplier = document.getElementById('comboMultiplier');
            
            if (gameState.kiwiCombo > 1) {
                comboDisplay.style.display = 'block';
                comboMultiplier.textContent = gameState.kiwiCombo;
                
                // Hide after 2 seconds
                setTimeout(() => {
                    comboDisplay.style.display = 'none';
                }, 2000);
            } else {
                comboDisplay.style.display = 'none';
            }
        }
        
        function updateKiwiUI() {
            const kiwiCount = document.getElementById('kiwiCount');
            kiwiCount.textContent = gameState.collectedKiwis;
        }
        
        function updateEnvironmentUI() {
            const environmentDisplay = document.getElementById('currentEnvironment');
            if (environmentDisplay) {
                switch (gameState.currentEnvironment) {
                    case 'street':
                        environmentDisplay.innerHTML = '🏙️ Straße';
                        break;
                    case 'tunnel_entrance':
                        environmentDisplay.innerHTML = '🚇 Tunnel Eingang';
                        break;
                    case 'tunnel':
                        environmentDisplay.innerHTML = '🚇 Tunnel';
                        break;
                    case 'tunnel_exit':
                        environmentDisplay.innerHTML = '🌅 Tunnel Ausgang';
                        break;
                    default:
                        environmentDisplay.innerHTML = '🏙️ Straße';
                }
            }
        }
        
        function updateDifficultyUI() {
            const difficultyLevel = document.getElementById('difficultyLevel');
            if (difficultyLevel) {
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime);
                
                if (gameProgress < 0.2) {
                    difficultyLevel.textContent = 'Leicht';
                    difficultyLevel.style.color = '#90EE90';
                } else if (gameProgress < 0.4) {
                    difficultyLevel.textContent = 'Mittel';
                    difficultyLevel.style.color = '#FFD700';
                } else if (gameProgress < 0.6) {
                    difficultyLevel.textContent = 'Schwer';
                    difficultyLevel.style.color = '#FFA500';
                } else if (gameProgress < 0.8) {
                    difficultyLevel.textContent = 'Extrem';
                    difficultyLevel.style.color = '#FF4500';
                } else {
                    difficultyLevel.textContent = 'Wahnsinn!';
                    difficultyLevel.style.color = '#FF0000';
                }
            }
        }
        
        // ==================== SKILL COMBO SYSTEM ====================
        
        function showSkillCombo(bonusPoints, comboMessage) {
            const skillComboDisplay = document.getElementById('skillComboDisplay');
            const skillComboCount = document.getElementById('skillComboCount');
            const skillComboBonus = document.getElementById('skillComboBonus');
            const skillComboIcon = document.getElementById('skillComboIcon');
            
            if (skillComboDisplay) {
                skillComboDisplay.style.display = 'block';
                skillComboCount.textContent = gameState.consecutiveAvoidances;
                skillComboBonus.textContent = `+${bonusPoints}`;
                
                // Dynamic icon based on combo type
                if (comboMessage.includes('ZIGZAG')) {
                    skillComboIcon.textContent = '⚡';
                } else if (comboMessage.includes('LIGHTNING')) {
                    skillComboIcon.textContent = '⚡';
                } else if (comboMessage.includes('PERFECT')) {
                    skillComboIcon.textContent = '💎';
                } else if (comboMessage.includes('RAPID')) {
                    skillComboIcon.textContent = '🔥';
                } else {
                    skillComboIcon.textContent = '⭐';
                }
                
                // Update combo message in UI
                const comboTextElement = skillComboDisplay.querySelector('div');
                if (comboTextElement) {
                    comboTextElement.innerHTML = `<span style="color: #FFD700;">+${bonusPoints} ${comboMessage}</span>`;
                }
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    skillComboDisplay.style.display = 'none';
                }, 3000);
                
                // Enhanced audio for combos
                if (bonusPoints > 200) {
                    audioManager.createTone(880, 0.3, 'sine'); // High achievement sound
                    audioManager.createTone(660, 0.4, 'sine'); // Chord
                } else if (bonusPoints > 100) {
                    audioManager.createTone(660, 0.2, 'sine'); // Medium achievement
                } else {
                    audioManager.createTone(440, 0.15, 'sine'); // Basic skill sound
                }
                
                console.log(`SKILL COMBO: ${comboMessage} - +${bonusPoints} points`);
            }
        }
        
        function trackPlayerMove(moveType, lane = null) {
            const currentTime = performance.now();
            const actualLane = lane !== null ? lane : gameState.playerLane;
            
            // BUGFIX: Only track lane changes for rapid move bonuses, not jumping/ducking
            if (gameState.lastAction !== moveType && (moveType === 'left' || moveType === 'right')) {
                const timeSinceLastMove = currentTime - gameState.lastSkillTime;
                
                // Award rapid movement bonus only for actual lane changes (skill moves)
                if (timeSinceLastMove < 1000 && gameState.rapidMoveBonus < 5) { // Max 5 rapid moves
                    gameState.rapidMoveBonus++;
                    const rapidBonus = gameState.rapidMoveBonus * 10;
                    addScore(rapidBonus, 'rapid_lane_change');
                    
                    // Show rapid move feedback
                    if (gameState.rapidMoveBonus >= 3) {
                        showSkillCombo(rapidBonus, `RAPID LANE CHANGES x${gameState.rapidMoveBonus}!`);
                    }
                } else if (timeSinceLastMove > 2000) {
                    gameState.rapidMoveBonus = 0; // Reset if too slow
                }
                
                gameState.lastAction = moveType;
                gameState.lastSkillTime = currentTime;
            }
            
            // Track jumping and ducking without giving points (just for sequence tracking)
            if (moveType === 'jumping' || moveType === 'ducking') {
                gameState.lastAction = moveType;
            }
        }
        
        // ==================== END SKILL COMBO SYSTEM ====================
        
        // ==================== SIMPLIFIED BRIDGE/UNDERPASS SYSTEM ====================
        
        function createBridgeSegment(z) {
            const bridgeGroup = new THREE.Group();
            
            // Bridge deck (road above)
            const bridgeGeometry = new THREE.BoxGeometry(12, 0.5, 10);
            const bridgeMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            bridge.position.set(0, 6.5, z);
            bridgeGroup.add(bridge);
            
            // Support pillars
            const pillarGeometry = new THREE.BoxGeometry(0.8, 6, 0.8);
            const pillarMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            for (let x of [-4, 4]) {
                const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
                pillar.position.set(x, 3, z);
                bridgeGroup.add(pillar);
            }
            
            // Bridge railings
            const railingGeometry = new THREE.BoxGeometry(12, 0.3, 0.2);
            const railingMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
            
            for (let side of [-4.5, 4.5]) {
                const railing = new THREE.Mesh(railingGeometry, railingMaterial);
                railing.position.set(0, 7.2, z + side);
                bridgeGroup.add(railing);
            }
            
            // Cars on bridge (decorative)
            if (Math.random() > 0.7) {
                const carGeometry = new THREE.BoxGeometry(1.5, 0.5, 3);
                const carMaterial = new THREE.MeshLambertMaterial({ 
                    color: Math.random() > 0.5 ? 0xFF0000 : 0x0000FF 
                });
                
                const car = new THREE.Mesh(carGeometry, carMaterial);
                car.position.set(
                    (Math.random() - 0.5) * 8, 
                    7, 
                    z + (Math.random() - 0.5) * 8
                );
                bridgeGroup.add(car);
            }
            
            return bridgeGroup;
        }
        
        function createSimpleKiwi(lane, z) {
            const kiwiGroup = new THREE.Group();
            
            // Simplified kiwi for performance (less detailed than createKiwi)
            const kiwiRadius = 0.25;
            
            // Half sphere for kiwi body
            const kiwiGeometry = new THREE.SphereGeometry(kiwiRadius, 8, 4, 0, Math.PI * 2, 0, Math.PI / 2);
            const kiwiMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8B6914,
                transparent: true,
                opacity: 0.9
            });
            
            const kiwiBody = new THREE.Mesh(kiwiGeometry, kiwiMaterial);
            kiwiBody.rotation.x = -Math.PI / 2;
            kiwiGroup.add(kiwiBody);
            
            // Simple flesh circle
            const fleshGeometry = new THREE.CircleGeometry(kiwiRadius * 0.9, 8);
            const fleshMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.95
            });
            
            const flesh = new THREE.Mesh(fleshGeometry, fleshMaterial);
            flesh.rotation.x = -Math.PI / 2;
            flesh.position.y = 0.01;
            kiwiGroup.add(flesh);
            
            // Simple white core
            const coreGeometry = new THREE.CircleGeometry(kiwiRadius * 0.3, 6);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xF5F5DC
            });
            
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.rotation.x = -Math.PI / 2;
            core.position.y = 0.02;
            kiwiGroup.add(core);
            
            // Position
            const LANE_POSITIONS = [-2, 0, 2];
            kiwiGroup.position.set(LANE_POSITIONS[lane], 1.2, z);
            
            scene.add(kiwiGroup);
            
            return {
                mesh: kiwiGroup,
                type: 'kiwi',
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0,
                baseY: 1.2
            };
        }
        
        function createSimplePowerUp(type, lane, z) {
            const powerUpGroup = new THREE.Group();
            
            // Main power-up crystal
            const crystalGeometry = new THREE.BoxGeometry(0.4, 0.6, 0.4);
            const crystalMaterial = new THREE.MeshBasicMaterial({ 
                color: POWER_UP_TYPES[type].color,
                transparent: true,
                opacity: 0.8
            });
            
            const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
            powerUpGroup.add(crystal);
            
            // Power-up glow
            const glowGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: POWER_UP_TYPES[type].color,
                transparent: true,
                opacity: 0.2
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            powerUpGroup.add(glow);
            
            // Position
            const LANE_POSITIONS = [-2, 0, 2];
            powerUpGroup.position.set(LANE_POSITIONS[lane], 1.5, z);
            
            scene.add(powerUpGroup);
            
            return {
                mesh: powerUpGroup,
                type: type,
                lane: lane,
                z: z,
                collected: false,
                animationTime: 0,
                baseY: 1.5
            };
        }
        
        function createTunnelSegment(z) {
            const tunnelGroup = new THREE.Group();
            
            // Tunnel walls (left and right)
            const wallGeometry = new THREE.BoxGeometry(0.3, 6, 8);
            const wallMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            
            // Left wall
            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-4, 3, z);
            tunnelGroup.add(leftWall);
            
            // Right wall  
            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(4, 3, z);
            tunnelGroup.add(rightWall);
            
            // Tunnel ceiling
            const ceilingGeometry = new THREE.BoxGeometry(8, 0.3, 8);
            const ceilingMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x333333,
                transparent: true,
                opacity: 0.8
            });
            
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.set(0, 5.5, z);
            tunnelGroup.add(ceiling);
            
            // Tunnel floor stripes (more industrial look)
            const stripeGeometry = new THREE.BoxGeometry(8, 0.05, 0.2);
            const stripeMaterial = new THREE.MeshLambertMaterial({ color: 0xFFFF00 });
            
            for (let i = 0; i < 3; i++) {
                const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                stripe.position.set(0, 0.05, z + (i * 2 - 2));
                tunnelGroup.add(stripe);
            }
            
            // Tunnel support beams
            const beamGeometry = new THREE.BoxGeometry(0.1, 5.5, 0.2);
            const beamMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            for (let side of [-3.8, 3.8]) {
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.set(side, 2.75, z);
                tunnelGroup.add(beam);
            }
            
            // Add tunnel lighting
            const lightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFAA,
                transparent: true,
                opacity: 0.8
            });
            
            const tunnelLight = new THREE.Mesh(lightGeometry, lightMaterial);
            tunnelLight.position.set(0, 5, z);
            tunnelGroup.add(tunnelLight);
            
            // Add light glow effect
            const glowGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFFFAA,
                transparent: true,
                opacity: 0.2
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(0, 5, z);
            tunnelGroup.add(glow);
            
            return tunnelGroup;
        }
        
        function createTunnelEntrance(z) {
            const entranceGroup = new THREE.Group();
            
            // Tunnel entrance arch
            const archGeometry = new THREE.CylinderGeometry(4.5, 4.5, 0.5, 16, 1, false, 0, Math.PI);
            const archMaterial = new THREE.MeshLambertMaterial({ color: 0x555555 });
            
            const arch = new THREE.Mesh(archGeometry, archMaterial);
            arch.position.set(0, 4.5, z);
            arch.rotation.z = Math.PI;
            entranceGroup.add(arch);
            
            // Entrance signs
            const signGeometry = new THREE.BoxGeometry(2, 0.5, 0.1);
            const signMaterial = new THREE.MeshLambertMaterial({ color: 0x2E86AB });
            
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 6, z);
            entranceGroup.add(sign);
            
            // Warning lights
            for (let x of [-1.5, 1.5]) {
                const warningLight = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFF4500 })
                );
                warningLight.position.set(x, 5.5, z);
                entranceGroup.add(warningLight);
            }
            
            return entranceGroup;
        }
        
        function checkBridgeSpawning() {
            const currentTime = performance.now();
            const gameTime = (currentTime - gameState.gameStartTime);
            
            // Progressive bridge spawning (longer intervals at start, shorter later)
            if (gameTime > gameState.nextTunnelTime) {
                const bridge = createBridgeSegment(-40);
                scene.add(bridge);
                gameState.tunnelSegments.push(bridge);
                
                // Audio effect for bridge
                audioManager.createTone(300, 0.2, 'sine');
                
                // Progressive bridge frequency
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime);
                const baseInterval = 25000; // 25 seconds at start
                const minInterval = 12000; // 12 seconds at end
                const currentInterval = baseInterval - (baseInterval - minInterval) * gameProgress;
                const randomVariation = Math.random() * 5000; // ±2.5 seconds
                
                gameState.nextTunnelTime = gameTime + currentInterval + randomVariation;
                
                console.log(`Bridge spawned! Next in ${(currentInterval + randomVariation)/1000}s`);
            }
        }
        
        function startTunnelTransition() {
            console.log('Entering tunnel...');
            gameState.currentEnvironment = 'tunnel_entrance';
            gameState.environmentTransition = true;
            gameState.tunnelStartTime = performance.now();
            
            // Update UI
            updateEnvironmentUI();
            
            // Create tunnel entrance
            const entrance = createTunnelEntrance(-25);
            scene.add(entrance);
            gameState.tunnelSegments.push(entrance);
            
            // Audio effect for tunnel entrance
            audioManager.createTone(200, 0.5, 'sine');
            
            // Dim ambient lighting
            gameState.ambientLightIntensity = 0.3;
            if (scene.children.find(child => child.type === 'AmbientLight')) {
                scene.children.find(child => child.type === 'AmbientLight').intensity = 0.3;
            }
            
            // Create initial tunnel segments
            for (let i = 0; i < 8; i++) {
                const segment = createTunnelSegment(-30 - (i * 8));
                scene.add(segment);
                gameState.tunnelSegments.push(segment);
            }
            
            // Transition to full tunnel after 2 seconds
            setTimeout(() => {
                gameState.currentEnvironment = 'tunnel';
                gameState.environmentTransition = false;
                updateEnvironmentUI();
                console.log('Now in tunnel!');
            }, 2000);
        }
        
        // NEW: Brokkoli health effect
        function createBroccoliHealthEffect(position) {
            const healthParticles = [];
            const particleCount = 15;
            
            for (let i = 0; i < particleCount; i++) {
                // Heart-shaped particles for health effect
                const heartSize = 0.08 + Math.random() * 0.05;
                const heartGeometry = new THREE.SphereGeometry(heartSize, 6, 4);
                const heartMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(0.2, 0.8 + Math.random() * 0.2, 0.3),
                    transparent: true,
                    opacity: 0.9
                });
                
                const heart = new THREE.Mesh(heartGeometry, heartMaterial);
                heart.position.copy(position);
                
                // Upward floating motion for health
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    3 + Math.random() * 2,  // Upward
                    (Math.random() - 0.5) * 3
                );
                
                heart.userData = { velocity: velocity, life: 1.0 };
                scene.add(heart);
                healthParticles.push(heart);
            }
            
            // Animate health particles
            function animateHealthParticles() {
                healthParticles.forEach((particle, index) => {
                    if (particle.userData.life > 0) {
                        particle.position.add(particle.userData.velocity.clone().multiplyScalar(0.016));
                        particle.userData.velocity.y -= 0.3; // Gravity
                        particle.userData.life -= 0.02;
                        particle.material.opacity = particle.userData.life;
                        
                        if (particle.userData.life <= 0) {
                            scene.remove(particle);
                            healthParticles.splice(index, 1);
                        }
                    }
                });
                
                if (healthParticles.length > 0) {
                    requestAnimationFrame(animateHealthParticles);
                }
            }
            
            animateHealthParticles();
        }
        
        // NEW: Update collectible UI for both kiwis and broccolis
        function updateCollectibleUI() {
            const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
            const collectionPercentage = gameState.totalCollectibles > 0 ? 
                (collectedTotal / gameState.totalCollectibles * 100).toFixed(0) : 0;
            
            // Update display (you can expand this with actual UI elements)
            console.log(`🥝 Kiwis: ${gameState.collectedKiwis} | 🥦 Broccolis: ${gameState.collectedBroccolis} | Progress: ${collectionPercentage}%`);
            
            // Check for collection milestone bonus (80% collected)
            if (collectionPercentage >= 80 && !gameState.collectionBonusAwarded) {
                awardCollectionBonus();
            }
        }
        
        // NEW: Award bonus for collecting 80% of available collectibles
        function awardCollectionBonus() {
            if (gameState.collectionBonusAwarded) return;
            
            gameState.collectionBonusAwarded = true;
            const collectedTotal = gameState.collectedKiwis + gameState.collectedBroccolis;
            const collectionPercentage = (collectedTotal / gameState.totalCollectibles * 100).toFixed(0);
            
            // Calculate bonus - generous reward for achievement
            const baseBonus = 500;
            const percentageBonus = Math.floor((collectionPercentage - 80) * 20); // Extra for over 80%
            const totalBonus = baseBonus + percentageBonus;
            
            addScore(totalBonus, 'collection_achievement');
            
            // Special celebration effects
            showCollectionAchievement(collectedTotal, gameState.totalCollectibles, totalBonus);
            
            // Audio celebration
            audioManager.createTone(523, 0.3, 'sine'); // C5
            setTimeout(() => audioManager.createTone(659, 0.3, 'sine'), 150); // E5
            setTimeout(() => audioManager.createTone(784, 0.4, 'sine'), 300); // G5
            
            console.log(`🎉 COLLECTION ACHIEVEMENT! ${collectionPercentage}% collected - Bonus: +${totalBonus} points`);
        }
        
        // NEW: Show collection achievement UI
        function showCollectionAchievement(collected, total, bonus) {
            // Create achievement popup (you can enhance this with actual UI)
            const percentage = (collected / total * 100).toFixed(0);
            
            // For now, show in console - can be enhanced with visual UI later
            console.log(`
🏆 COLLECTION MASTER! 🏆
━━━━━━━━━━━━━━━━━━━━
🥝 Collected: ${collected}/${total} (${percentage}%)
💎 Bonus Score: +${bonus} points
🎯 Achievement: Healthy Eater!
━━━━━━━━━━━━━━━━━━━━
            `);
            
            // Trigger confetti or other celebration effects
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createParticleEffect(
                        new THREE.Vector3(
                            player.position.x + (Math.random() - 0.5) * 4,
                            player.position.y + 3,
                            player.position.z
                        ),
                        [0xFFD700, 0x00FF00, 0xFF69B4][i % 3],
                        'celebration'
                    );
                }, i * 100);
            }
        }
        
        function exitTunnelTransition() {
            console.log('Exiting tunnel...');
            gameState.currentEnvironment = 'tunnel_exit';
            gameState.environmentTransition = true;
            gameState.lastTunnelExit = performance.now();
            
            // Update UI
            updateEnvironmentUI();
            
            // Schedule next tunnel
            const currentTime = performance.now();
            const gameTime = (currentTime - gameState.gameStartTime);
            gameState.nextTunnelTime = gameTime + gameState.tunnelCooldown;
            
            // Audio effect for tunnel exit
            audioManager.createTone(400, 0.3, 'sine');
            
            // Restore ambient lighting gradually
            gameState.ambientLightIntensity = 1.0;
            if (scene.children.find(child => child.type === 'AmbientLight')) {
                scene.children.find(child => child.type === 'AmbientLight').intensity = 1.0;
            }
            
            // Clean up tunnel segments gradually
            setTimeout(() => {
                cleanupTunnelSegments();
                gameState.currentEnvironment = 'street';
                gameState.environmentTransition = false;
                updateEnvironmentUI();
                console.log('Back to street!');
            }, 3000);
        }
        
        function updateBridgeEnvironment(deltaTime) {
            // Move bridge segments
            gameState.tunnelSegments.forEach((segment, index) => {
                segment.position.z += visualSpeed;
                
                // Remove segments that have passed the player
                if (segment.position.z > 15) {
                    scene.remove(segment);
                    gameState.tunnelSegments.splice(index, 1);
                }
            });
            
            // Animate cars on bridges
            gameState.tunnelSegments.forEach(segment => {
                segment.children.forEach(child => {
                    if (child.material && child.material.color && 
                        (child.material.color.r > 0.8 || child.material.color.b > 0.8)) { // Car objects
                        child.position.x += (Math.random() - 0.5) * 0.01; // Slight car movement
                    }
                });
            });
        }
        
        function cleanupTunnelSegments() {
            gameState.tunnelSegments.forEach(segment => {
                scene.remove(segment);
            });
            gameState.tunnelSegments = [];
        }
        
        function getTunnelSpecificObstacles() {
            // Tunnel-specific obstacles that make sense in confined space
            return [
                'lowbarrier', 'duckbeam', 'wallgap', 'spikes',
                'rotatingblade', 'swinginghammer' // Moving obstacles work well in tunnels
            ];
        }
        
        // ==================== END TUNNEL ENVIRONMENT SYSTEM ====================
        
        // ==================== END POWER-UP SYSTEM ====================
        
        // Near-miss detection and bonus system
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            // Prevent multiple near-miss triggers for same obstacle
            if (obstacle.nearMissTriggered) return;
            obstacle.nearMissTriggered = true;
            
            // Calculate how close the call was
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const nearMissBonus = Math.floor((0.3 - distance) * 100); // Closer = more points
            
            addScore(nearMissBonus, 'near_miss_bonus');
            
            // Near-miss audio feedback
            audioManager.play('nearmiss');
            
            // Enhanced visual feedback for near miss
            const effectPos = obstacle.mesh.position.clone();
            
            // Create multiple spark effects
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const sparkPos = effectPos.clone();
                    sparkPos.x += (Math.random() - 0.5);
                    sparkPos.y += Math.random() * 0.5;
                    sparkPos.z += (Math.random() - 0.5) * 0.5;
                    createParticleEffect(sparkPos, 0xFFFF00, 'spark');
                }, i * 30);
            }
            
            // Main near miss effect
            createParticleEffect(effectPos, 0xFFD700, 'nearMiss');
            
            // Camera effect for close calls
            if (distance < 0.1) {
                cameraZoomEffect(1.05, 150);
            }
            
            // Show near-miss popup
            showScorePopup(nearMissBonus, effectPos, distance < 0.1 ? 'SUPER CLOSE!' : 'CLOSE!');
        }
        
        // Update animations for moving obstacles
        function updateMovingObstacles(deltaTime) {
            obstacles.forEach(obstacle => {
                obstacle.animationTime += deltaTime * 0.001; // Convert to seconds
                
                switch (obstacle.type) {
                    case 'rotatingblade':
                        // Rotate the blade group
                        const bladeGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (bladeGroup) {
                            bladeGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                            
                            // Add warning sound for fast rotating blades
                            if (obstacle.rotationSpeed > 4 && Math.random() > 0.98) {
                                audioManager.createNoise(0.02, 800 + Math.random() * 400);
                            }
                        }
                        break;
                        
                    case 'swinginghammer':
                        // Swing the hammer arm
                        const hammerGroup = obstacle.mesh.children.find(child => child.type === 'Group');
                        if (hammerGroup) {
                            const armGroup = hammerGroup.children.find(child => child.type === 'Group');
                            if (armGroup) {
                                const swingAngle = Math.sin(obstacle.animationTime * obstacle.swingSpeed) * obstacle.swingAmplitude;
                                armGroup.rotation.z = swingAngle;
                                
                                // Add swoosh sound at swing extremes
                                if (Math.abs(swingAngle) > obstacle.swingAmplitude * 0.8 && Math.random() > 0.95) {
                                    audioManager.createNoise(0.03, 1200 + Math.abs(swingAngle) * 500);
                                }
                            }
                        }
                        break;
                        
                    case 'movingwall':
                        // Move the wall side to side
                        const movingWall = obstacle.mesh.children[0];
                        if (movingWall) {
                            const movement = Math.sin(obstacle.animationTime * obstacle.movementSpeed) * obstacle.movementRange;
                            obstacle.mesh.position.x = obstacle.initialX + movement;
                            
                            // Add mechanical sound when changing direction
                            const prevMovement = Math.sin((obstacle.animationTime - deltaTime * 0.001) * obstacle.movementSpeed) * obstacle.movementRange;
                            if (Math.sign(movement) !== Math.sign(prevMovement) && Math.random() > 0.9) {
                                audioManager.createTone(150, 0.1, 'square');
                            }
                        }
                        break;
                        
                    case 'bouncingball':
                        // Bounce the ball up and down with realistic physics
                        const ballGroup = obstacle.mesh.children[0];
                        if (ballGroup) {
                            const ball = ballGroup.children[0]; // The actual ball
                            const shadow = ballGroup.children[1]; // Ground shadow
                            const ring = ballGroup.children[2]; // Warning ring
                            
                            if (ball && shadow && ring) {
                                // Bouncing motion using sine wave with gravity simulation
                                const bouncePhase = obstacle.animationTime * obstacle.bounceSpeed;
                                const bounceHeight = Math.abs(Math.sin(bouncePhase)) * obstacle.bounceHeight;
                                ball.position.y = 0.6 + bounceHeight; // 0.6 is ball radius
                                
                                // Scale shadow based on height (higher = smaller shadow)
                                const shadowScale = 1 - (bounceHeight / obstacle.bounceHeight) * 0.3;
                                shadow.scale.set(shadowScale, 1, shadowScale);
                                
                                // Pulse warning ring
                                const ringPulse = 1 + Math.sin(obstacle.animationTime * 8) * 0.2;
                                ring.scale.set(ringPulse, 1, ringPulse);
                                
                                // Add bounce sound at impact
                                if (bounceHeight < 0.2 && Math.random() > 0.97) {
                                    audioManager.createTone(200 + Math.random() * 100, 0.1, 'square');
                                }
                            }
                        }
                        break;
                        
                    case 'spinninglaser':
                        // Spin the laser beams and pulse warning lights
                        const laserGroup = obstacle.mesh.children[0];
                        if (laserGroup) {
                            const laserBeamGroup = laserGroup.children.find(child => child.type === 'Group');
                            
                            if (laserBeamGroup) {
                                // Rotate laser beams
                                laserBeamGroup.rotation.y += obstacle.rotationSpeed * deltaTime * 0.001;
                                
                                // Pulse warning lights
                                const pulseFactor = (Math.sin(obstacle.animationTime * obstacle.pulseSpeed) + 1) / 2;
                                laserGroup.children.forEach(child => {
                                    if (child.geometry && child.geometry.type === 'SphereGeometry') {
                                        child.material.emissive.setHex(pulseFactor > 0.5 ? 0x440000 : 0x220000);
                                    }
                                });
                                
                                // Add laser whir sound
                                if (obstacle.rotationSpeed > 2.5 && Math.random() > 0.98) {
                                    audioManager.createNoise(0.02, 1500 + Math.random() * 500);
                                }
                            }
                        }
                        break;
                }
            });
        }

        function showScorePopup(score, position) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            context.fillStyle = '#00FF00';
            context.font = 'bold 24px Arial';
            context.textAlign = 'center';
            context.fillText(`+${score}`, 64, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            
            sprite.position.copy(position);
            sprite.position.y += 2;
            sprite.scale.set(2, 1, 1);
            scene.add(sprite);
            
            // Animate popup
            const startY = sprite.position.y;
            const animatePopup = () => {
                sprite.position.y += 0.05;
                sprite.material.opacity -= 0.02;
                
                if (sprite.material.opacity > 0) {
                    requestAnimationFrame(animatePopup);
                } else {
                    scene.remove(sprite);
                }
            };
            animatePopup();
        }

        function loseLife() {
            gameState.lives--;
            
            // Make player invulnerable for 2 seconds
            gameState.invulnerable = true;
            gameState.invulnerabilityTime = 2000;
            
            // Visual feedback - make player flash red
            player.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(0xFF6B6B);
                    child.material.transparent = true;
                    child.material.opacity = 0.7;
                }
            });
            
            if (gameState.lives <= 0) {
                endGame();
            }
        }

        // Smooth linear interpolation function
        function lerp(start, end, factor) {
            return start + (end - start) * factor;
        }
        
        // Enhanced environment movement with parallax and smooth speed
        function updateEnvironmentMovement(deltaTime) {
            // Smooth speed interpolation
            visualSpeed = lerp(visualSpeed, gameState.speed, SPEED_LERP_FACTOR);
            
            // Move all environment objects with parallax effect
            Object.keys(environmentObjects).forEach(category => {
                environmentObjects[category].forEach((obj, index) => {
                    if (obj && obj.userData) {
                        const parallaxSpeed = visualSpeed * obj.userData.parallaxSpeed;
                        obj.position.z += parallaxSpeed;
                        
                        // Reset object position when it goes too far
                        if (obj.position.z > 50) {
                            // Calculate new spawn position based on object type
                            let resetDistance = -150;
                            if (obj.userData.type === 'building') {
                                resetDistance = -200 - Math.random() * 50;
                            } else if (obj.userData.type === 'streetLamp') {
                                resetDistance = -120;
                            } else if (obj.userData.type === 'streetLine') {
                                resetDistance = -120;
                            }
                            
                            obj.position.z = resetDistance;
                            
                            // Add some variation for buildings
                            if (obj.userData.type === 'building') {
                                // Randomize building properties
                                const side = obj.position.x < 0 ? 'left' : 'right';
                                const baseX = side === 'left' ? -15 : 15;
                                obj.position.x = baseX + (Math.random() - 0.5) * 8;
                                
                                // Update parallax speed slightly for variation
                                obj.userData.parallaxSpeed = 0.7 + Math.random() * 0.2;
                            }
                        }
                    }
                });
            });
        }
        
        // Dynamic audio system that responds to speed
        let lastEngineTime = 0;
        function updateDynamicAudio() {
            const currentTime = performance.now();
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Engine sound every 800ms, pitch increases with speed
            if (currentTime - lastEngineTime > 800) {
                audioManager.play('engine');
                lastEngineTime = currentTime;
            }
            
            // High-speed wind effects
            if (speedRatio > 0.7 && Math.random() > 0.95) {
                // Occasional high-speed wind whoosh
                audioManager.createNoise(0.08, 4000 + speedRatio * 2000);
            }
            
            // Master volume adjustment based on speed for intensity
            const baseVolume = 0.3;
            const speedVolume = baseVolume * (0.8 + speedRatio * 0.4);
            if (audioManager.audioContext && audioManager.masterGain) {
                audioManager.masterGain.gain.setValueAtTime(speedVolume, audioManager.audioContext.currentTime);
            }
        }
        
        // Enhanced motion blur effect at high speeds
        function updateVisualEffects() {
            const speedRatio = visualSpeed / gameState.maxSpeed;
            
            // Dynamic fog based on speed
            if (scene.fog) {
                scene.fog.near = 20 - speedRatio * 10; // Closer fog at high speed
                scene.fog.far = 60 + speedRatio * 20; // Extended range
            }
            
            // Camera FOV effect for speed sensation
            const baseFov = 60;
            const speedFov = baseFov + speedRatio * 15; // Wider FOV at high speed
            camera.fov = lerp(camera.fov, speedFov, 0.02);
            camera.updateProjectionMatrix();
            
            // Enhanced camera shake at high speeds
            if (speedRatio > 0.7) {
                const shakeIntensity = (speedRatio - 0.7) * 0.1;
                gameState.cameraShakeIntensity = Math.max(gameState.cameraShakeIntensity, shakeIntensity);
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Calculate delta time for smooth movement
            const currentTime = performance.now();
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            if (gameState.isPlaying) {
                // Update player position
                const targetX = LANE_POSITIONS[gameState.playerLane];
                player.position.x += (targetX - player.position.x) * 0.1;
                
                // Handle jumping - FIXED: Use proper deltaTime for frame-independent physics
                if (gameState.playerAction === 'jumping') {
                    const deltaTimeSeconds = deltaTime / 1000; // Convert to seconds
                    gameState.playerY += gameState.jumpVelocity * deltaTimeSeconds;
                    gameState.jumpVelocity -= 30 * deltaTimeSeconds; // Gravity in units/second²
                    
                    // BUGFIX: Maximum jump duration safety check
                    const jumpDuration = Date.now() - gameState.jumpStartTime;
                    if (jumpDuration > gameState.maxJumpDuration) {
                        console.warn('Jump duration exceeded, forcing landing');
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                    }
                    
                    // Landing with safety check
                    if (gameState.playerY <= 0) {
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                    }
                    
                    // BUGFIX: Enhanced safety check - trigger earlier at Y < -2
                    if (gameState.playerY < -2) {
                        console.warn('Player stuck in air, resetting position');
                        gameState.playerY = 0;
                        gameState.jumpVelocity = 0;
                        gameState.playerAction = 'running';
                        
                        // Landing Audio & Visual
                        audioManager.play('land');
                        
                        // Enhanced landing effects
                        const landingPos = new THREE.Vector3(player.position.x, 0.1, player.position.z);
                        
                        // Main landing dust
                        createParticleEffect(landingPos, 0xAAAAAA, 'landing');
                        
                        // Additional dust clouds
                        for (let i = 0; i < 4; i++) {
                            const angle = (i / 4) * Math.PI * 2;
                            const dustPos = landingPos.clone();
                            dustPos.x += Math.cos(angle) * 0.5;
                            dustPos.z += Math.sin(angle) * 0.5;
                            setTimeout(() => {
                                createParticleEffect(dustPos, 0x8B7355, 'dust');
                            }, i * 20);
                        }
                        
                        // Mini screen shake for landing
                        screenShake(0.05, 100);
                    }
                }
                
                // Handle ducking
                if (gameState.playerAction === 'ducking') {
                    player.scale.y = 0.5;
                } else {
                    player.scale.y = 1;
                }
                
                player.position.y = gameState.playerY;
                
                // Handle invulnerability
                if (gameState.invulnerable) {
                    gameState.invulnerabilityTime -= 16; // ~16ms per frame at 60fps
                    
                    // Flash effect
                    const flashRate = Math.sin(Date.now() * 0.02) > 0;
                    player.children.forEach(child => {
                        if (child.material) {
                            child.material.opacity = flashRate ? 0.3 : 0.7;
                        }
                    });
                    
                    if (gameState.invulnerabilityTime <= 0) {
                        gameState.invulnerable = false;
                        // Restore normal player appearance
                        player.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = 1.0;
                                child.material.transparent = false;
                            }
                        });
                        // Restore original colors
                        if (player.children[0]) player.children[0].material.color.setHex(0x4A90E2); // Body
                        if (player.children[1]) player.children[1].material.color.setHex(0xF5B041); // Head
                    }
                }
                
                // Move track with smooth speed
                track.children.forEach(segment => {
                    segment.position.z += visualSpeed;
                    if (segment.position.z > 10) {
                        segment.position.z -= 100;
                    }
                });
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Move obstacles with smooth speed
                obstacles.forEach((obstacle, index) => {
                    obstacle.mesh.position.z += visualSpeed;
                    obstacle.z = obstacle.mesh.position.z;
                    
                    if (obstacle.z > 10) {
                        scene.remove(obstacle.mesh);
                        obstacles.splice(index, 1);
                        addScore(10, 'shield_collision');
                    }
                });
                
                // ==================== BRIDGE SPAWNING CHECK ====================
                checkBridgeSpawning();
                
                // ==================== ENVIRONMENT-SPECIFIC OBSTACLE SPAWNING ====================
                
                // ==================== PROGRESSIVE DIFFICULTY SYSTEM ====================
                
                // Calculate game progress (0 to 1)
                const gameProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 at start, 1 at end
                
                // Optimized obstacle spawning with better difficulty curve
                let baseSpawnRate, maxSpawnRate;
                
                if (gameProgress < 0.2) {
                    // Phase 1: Very gentle start (0-12s)
                    baseSpawnRate = 0.003;
                    maxSpawnRate = 0.008;
                } else if (gameProgress < 0.5) {
                    // Phase 2: Moderate challenge (12-30s)
                    baseSpawnRate = 0.008;
                    maxSpawnRate = 0.015;
                } else if (gameProgress < 0.8) {
                    // Phase 3: Challenging (30-48s)
                    baseSpawnRate = 0.012;
                    maxSpawnRate = 0.020;
                } else {
                    // Phase 4: Extreme finale (48-60s)
                    baseSpawnRate = 0.015;
                    maxSpawnRate = 0.025;
                }
                
                const phaseProgress = gameProgress < 0.2 ? gameProgress / 0.2 :
                                     gameProgress < 0.5 ? (gameProgress - 0.2) / 0.3 :
                                     gameProgress < 0.8 ? (gameProgress - 0.5) / 0.3 :
                                     (gameProgress - 0.8) / 0.2;
                
                const progressiveSpawnRate = baseSpawnRate + (maxSpawnRate - baseSpawnRate) * phaseProgress;
                
                // Speed multiplier adjusted for combo potential
                const speedRatio = gameState.speed / gameState.maxSpeed;
                const spawnSpeedMultiplier = 1 + speedRatio * 0.2; // Gentler speed scaling
                
                let spawnRate = progressiveSpawnRate * spawnSpeedMultiplier;
                
                // Dynamic adjustment based on player performance
                if (gameState.consecutiveAvoidances > 5) {
                    // Player is doing well, slightly increase challenge
                    spawnRate *= 1.1;
                } else if (gameState.lives === 1) {
                    // Player struggling, reduce difficulty slightly
                    spawnRate *= 0.85;
                }
                
                // Reduce spawn rate during bridge transitions
                if (gameState.environmentTransition) {
                    spawnRate *= 0.3;
                }
                
                if (Math.random() < spawnRate) {
                    // Simplified obstacle spawning
                    const jumpObstacles = ['lowbarrier', 'jumpblock', 'hurdleset'];
                    const duckObstacles = ['highbarrier', 'duckbeam', 'wallgap'];
                    const flexibleObstacles = ['spikes'];
                    const movingObstacles = ['rotatingblade', 'swinginghammer', 'movingwall', 'bouncingball', 'spinninglaser'];
                    
                    let type;
                    const rand = Math.random();
                    
                    // Progressive difficulty for obstacle types
                    // Early game: mostly simple obstacles
                    // Late game: more complex moving obstacles
                    let movingChance, complexChance;
                    
                    if (gameProgress < 0.3) {
                        // First 30% of game: mostly basic obstacles
                        movingChance = 0.02; // Very few moving obstacles
                        complexChance = 0.1; // Few complex obstacles
                    } else if (gameProgress < 0.6) {
                        // Middle 30%: gradually introduce moving obstacles
                        movingChance = 0.02 + (gameProgress - 0.3) * 0.3; // 2% to 11%
                        complexChance = 0.3;
                    } else {
                        // Final 40%: more challenging obstacles
                        movingChance = 0.11 + (gameProgress - 0.6) * 0.225; // 11% to 20%
                        complexChance = 0.5;
                    }
                    
                    if (rand < movingChance) {
                        // Moving obstacles (progressive introduction)
                        type = movingObstacles[Math.floor(Math.random() * movingObstacles.length)];
                    } else if (rand < movingChance + complexChance) {
                        // Complex static obstacles (hurdleset, highbarrier)
                        const complexObstacles = ['hurdleset', 'highbarrier'];
                        type = complexObstacles[Math.floor(Math.random() * complexObstacles.length)];
                    } else if (rand < movingChance + complexChance + 0.3) {
                        // Jump obstacles (basic)
                        type = jumpObstacles[Math.floor(Math.random() * jumpObstacles.length)];
                    } else if (rand < movingChance + complexChance + 0.6) {
                        // Duck obstacles (basic)
                        type = duckObstacles[Math.floor(Math.random() * duckObstacles.length)];
                    } else {
                        // Flexible obstacles (easiest)
                        type = flexibleObstacles[Math.floor(Math.random() * flexibleObstacles.length)];
                    }
                    
                    const lane = Math.floor(Math.random() * 3);
                    createObstacle(type, lane, -30);
                }
                
                // ==================== PROGRESSIVE POWER-UP & COIN SPAWNING ====================
                
                // Progressive Power-Up spawning (rare at start, more frequent later)
                const basePowerUpRate = 0.001; // Very low at start
                const maxPowerUpRate = 0.006; // Higher at end
                const progressivePowerUpRate = basePowerUpRate + (maxPowerUpRate - basePowerUpRate) * Math.pow(gameProgress, 1.5);
                
                if (Math.random() < progressivePowerUpRate && !gameState.activePowerUp) {
                    const powerUpTypes = Object.keys(POWER_UP_TYPES);
                    const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                    const lane = Math.floor(Math.random() * 3);
                    
                    const powerUp = createSimplePowerUp(randomType, lane, -35);
                    gameState.powerUps.push(powerUp);
                }
                
                // Progressive Kiwi spawning (few at start, many later)
                const baseCoinRate = 0.003; // Low starting rate
                const maxCoinRate = 0.015; // Higher end rate
                const progressiveCoinRate = baseCoinRate + (maxCoinRate - baseCoinRate) * Math.pow(gameProgress, 1.1);
                
                if (Math.random() < progressiveCoinRate) {
                    // Progressive kiwi pattern complexity
                    let pattern;
                    const patternRand = Math.random();
                    
                    if (gameProgress < 0.3) {
                        // Early game: mostly single kiwis
                        pattern = patternRand < 0.8 ? 'single' : 'line';
                    } else if (gameProgress < 0.6) {
                        // Mid game: introduce more patterns
                        if (patternRand < 0.5) {
                            pattern = 'single';
                        } else if (patternRand < 0.8) {
                            pattern = 'line';
                        } else {
                            pattern = 'arc';
                        }
                    } else {
                        // Late game: more complex patterns, more rewards
                        if (patternRand < 0.3) {
                            pattern = 'single';
                        } else if (patternRand < 0.6) {
                            pattern = 'line';
                        } else {
                            pattern = 'arc';
                        }
                    }
                    
                    // ENHANCED: Limit total collectibles to 12-15 per game (10-12 needed for 80% bonus)
                    if (gameState.totalCollectibles >= 15) {
                        // Max collectibles reached, no more spawning
                        return;
                    }
                    
                    // Randomly choose between kiwi and broccoli (50/50 chance)
                    const isKiwi = Math.random() < 0.5;
                    
                    if (pattern === 'single') {
                        const lane = Math.floor(Math.random() * 3);
                        if (isKiwi) {
                            const kiwi = createSimpleKiwi(lane, -35);
                            gameState.kiwis.push(kiwi);
                        } else {
                            const broccoli = createBroccoli(lane, -35, 'single');
                            gameState.broccolis.push(broccoli);
                        }
                    } else if (pattern === 'line') {
                        // Spawn collectibles in a line across lanes
                        for (let lane = 0; lane < 3; lane++) {
                            if (gameState.totalCollectibles >= 15) break; // Safety check
                            
                            // Mix kiwis and broccolis in line patterns
                            const collectibleType = Math.random() < 0.5;
                            if (collectibleType) {
                                const kiwi = createSimpleKiwi(lane, -35 - (lane * 2));
                                gameState.kiwis.push(kiwi);
                            } else {
                                const broccoli = createBroccoli(lane, -35 - (lane * 2), 'line');
                                gameState.broccolis.push(broccoli);
                            }
                        }
                    } else if (pattern === 'arc') {
                        // Spawn collectibles in arc pattern - mixed variety
                        const lanes = gameProgress > 0.5 ? [0, 1, 2] : [Math.floor(Math.random() * 2), Math.floor(Math.random() * 2) + 1];
                        lanes.forEach((lane, index) => {
                            if (gameState.totalCollectibles >= 15) return; // Safety check
                            
                            // Alternate between kiwis and broccolis in arcs
                            if (index % 2 === 0) {
                                const kiwi = createSimpleKiwi(lane, -35 - (index * 1.5));
                                gameState.kiwis.push(kiwi);
                            } else {
                                const broccoli = createBroccoli(lane, -35 - (index * 1.5), 'arc');
                                gameState.broccolis.push(broccoli);
                            }
                        });
                    }
                }
                
                // Update Power-Ups
                gameState.powerUps.forEach((powerUp, index) => {
                    powerUp.mesh.position.z += visualSpeed;
                    powerUp.z = powerUp.mesh.position.z;
                    
                    // Remove if passed player
                    if (powerUp.z > 10) {
                        scene.remove(powerUp.mesh);
                        gameState.powerUps.splice(index, 1);
                    }
                    
                    // Animate power-up rotation and floating
                    powerUp.animationTime += deltaTime * 0.001;
                    powerUp.mesh.rotation.y += 0.02;
                    powerUp.mesh.position.y = powerUp.baseY + Math.sin(powerUp.animationTime * 3) * 0.3;
                    
                    // Update particle effects
                    if (powerUp.particles) {
                        powerUp.particles.rotation.y += 0.01;
                    }
                });
                
                // Update Kiwis
                gameState.kiwis.forEach((kiwi, index) => {
                    kiwi.mesh.position.z += visualSpeed;
                    kiwi.z = kiwi.mesh.position.z;
                    
                    // Remove if passed player
                    if (kiwi.z > 10) {
                        scene.remove(kiwi.mesh);
                        gameState.kiwis.splice(index, 1);
                    }
                    
                    // Animate kiwi wobble and subtle floating
                    kiwi.animationTime += deltaTime * 0.001;
                    // Wobble rotation instead of spin
                    kiwi.mesh.rotation.z = Math.sin(kiwi.animationTime * 3) * 0.15;
                    kiwi.mesh.rotation.x = Math.cos(kiwi.animationTime * 2) * 0.1;
                    // Subtle bounce
                    const baseY = 1.2;
                    kiwi.mesh.position.y = baseY + Math.sin(kiwi.animationTime * 4) * 0.1;
                });
                
                // Update Broccolis (similar to kiwis)
                gameState.broccolis.forEach((broccoli, index) => {
                    broccoli.mesh.position.z += visualSpeed;
                    broccoli.z = broccoli.mesh.position.z;
                    
                    // Remove if passed player
                    if (broccoli.z > 10) {
                        scene.remove(broccoli.mesh);
                        gameState.broccolis.splice(index, 1);
                    }
                    
                    // Animate broccoli - different pattern than kiwis
                    broccoli.animationTime += deltaTime * 0.001;
                    // Gentle swaying motion for broccoli
                    broccoli.mesh.rotation.y = Math.sin(broccoli.animationTime * 2) * 0.1;
                    broccoli.mesh.rotation.z = Math.cos(broccoli.animationTime * 1.5) * 0.05;
                    // Slight vertical movement
                    const baseY = 1.0;
                    broccoli.mesh.position.y = baseY + Math.sin(broccoli.animationTime * 3) * 0.08;
                });
                
                // Handle Power-Up Time Remaining
                if (gameState.activePowerUp && gameState.powerUpTimeRemaining > 0) {
                    gameState.powerUpTimeRemaining -= deltaTime;
                    if (gameState.powerUpTimeRemaining <= 0) {
                        deactivatePowerUp();
                    }
                    updatePowerUpUI();
                }
                
                // ==================== END POWER-UP & COIN SPAWNING ====================
                
                // ==================== BRIDGE ENVIRONMENT UPDATE ====================
                
                updateBridgeEnvironment(deltaTime);
                
                // ==================== END BRIDGE ENVIRONMENT UPDATE ====================
                
                // Update camera with shake effect
                const baseX = player.position.x * 0.3;
                const baseY = 3 + Math.sin(Date.now() * 0.002) * 0.05;
                const baseZ = 8;
                
                // Apply screen shake
                const shakeX = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeY = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 2;
                const shakeZ = gameState.cameraShakeIntensity * (Math.random() - 0.5) * 0.5;
                
                camera.position.x += (baseX + shakeX - camera.position.x) * 0.05;
                camera.position.y = baseY + shakeY;
                camera.position.z = baseZ + shakeZ;
                
                camera.lookAt(player.position.x * 0.2, 1, -3);
                
                // Update game timer
                const currentTime = Date.now();
                const elapsedTime = (currentTime - gameState.gameStartTime) / 1000;
                gameState.timeRemaining = Math.max(0, gameState.gameTime - elapsedTime);
                
                // Check for victory (survived 60 seconds!)
                if (gameState.timeRemaining <= 0 && !gameState.isVictory) {
                    victoryGame();
                    return;
                }
                
                // Progressive speed increase - optimized curve for better gameplay
                const timeProgress = 1 - (gameState.timeRemaining / gameState.gameTime); // 0 to 1
                
                // Smoother difficulty curve with multiple phases
                let speedMultiplier;
                if (timeProgress < 0.2) {
                    // Phase 1: Gentle start (0-12s)
                    speedMultiplier = 1 + timeProgress * 2; // 1x to 1.4x
                } else if (timeProgress < 0.5) {
                    // Phase 2: Moderate increase (12-30s)
                    speedMultiplier = 1.4 + (timeProgress - 0.2) * 3; // 1.4x to 2.3x
                } else if (timeProgress < 0.8) {
                    // Phase 3: Challenging (30-48s)
                    speedMultiplier = 2.3 + (timeProgress - 0.5) * 4; // 2.3x to 3.5x
                } else {
                    // Phase 4: Extreme finale (48-60s)
                    speedMultiplier = 3.5 + Math.pow((timeProgress - 0.8) * 5, 1.5) * 2; // 3.5x to 5.5x
                }
                
                // Apply Speed Boost Power-Up multiplier
                if (gameState.speedBoostActive) {
                    speedMultiplier *= 1.5; // 50% speed increase
                }
                
                gameState.speed = gameState.baseSpeed * speedMultiplier;
                gameState.speed = Math.min(gameState.speed, gameState.maxSpeed);
                
                // Update total distance (for milestones)
                gameState.totalDistance += gameState.speed * deltaTime * 10;
                
                // Update environment movement with parallax
                updateEnvironmentMovement(deltaTime);
                
                // Update visual effects based on speed
                updateVisualEffects();
                
                // Update dynamic audio based on speed
                updateDynamicAudio();
                
                // Update moving obstacles animations
                updateMovingObstacles(deltaTime);
                
                // Check collisions
                checkCollisions();
                
                // Check for milestones
                checkMilestones();
                
                // CRITICAL FIX: Process centralized score queue instead of individual updates
                processScoreQueue();
                
                // Keep distance-based scoring (converted to use addScore)
                const timeSinceLastUpdate = (currentTime - (gameState.lastDistanceScore || 0)) / 1000;
                if (timeSinceLastUpdate >= 0.1) { // Every 100ms
                    const distanceScore = Math.floor(gameState.speed * timeSinceLastUpdate * 10);
                    addScore(distanceScore, 'distance');
                    gameState.lastDistanceScore = currentTime;
                }
                
                updateUI();
            }
            
            renderer.render(scene, camera);
        }

        // Handle near miss detection
        function handleNearMiss(obstacle, playerBBox, obstacleBBox) {
            const currentTime = performance.now();
            
            // Prevent multiple near misses for the same obstacle
            if (obstacle.nearMissHandled) return;
            obstacle.nearMissHandled = true;
            
            // Update near miss streak
            if (currentTime - gameState.lastNearMissTime < 5000) { // 5 second window
                gameState.nearMissStreak++;
            } else {
                gameState.nearMissStreak = 1;
            }
            gameState.lastNearMissTime = currentTime;
            
            // Calculate near miss bonus based on distance and streak
            const distance = boundingBoxDistance(playerBBox, obstacleBBox);
            const precision = 1 - (distance / 0.3); // 0.3 is max near miss distance
            let nearMissBonus = Math.floor(50 + (precision * 50)); // 50-100 base points
            
            // Streak multiplier
            nearMissBonus *= Math.min(gameState.nearMissStreak, 5); // Max 5x multiplier
            
            // Add to score
            addScore(nearMissBonus, 'near_miss_bonus');
            
            // Update near miss multiplier
            gameState.nearMissMultiplier = Math.min(gameState.nearMissStreak * 0.2 + 1, 2); // Max 2x
            
            // Show near miss UI
            showNearMissUI(nearMissBonus, gameState.nearMissStreak);
            
            // Audio feedback
            audioManager.createTone(440 + (gameState.nearMissStreak * 110), 0.1, 'sine');
            
            // Visual effect
            createParticleEffect(
                player.position.clone(),
                0xFFD700,
                'nearMiss'
            );
            
            // Camera shake for dramatic effect
            gameState.cameraShakeIntensity = 0.05;
            setTimeout(() => { gameState.cameraShakeIntensity = 0; }, 200);
        }
        
        // Show near miss UI feedback
        function showNearMissUI(bonus, streak) {
            const nearMissDisplay = document.getElementById('nearMissDisplay');
            const nearMissCount = document.getElementById('nearMissCount');
            const nearMissBonus = document.getElementById('nearMissBonus');
            
            if (nearMissDisplay) {
                nearMissDisplay.style.display = 'block';
                nearMissCount.textContent = streak;
                nearMissBonus.textContent = bonus;
                
                // Auto-hide after 2 seconds
                setTimeout(() => {
                    nearMissDisplay.style.display = 'none';
                }, 2000);
            }
        }
        
        // Check and award milestone rewards (FIXED: Based on time, not exploitable score)
        function checkMilestones() {
            const gameTimeElapsed = (performance.now() - gameState.gameStartTime) / 1000;
            const milestoneInterval = 10; // Every 10 seconds of actual gameplay
            const currentMilestone = Math.floor(gameTimeElapsed / milestoneInterval) * milestoneInterval;
            
            // Only award milestone if enough time has passed AND we haven't awarded this one yet
            if (currentMilestone > gameState.lastMilestone && currentMilestone > 0 && gameTimeElapsed >= milestoneInterval) {
                gameState.lastMilestone = currentMilestone;
                
                // Calculate milestone bonus (reasonable amounts)
                const milestoneBonus = Math.min(100, currentMilestone * 2); // Max 100 points per milestone
                addScore(milestoneBonus, 'milestone_bonus');
                
                // Show milestone UI
                showMilestoneUI(currentMilestone, milestoneBonus);
                
                // Audio celebration
                audioManager.play('powerup');
                audioManager.createTone(523, 0.2, 'sine'); // C5
                setTimeout(() => audioManager.createTone(659, 0.2, 'sine'), 100); // E5
                setTimeout(() => audioManager.createTone(784, 0.3, 'sine'), 200); // G5
                
                // Visual celebration
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        createParticleEffect(
                            new THREE.Vector3(
                                player.position.x + (Math.random() - 0.5) * 2,
                                player.position.y + 2,
                                player.position.z
                            ),
                            [0x00FF00, 0xFFD700, 0xFF00FF][i],
                            'success'
                        );
                    }, i * 100);
                }
                
                // BUGFIX: Life awards based on actual game time, not score-based milestones
                const gameTimeElapsed = (performance.now() - gameState.gameStartTime) / 1000;
                const lifeAwardInterval = 20; // Award life every 20 seconds
                const expectedLives = Math.min(5, 3 + Math.floor(gameTimeElapsed / lifeAwardInterval));
                
                if (gameState.lives < expectedLives && currentMilestone >= 1500) {
                    gameState.lives = expectedLives;
                    console.log(`Extra life awarded! Lives: ${gameState.lives} (time: ${gameTimeElapsed.toFixed(1)}s)`);
                }
            }
        }
        
        // Show milestone UI feedback
        function showMilestoneUI(distance, bonus) {
            const milestoneDisplay = document.getElementById('milestoneDisplay');
            const milestoneText = document.getElementById('milestoneText');
            const milestoneBonus = document.getElementById('milestoneBonus');
            const milestoneIcon = document.getElementById('milestoneIcon');
            
            if (milestoneDisplay) {
                milestoneDisplay.style.display = 'block';
                milestoneText.textContent = `${distance}m!`;
                milestoneBonus.textContent = bonus;
                
                // Special icons for major milestones
                if (distance >= 3000) {
                    milestoneIcon.textContent = '🏆';
                } else if (distance >= 2000) {
                    milestoneIcon.textContent = '⭐';
                } else if (distance >= 1000) {
                    milestoneIcon.textContent = '🎯';
                } else {
                    milestoneIcon.textContent = '🏁';
                }
                
                // Auto-hide after 3 seconds
                setTimeout(() => {
                    milestoneDisplay.style.display = 'none';
                }, 3000);
            }
        }
        
        // Update visual effects based on speed and game state
        function updateVisualEffects() {
            const speedRatio = gameState.speed / gameState.maxSpeed;
            
            // Update fog density based on speed
            gameState.targetFogDensity = 0.002 + (speedRatio * 0.003);
            gameState.currentFogDensity += (gameState.targetFogDensity - gameState.currentFogDensity) * 0.1;
            if (scene.fog) {
                scene.fog.density = gameState.currentFogDensity;
            }
            
            // Speed lines effect
            if (speedRatio > 0.5) {
                gameState.speedLineIntensity = Math.min((speedRatio - 0.5) * 2, 1);
                createSpeedLines();
            }
            
            // Vignette effect at high speed
            const vignetteOverlay = document.getElementById('vignetteOverlay');
            if (vignetteOverlay) {
                if (speedRatio > 0.7) {
                    vignetteOverlay.classList.add('active');
                } else {
                    vignetteOverlay.classList.remove('active');
                }
            }
            
            // Motion blur simulation
            if (speedRatio > 0.8 && !gameState.motionBlurActive) {
                gameState.motionBlurActive = true;
                renderer.domElement.style.filter = `blur(${(speedRatio - 0.8) * 2}px)`;
            } else if (speedRatio <= 0.8 && gameState.motionBlurActive) {
                gameState.motionBlurActive = false;
                renderer.domElement.style.filter = 'none';
            }
            
            // Camera shake at extreme speeds
            if (speedRatio > 0.9) {
                gameState.cameraShakeIntensity = (speedRatio - 0.9) * 0.5;
            }
            
            // Update point lights intensity based on environment
            const lights = scene.children.filter(child => child.type === 'PointLight');
            lights.forEach(light => {
                if (gameState.currentEnvironment === 'tunnel') {
                    light.intensity = 0.8;
                } else {
                    light.intensity = 0.5;
                }
            });
        }
        
        // Create speed lines for high-speed effect
        function createSpeedLines() {
            const speedLinesContainer = document.getElementById('speedLines');
            if (!speedLinesContainer || Math.random() > gameState.speedLineIntensity) return;
            
            const speedLine = document.createElement('div');
            speedLine.className = 'speed-line';
            speedLine.style.left = Math.random() * 100 + '%';
            speedLine.style.opacity = gameState.speedLineIntensity;
            
            speedLinesContainer.appendChild(speedLine);
            
            // Remove after animation
            setTimeout(() => {
                speedLine.remove();
            }, 300);
        }
        
        // Enhanced particle effect for collisions
        function createCollisionParticles(position, obstacleType) {
            // Main collision effect
            createParticleEffect(position, 0xFF4444, 'collision');
            
            // Sparks
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const sparkPos = position.clone();
                    sparkPos.x += (Math.random() - 0.5) * 2;
                    sparkPos.y += Math.random() * 2;
                    createParticleEffect(sparkPos, 0xFFFF00, 'spark');
                }, i * 50);
            }
            
            // Screen effects
            screenShake(0.3, 500);
            flashScreen(0xFF0000, 200);
        }
        
        // Flash screen effect
        function flashScreen(color, duration) {
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.top = '0';
            flash.style.left = '0';
            flash.style.width = '100%';
            flash.style.height = '100%';
            flash.style.backgroundColor = `#${color.toString(16)}`;
            flash.style.opacity = '0.3';
            flash.style.pointerEvents = 'none';
            flash.style.zIndex = '100';
            
            document.getElementById('gameContainer').appendChild(flash);
            
            setTimeout(() => {
                flash.style.transition = `opacity ${duration}ms`;
                flash.style.opacity = '0';
                setTimeout(() => flash.remove(), duration);
            }, 10);
        }
        
        // REMOVED: Old updateScoreWithMultipliers function replaced by centralized score system
        
        // Touch control handlers
        function handleTouchStart(event) {
            if (!gameState.isPlaying) return;
            
            const touch = event.touches[0];
            gameState.touchStartX = touch.clientX;
            gameState.touchStartY = touch.clientY;
        }
        
        function handleTouchEnd(event) {
            if (!gameState.isPlaying) return;
            
            const touch = event.changedTouches[0];
            const deltaX = touch.clientX - gameState.touchStartX;
            const deltaY = touch.clientY - gameState.touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (Math.abs(deltaX) > gameState.touchThreshold) {
                    if (deltaX > 0 && gameState.playerLane < 2) {
                        // Swipe right
                        gameState.playerLane++;
                        audioManager.play('whoosh');
                        trackPlayerMove('right', gameState.playerLane);
                    } else if (deltaX < 0 && gameState.playerLane > 0) {
                        // Swipe left
                        gameState.playerLane--;
                        audioManager.play('whoosh');
                        trackPlayerMove('left', gameState.playerLane);
                    }
                }
            } else {
                // Vertical swipe
                if (Math.abs(deltaY) > gameState.touchThreshold) {
                    if (deltaY < 0 && gameState.playerAction === 'running') {
                        // Swipe up - jump
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        audioManager.play('jump');
                        createParticleEffect(
                            new THREE.Vector3(player.position.x, 0.1, player.position.z),
                            0xFFFF00,
                            'jump'
                        );
                        trackPlayerMove('jumping');
                    } else if (deltaY > 0 && gameState.playerAction === 'running') {
                        // Swipe down - duck
                        gameState.playerAction = 'ducking';
                        audioManager.play('duck');
                        trackPlayerMove('ducking');
                    }
                }
            }
        }
        
        function handleTouchMove(event) {
            // Prevent scrolling while playing
            if (gameState.isPlaying) {
                event.preventDefault();
            }
        }

        function onWindowResize() {
            const canvas = document.getElementById('gameCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        // Event listeners
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        
        // Touch event listeners
        gameState.isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (gameState.isTouchDevice) {
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            
            // Auto-release duck after swipe down
            document.addEventListener('touchend', (event) => {
                if (gameState.playerAction === 'ducking') {
                    setTimeout(() => {
                        if (gameState.playerAction === 'ducking') {
                            gameState.playerAction = 'running';
                        }
                    }, 500); // Auto-release after 500ms
                }
            });
        }

        // Debug function for testing
        window.testFunction = function() {
            console.log('Test function works!');
            console.log('THREE object:', typeof THREE);
            console.log('gameState:', gameState);
            console.log('scene:', scene);
            console.log('camera:', camera);
            console.log('renderer:', renderer);
        };

        // Initialize game
        console.log('Starting game initialization...');
        init();
        
        // ==================== GESTURE CONTROL SYSTEM ====================
        
        // Kalman Filter for smoothing
        class KalmanFilter {
            constructor(processNoise = 0.01, measurementNoise = 1) {
                this.processNoise = processNoise;
                this.measurementNoise = measurementNoise;
                this.value = 0;
                this.uncertainty = 1;
            }
            
            filter(measurement) {
                this.uncertainty += this.processNoise;
                const gain = this.uncertainty / (this.uncertainty + this.measurementNoise);
                this.value += gain * (measurement - this.value);
                this.uncertainty *= (1 - gain);
                return this.value;
            }
        }
        
        // Gesture Controller Class
        class GestureController {
            constructor(options = {}) {
                this.options = {
                    videoElement: options.videoElement || null,
                    canvasElement: options.canvasElement || null,
                    onGestureDetected: options.onGestureDetected || (() => {}),
                    onStatsUpdate: options.onStatsUpdate || (() => {}),
                    onError: options.onError || (() => {}),
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5,
                    smoothingFrames: 5,
                    sensitivity: 0.5,
                    debugMode: false
                };
                
                this.isRunning = false;
                this.faceLandmarker = null;
                this.lastVideoTime = -1;
                this.gestureHistory = [];
                this.lastGesture = 'NONE';
                
                this.calibrationData = {
                    neutralYaw: 0,
                    neutralPitch: 0,
                    isCalibrated: false
                };
                
                this.stats = {
                    fps: 0,
                    frameCount: 0,
                    lastFrameTime: performance.now(),
                    faceDetected: false,
                    yaw: 0,
                    pitch: 0
                };
                
                this.kalmanFilter = {
                    yaw: new KalmanFilter(0.01, 1),
                    pitch: new KalmanFilter(0.01, 1)
                };
                
                this.thresholds = {
                    yawLeft: -0.6,
                    yawRight: 0.6,
                    pitchUp: -0.6,
                    pitchDown: 0.6,
                    deadZone: 0.2
                };
                
                this.ctx = this.options.canvasElement ? 
                    this.options.canvasElement.getContext('2d') : null;
                
                this.frameSkipCounter = 0;
                this.frameSkipRate = 2;
            }
            
            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    this.options.videoElement.srcObject = stream;
                    
                    await new Promise((resolve) => {
                        this.options.videoElement.onloadedmetadata = resolve;
                    });
                    
                    try {
                        await this.initializeMediaPipe();
                    } catch (error) {
                        console.error('MediaPipe initialization failed:', error);
                        throw new Error('MediaPipe Vision library not loaded. Please refresh the page.');
                    }
                    
                    this.isRunning = true;
                    this.detectLoop();
                    
                    setTimeout(() => this.calibrate(), 2000);
                    
                } catch (error) {
                    this.options.onError(`Failed to start camera: ${error.message}`);
                    throw error;
                }
            }
            
            stop() {
                this.isRunning = false;
                
                if (this.options.videoElement && this.options.videoElement.srcObject) {
                    const tracks = this.options.videoElement.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    this.options.videoElement.srcObject = null;
                }
                
                if (this.ctx) {
                    this.ctx.clearRect(0, 0, this.options.canvasElement.width, this.options.canvasElement.height);
                }
            }
            
            async initializeMediaPipe() {
                // BUGFIX: Check if MediaPipe is loaded and handle namespace properly
                if (!window.mediapipe || !window.mediapipe.tasks || !window.mediapipe.tasks.vision) {
                    throw new Error('MediaPipe Vision library not loaded yet');
                }
                
                try {
                    const vision = await window.mediapipe.tasks.vision.FilesetResolver.forVisionTasks(
                        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                    );
                    
                    this.faceLandmarker = await window.mediapipe.tasks.vision.FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker_lite/float16/latest/face_landmarker_lite.task",
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true,
                    runningMode: "VIDEO",
                    numFaces: 1,
                    minFaceDetectionConfidence: this.options.minDetectionConfidence,
                    minFacePresenceConfidence: this.options.minDetectionConfidence,
                    minTrackingConfidence: this.options.minTrackingConfidence
                });
                } catch (error) {
                    console.error('Failed to create FaceLandmarker:', error);
                    throw error;
                }
            }
            
            detectLoop() {
                if (!this.isRunning || !this.faceLandmarker) {
                    return;
                }
                
                this.frameSkipCounter++;
                if (this.frameSkipCounter < this.frameSkipRate) {
                    requestAnimationFrame(() => this.detectLoop());
                    return;
                }
                this.frameSkipCounter = 0;
                
                const video = this.options.videoElement;
                const startTimeMs = performance.now();
                
                if (video.readyState >= 2 && this.lastVideoTime !== video.currentTime) {
                    this.lastVideoTime = video.currentTime;
                    
                    const results = this.faceLandmarker.detectForVideo(video, startTimeMs);
                    
                    this.updateFPS();
                    
                    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                        this.processFaceLandmarks(results);
                        this.stats.faceDetected = true;
                    } else {
                        this.stats.faceDetected = false;
                        this.updateGesture('NONE');
                    }
                    
                    if (this.ctx) {
                        this.drawMinimalVisualization();
                    }
                    
                    this.options.onStatsUpdate(this.stats);
                }
                
                requestAnimationFrame(() => this.detectLoop());
            }
            
            processFaceLandmarks(results) {
                const landmarks = results.faceLandmarks[0];
                
                const nose = landmarks[1];
                const forehead = landmarks[9];
                const chin = landmarks[152];
                const leftEar = landmarks[234];
                const rightEar = landmarks[454];
                
                const earDistance = rightEar.x - leftEar.x;
                const faceCenterX = (leftEar.x + rightEar.x) / 2;
                const noseOffsetX = nose.x - faceCenterX;
                let yaw = (noseOffsetX / earDistance) * 2;
                
                const faceHeight = chin.y - forehead.y;
                const noseCenterY = (forehead.y + chin.y) / 2;
                const noseOffsetY = nose.y - noseCenterY;
                let pitch = (noseOffsetY / faceHeight) * 2;
                
                yaw = this.kalmanFilter.yaw.filter(yaw);
                pitch = this.kalmanFilter.pitch.filter(pitch);
                
                this.stats.yaw = yaw * 45;
                this.stats.pitch = pitch * 45;
                
                if (this.calibrationData.isCalibrated) {
                    yaw -= this.calibrationData.neutralYaw;
                    pitch -= this.calibrationData.neutralPitch;
                }
                
                yaw *= this.options.sensitivity * 2;
                pitch *= this.options.sensitivity * 2;
                
                const gesture = this.detectGesture(yaw, pitch);
                this.updateGesture(gesture);
            }
            
            detectGesture(yaw, pitch) {
                const inDeadZone = Math.abs(yaw) < this.thresholds.deadZone && 
                                  Math.abs(pitch) < this.thresholds.deadZone;
                
                if (pitch > this.thresholds.pitchDown) {
                    return 'DUCK';
                } else if (pitch < this.thresholds.pitchUp) {
                    return 'JUMP';
                } else if (yaw < this.thresholds.yawLeft) {
                    return 'MOVE_LEFT';
                } else if (yaw > this.thresholds.yawRight) {
                    return 'MOVE_RIGHT';
                } else if (inDeadZone || this.lastGesture === 'DUCK') {
                    return 'NONE';
                }
                
                return this.lastGesture;
            }
            
            updateGesture(gesture) {
                this.gestureHistory.push(gesture);
                if (this.gestureHistory.length > this.options.smoothingFrames) {
                    this.gestureHistory.shift();
                }
                
                const gestureCount = {};
                this.gestureHistory.forEach(g => {
                    gestureCount[g] = (gestureCount[g] || 0) + 1;
                });
                
                let maxCount = 0;
                let smoothedGesture = 'NONE';
                for (const [g, count] of Object.entries(gestureCount)) {
                    if (count > maxCount) {
                        maxCount = count;
                        smoothedGesture = g;
                    }
                }
                
                if (smoothedGesture !== this.lastGesture) {
                    this.lastGesture = smoothedGesture;
                    this.options.onGestureDetected(smoothedGesture);
                }
            }
            
            calibrate() {
                this.calibrationData.neutralYaw = this.stats.yaw / 45;
                this.calibrationData.neutralPitch = this.stats.pitch / 45;
                this.calibrationData.isCalibrated = true;
                
                if (this.ctx) {
                    const canvas = this.options.canvasElement;
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('KALIBRIERT!', canvas.width / 2, canvas.height / 2);
                    
                    setTimeout(() => {
                        if (this.ctx) {
                            this.ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }
                    }, 1000);
                }
            }
            
            drawMinimalVisualization() {
                const canvas = this.options.canvasElement;
                const video = this.options.videoElement;
                
                canvas.width = 160;
                canvas.height = 120;
                
                this.ctx.save();
                this.ctx.scale(-1, 1);
                this.ctx.drawImage(video, -canvas.width, 0, canvas.width, canvas.height);
                this.ctx.restore();
                
                if (this.stats.faceDetected) {
                    this.ctx.strokeStyle = '#00ff88';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                } else {
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
                }
                
                if (this.lastGesture !== 'NONE') {
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.lastGesture.replace('_', ' '), canvas.width / 2, canvas.height - 10);
                }
            }
            
            updateFPS() {
                this.stats.frameCount++;
                const now = performance.now();
                const elapsed = now - this.stats.lastFrameTime;
                
                if (elapsed >= 1000) {
                    this.stats.fps = (this.stats.frameCount * 1000) / elapsed;
                    this.stats.frameCount = 0;
                    this.stats.lastFrameTime = now;
                }
            }
            
            setSensitivity(value) {
                this.options.sensitivity = Math.max(0.1, Math.min(1, value));
            }
        }
        
        // Global gesture controller instance
        let gestureController = null;
        let gestureEnabled = false;
        
        // Initialize gesture controller
        function initGestureController() {
            // Wait for MediaPipe to load
            if (!window.mediapipe || !window.mediapipe.tasks || !window.mediapipe.tasks.vision) {
                console.warn('MediaPipe not loaded yet, waiting...');
                setTimeout(initGestureController, 500);
                return;
            }
            
            gestureController = new GestureController({
                videoElement: document.getElementById('gestureVideo'),
                canvasElement: document.getElementById('gestureCanvas'),
                onGestureDetected: handleGestureInput,
                onStatsUpdate: updateGestureStats,
                onError: showGestureError
            });
        }
        
        // Handle gesture input
        function handleGestureInput(gesture) {
            if (!gameState.isPlaying || !gestureEnabled) return;
            
            const feedbackEl = document.getElementById('gestureFeedback');
            
            switch (gesture) {
                case 'MOVE_LEFT':
                    if (gameState.playerLane > 0) {
                        gameState.playerLane--;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        trackPlayerMove('left', gameState.playerLane);
                        
                        // Show feedback
                        feedbackEl.textContent = '⬅️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'MOVE_RIGHT':
                    if (gameState.playerLane < 2) {
                        gameState.playerLane++;
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('whoosh', speedMultiplier);
                        trackPlayerMove('right', gameState.playerLane);
                        
                        // Show feedback
                        feedbackEl.textContent = '➡️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'JUMP':
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'jumping';
                        gameState.jumpVelocity = 10;
                        gameState.jumpStartTime = Date.now(); // BUGFIX: Track jump start time
                        
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('jump', speedMultiplier);
                        audioManager.resume();
                        
                        createParticleEffect(
                            new THREE.Vector3(player.position.x, 0.1, player.position.z),
                            0xFFFF00,
                            'jump'
                        );
                        
                        trackPlayerMove('jumping');
                        
                        // Show feedback
                        feedbackEl.textContent = '⬆️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'DUCK':
                    if (gameState.playerAction === 'running') {
                        gameState.playerAction = 'ducking';
                        const speedMultiplier = gameState.speed / gameState.maxSpeed;
                        audioManager.playSpeedDependentSound('duck', speedMultiplier);
                        trackPlayerMove('ducking');
                        
                        // Show feedback
                        feedbackEl.textContent = '⬇️';
                        feedbackEl.classList.add('show');
                        setTimeout(() => feedbackEl.classList.remove('show'), 500);
                    }
                    break;
                    
                case 'NONE':
                    if (gameState.playerAction === 'ducking') {
                        gameState.playerAction = 'running';
                    }
                    break;
            }
        }
        
        // Update gesture stats display
        function updateGestureStats(stats) {
            // Update status text
            const statusEl = document.getElementById('gestureStatus');
            if (stats.faceDetected) {
                statusEl.textContent = `Gesten: Aktiv (${stats.fps.toFixed(0)} FPS)`;
                statusEl.style.color = '#00ff88';
            } else {
                statusEl.textContent = 'Gesten: Kein Gesicht erkannt';
                statusEl.style.color = '#ff4444';
            }
        }
        
        // Show gesture error
        function showGestureError(message) {
            const statusEl = document.getElementById('gestureStatus');
            statusEl.textContent = `Fehler: ${message}`;
            statusEl.style.color = '#ff4444';
            
            // Disable gesture controls
            gestureEnabled = false;
            document.getElementById('gestureToggle').textContent = '🎥 Gesten aktivieren';
            document.getElementById('gestureToggle').classList.remove('active');
            document.getElementById('calibrateBtn').disabled = true;
            document.getElementById('gestureCanvas').classList.remove('active');
        }
        
        // Toggle gesture control
        async function toggleGestureControl() {
            const toggleBtn = document.getElementById('gestureToggle');
            const calibrateBtn = document.getElementById('calibrateBtn');
            const canvas = document.getElementById('gestureCanvas');
            
            if (!gestureController) {
                initGestureController();
            }
            
            if (gestureEnabled) {
                // Disable gesture control
                gestureEnabled = false;
                gestureController.stop();
                toggleBtn.textContent = '🎥 Gesten aktivieren';
                toggleBtn.classList.remove('active');
                calibrateBtn.disabled = true;
                canvas.classList.remove('active');
                document.getElementById('gestureStatus').textContent = 'Gesten: Inaktiv';
            } else {
                // Enable gesture control
                try {
                    await gestureController.start();
                    gestureEnabled = true;
                    toggleBtn.textContent = '🎥 Gesten deaktivieren';
                    toggleBtn.classList.add('active');
                    calibrateBtn.disabled = false;
                    canvas.classList.add('active');
                    document.getElementById('gestureStatus').textContent = 'Gesten: Wird initialisiert...';
                } catch (error) {
                    showGestureError(error.message);
                }
            }
        }
        
        // Calibrate gestures
        function calibrateGestures() {
            if (gestureController && gestureEnabled) {
                gestureController.calibrate();
                const statusEl = document.getElementById('gestureStatus');
                statusEl.textContent = 'Kalibrierung erfolgreich!';
                statusEl.style.color = '#4CAF50';
                setTimeout(() => {
                    updateGestureStats(gestureController.stats);
                }, 2000);
            }
        }
        
        // Make functions globally available
        window.toggleGestureControl = toggleGestureControl;
        window.calibrateGestures = calibrateGestures;
        window.submitHighscore = submitHighscoreInternal;
        window.skipHighscore = skipHighscoreInternal;
        
        // ==================== END GESTURE CONTROL SYSTEM ====================
    </script>
</body>
</html>